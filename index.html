<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <!-- Favicon and App Icons -->
    <link rel="icon" type="image/png" sizes="32x32" href="tuba-icon.png">
    <link rel="icon" type="image/png" sizes="16x16" href="tuba-icon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="tuba-icon.png">
    <link rel="apple-touch-icon" sizes="167x167" href="tuba-icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="tuba-icon.png">
    <link rel="apple-touch-icon" sizes="120x120" href="tuba-icon.png">
    <link rel="apple-touch-icon-precomposed" href="tuba-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="tuba-icon.png">
    <link rel="icon" type="image/png" sizes="512x512" href="tuba-icon.png">
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TUBA">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="msapplication-TileColor" content="#000000">
    <meta name="msapplication-tap-highlight" content="no">
    <meta name="format-detection" content="telephone=no">
    <title>TUBA</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        html {
            -webkit-text-size-adjust: 100%;
        }

        #loginForm input,
        #signupForm input {
            font-size: 16px;
        }

        :root {
            padding-bottom: env (safe-area-inset-bottom);
            padding-left: env (safe-area-inset-left);
            padding-right: env (safe-area-inset-right);
        }

        /* Mobile-specific enhancements */
        html {
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            touch-action: manipulation;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
            padding-bottom: 70px;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
        }

        /* Removed in-app pull-to-refresh styles */

        /* Enhanced touch interactions */
        button,
        .btn,
        .nav-item,
        .stat-card,
        .item,
        .quick-nav-btn {
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            cursor: pointer;
        }

        /* Improved button feedback for mobile */
        button:active,
        .btn:active,
        .nav-item:active,
        .stat-card:active {
            transform: scale(0.98);
            transition: transform 0.1s ease;
        }

        /* Safe area support for notched devices */
        .header {
            padding-top: max(16px, env(safe-area-inset-top));
            padding-left: max(16px, env(safe-area-inset-left));
            padding-right: max(16px, env(safe-area-inset-right));
        }

        .bottom-nav {
            /* Extra breathing room to avoid iPhone home indicator overlap */
            padding-top: 8px;
            padding-bottom: calc(max(0px, env(safe-area-inset-bottom)) + 16px);
            padding-left: max(0px, env(safe-area-inset-left));
            padding-right: max(0px, env(safe-area-inset-right));
        }

        /* Offline banner (non-overlay, sits between header and content) */
        .offline-banner {
            display: none;
            width: 100%;
            background: linear-gradient(145deg, #b71c1c, #7f0000);
            color: #ffffff;
            text-align: center;
            font-size: 12px;
            font-weight: 600;
            padding: 6px 12px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
            position: sticky;
            top: calc(70px + env(safe-area-inset-top));
            z-index: 9998;
        }

        .offline-banner.clickable {
            cursor: pointer;
        }

        /* Auth banner (same style, clickable) */
        .auth-banner {
            background: linear-gradient(145deg, #1976d2, #0d47a1);
            cursor: pointer;
        }

        /* FAB (Floating Action Button) and radial tabs */
        .fab-container {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 8px;
            /* above bottom nav */
            z-index: 1000;
        }

        .fab {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.25);
            background: linear-gradient(145deg, #7b1fa2, #4a148c);
        }

        .fab:active {
            transform: scale(0.98);
        }

        /* FAB hint: subtle pulsing ring to indicate tap */
        .fab.hint::after {
            content: '';
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 72px;
            height: 72px;
            border-radius: 50%;
            box-shadow: 0 0 0 0 rgba(123, 31, 162, 0.5);
            animation: fab-pulse 1.8s ease-out infinite;
        }

        @keyframes fab-pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(123, 31, 162, 0.45);
            }

            70% {
                box-shadow: 0 0 0 14px rgba(123, 31, 162, 0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(123, 31, 162, 0);
            }
        }

        .fab-menu {
            position: absolute;
            left: 50%;
            bottom: 28px;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            pointer-events: none;
            /* enable items only when open */
        }

        .fab-item {
            position: absolute;
            width: 44px;
            height: 44px;
            border-radius: 12px;
            border: none;
            color: #fff;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 18px rgba(0, 0, 0, 0.25);
            background: linear-gradient(145deg, #1976d2, #0d47a1);
            transform: translate(0, 0) scale(0.6);
            opacity: 0;
            transition: transform 0.35s cubic-bezier(.2, .8, .2, 1), opacity 0.25s ease-out;
            overflow: visible;
        }

        .fab-icon {
            pointer-events: none;
            color: #fff;
        }

        .fab-label {
            position: absolute;
            top: 52px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            font-weight: 600;
            color: #222;
            background: rgba(255, 255, 255, 0.95);
            padding: 2px 6px;
            border-radius: 10px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            white-space: nowrap;
            max-width: 96px;
            overflow: hidden;
            text-overflow: ellipsis;
            z-index: 2;
        }

        .fab-item:hover {
            filter: brightness(1.05);
        }

        .fab-container.open .fab-menu {
            pointer-events: auto;
        }

        .fab-container.open .fab-item {
            opacity: 1;
            transform: scale(1);
        }

        @keyframes fab-spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .fab-container.open .fab {
            animation: fab-spin 0.6s ease-out;
        }

        /* Splash screen styles */
        .privacy-blur {
            filter: blur(8px);
            -webkit-filter: blur(8px);
            transition: filter 0.3s ease;
        }

        /* Hide legacy bottom nav in favor of FAB menu */
        .bottom-nav {
            display: none;
        }

        .privacy-toggle-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 12px;
            cursor: pointer;
            box-shadow: 0 4px 16px rgba(102, 126, 234, 0.4), inset 0 -1px 2px rgba(0, 0, 0, 0.2);
            z-index: 50;
            display: none;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            will-change: transform;
        }

        .privacy-toggle-btn.show {
            display: flex;
        }

        .privacy-toggle-btn:hover {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6), inset 0 -1px 2px rgba(0, 0, 0, 0.2);
        }

        .privacy-toggle-btn:active {
            transform: translate(-50%, -50%) scale(0.98);
        }

        .privacy-toggle-btn.bounce {
            animation: bounce 0.6s ease-in-out;
        }

        .privacy-container {
            position: relative;
            margin-bottom: 12px;
        }

        input[readonly] {
            background: rgba(0, 0, 0, 0.05);
            cursor: not-allowed;
            color: #666;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #ffffff 0%, #f5f5f5 100%);
            padding-bottom: 70px;
            overflow-x: hidden;
        }

        body.theme-dark {
            background: linear-gradient(135deg, #0f0f0f 0%, #1a1a1a 100%);
            color: #e0e0e0;
        }

        body.theme-dark .card {
            background: rgba(24, 24, 24, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: #e0e0e0;
        }

        body.theme-dark .bottom-nav {
            background: rgba(24, 24, 24, 0.95);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
        }

        body.theme-dark .nav-item {
            color: #cfcfcf;
        }

        body.theme-dark .nav-item:hover:not(.active) {
            background: rgba(102, 126, 234, 0.14);
        }

        body.theme-dark .item-title {
            color: #e6e6e6;
        }

        body.theme-dark .item-subtitle {
            color: #a8a8a8;
        }

        body.theme-dark .item {
            background: #0f1115;
            border: 1px solid rgba(255, 255, 255, 0.10);
            box-shadow: none;
        }

        body.theme-dark .note-preview {
            background: #0f1115;
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.18), inset 0 1px 0 rgba(255, 255, 255, 0.06);
        }

        body.theme-dark .note-preview:hover {
            box-shadow: 0 12px 30px rgba(102, 126, 234, 0.18), inset 0 1px 0 rgba(255, 255, 255, 0.06);
            border-color: rgba(102, 126, 234, 0.4);
        }

        body.theme-dark .alert-info,
        body.theme-dark .alert-success,
        body.theme-dark .alert-box,
        body.theme-dark .alert-box-danger {
            background: rgba(26, 28, 32, 0.95);
            color: #e6e6e6;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.35);
        }

        body.theme-dark .modal-content {
            background: rgba(24, 24, 24, 0.98);
            border: 1px solid rgba(255, 255, 255, 0.08);
            color: #e0e0e0;
        }

        body.theme-dark .modal-title {
            color: #ffffff;
            text-shadow: none;
        }

        body.theme-dark input,
        body.theme-dark textarea,
        body.theme-dark select {
            background: #0f1115;
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        body.theme-dark input::placeholder,
        body.theme-dark textarea::placeholder {
            color: #9aa0a6;
        }

        body.theme-dark input:focus,
        body.theme-dark textarea:focus,
        body.theme-dark select:focus {
            outline: none;
            border-color: rgba(102, 126, 234, 0.6);
            box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.35);
        }

        body.theme-dark .search-box input {
            background: #0f1115;
            border-color: rgba(255, 255, 255, 0.12);
            color: #e0e0e0;
        }

        body.theme-dark .money-input {
            background: #0f1115;
            color: #e0e0e0;
            border-color: rgba(255, 255, 255, 0.12);
        }

        body.theme-dark .filter-row input,
        body.theme-dark .filter-row select {
            background: #0f1115;
            color: #e0e0e0;
            border-color: rgba(255, 255, 255, 0.12);
        }

        body.theme-dark .float-balance-container {
            background: #121417;
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: none;
        }

        body.theme-dark .float-balance-row {
            border-bottom: 1px solid rgba(255, 255, 255, 0.12);
        }

        body.theme-dark .float-balance-label {
            color: #ffffff;
        }

        body.theme-dark .float-balance-value {
            color: #e0e0e0;
        }

        body.theme-dark .editable-float {
            background: #0f1115;
            border: 1px solid rgba(255, 255, 255, 0.12);
            color: #e0e0e0;
        }

        body.theme-dark .bulk-actions {
            background: #0f1115;
            border: 1px solid rgba(255, 255, 255, 0.12);
            color: #e0e0e0;
            box-shadow: none;
        }

        body.theme-dark .info-box {
            background: #121417;
            color: #e0e0e0;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        body.theme-dark .collapse-btn {
            background: #0f1115;
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.12);
        }

        body.theme-dark .badge {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }

        body.theme-dark .card h1,
        body.theme-dark .card h2,
        body.theme-dark .card h3,
        body.theme-dark .card h4,
        body.theme-dark .card h5,
        body.theme-dark .card h6 {
            color: #ffffff;
        }

        body.theme-dark .form-group label,
        body.theme-dark label,
        body.theme-dark .stat-label,
        body.theme-dark .float-balance-label {
            color: #ffffff;
        }

        .header {
            background: linear-gradient(145deg, #1a1a1a, #000000);
            color: white;
            padding: 16px;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 9999;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-top: max(16px, env(safe-area-inset-top));
            padding-left: max(16px, env(safe-area-inset-left));
            padding-right: max(16px, env(safe-area-inset-right));
        }

        .header h1 {
            font-size: 15px;
            font-weight: 600;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .header-btn {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background: linear-gradient(145deg, #2e7d32, #1b5e20);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(46, 125, 50, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .header-btn:hover {
            box-shadow: 0 6px 20px rgba(46, 125, 50, 0.6), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
        }

        .header-btn:active {
            transform: translateY(-50%) scale(0.95);
            box-shadow: 0 2px 10px rgba(46, 125, 50, 0.4), inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .header-btn-left {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background: linear-gradient(145deg, #1976d2, #0d47a1);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 15px rgba(25, 118, 210, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
            transition: none;
        }

        .header-btn-left:hover {
            box-shadow: 0 4px 15px rgba(25, 118, 210, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
        }

        .header-btn-left:active {
            transform: translateY(-50%);
            box-shadow: 0 4px 15px rgba(25, 118, 210, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
        }

        .content {
            padding: 16px;
            padding-top: calc(70px + env(safe-area-inset-top));
            padding-bottom: calc(90px + env(safe-area-inset-bottom));
            scroll-padding-top: calc(70px + env(safe-area-inset-top));
            scroll-padding-bottom: calc(90px + env(safe-area-inset-bottom));
        }

        .stat-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }

        .stat-card {
            background: linear-gradient(145deg, #1a1a1a, #000000);
            color: white;
            padding: 16px;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: transform 0.3s ease;
            cursor: pointer;
        }

        .stat-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            font-size: 11px;
            opacity: 0.8;
            margin-bottom: 4px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 22px;
            font-weight: 700;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .stat-subvalue {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 4px;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 14px;
            margin-bottom: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12),
                0 1px 3px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.5);
            position: relative;
        }

        .card:hover {
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.2),
                0 1px 3px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        .card h2 {
            font-size: 15px;
            font-weight: 700;
            margin-bottom: 12px;
            color: #1a1a1a;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        .card-header-buttons {
            position: absolute;
            right: 14px;
            top: 10px;
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .save-offline-btn {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 1px;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid rgba(25, 118, 210, 0.35);
            background: linear-gradient(145deg, #1976d2, #0d47a1);
            color: #ffffff;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(13, 71, 161, 0.35);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            width: auto;
            max-width: 160px;
            line-height: 1.2;
        }

        .save-offline-btn>span:first-child {
            font-weight: 700;
        }

        .save-offline-btn .save-offline-sub {
            font-weight: 500;
            font-size: 9px;
            color: #f5f5f5;
        }

        .save-offline-btn:hover {
            box-shadow: 0 10px 28px rgba(102, 126, 234, 0.35);
        }

        @keyframes glowPulse {
            0% {
                box-shadow: 0 6px 18px rgba(102, 126, 234, 0.25);
            }

            50% {
                box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.35), 0 12px 32px rgba(102, 126, 234, 0.35);
            }

            100% {
                box-shadow: 0 6px 18px rgba(102, 126, 234, 0.25);
            }
        }

        @keyframes miniBounce {

            0%,
            100% {
                transform: translateY(0)
            }

            50% {
                transform: translateY(-8px)
            }
        }

        .save-offline-btn.attention {
            animation: miniBounce 0.6s ease-in-out, glowPulse 1.4s ease-in-out 0s 2;
        }

        body.theme-dark .save-offline-btn {
            background: linear-gradient(145deg, #1976d2, #0d47a1);
            color: #ffffff;
            border-color: rgba(25, 118, 210, 0.45);
        }

        body.theme-dark .save-offline-btn .save-offline-sub {
            color: #f5f5f5;
        }

        body.theme-dark .save-offline-btn>span:first-child {
            color: #ffffff;
        }

        body.theme-dark .save-offline-btn:hover {
            box-shadow: 0 10px 28px rgba(102, 126, 234, 0.45);
        }

        @media (max-width: 420px) {
            .save-offline-btn {
                max-width: 140px;
                font-size: 9px;
            }

            .save-offline-btn .save-offline-sub {
                font-size: 8px;
            }
        }

        .quick-nav-btn {
            padding: 4px 8px;
            border: none;
            border-radius: 8px;
            font-size: 10px;
            font-weight: 600;
            color: white;
            cursor: pointer;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.18), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
            white-space: nowrap;
        }

        .quick-nav-btn:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .quick-nav-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2), inset 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        .quick-nav-btn.products {
            background: linear-gradient(145deg, #2e7d32, #1b5e20);
        }

        .quick-nav-btn.categories {
            background: linear-gradient(145deg, #e65100, #bf360c);
        }

        .quick-nav-btn.back {
            background: linear-gradient(145deg, #1976d2, #0d47a1);
        }

        .form-group {
            margin-bottom: 10px;
        }

        .form-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #333;
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
        }

        input,
        select,
        textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        input:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #667eea;
            background: white;
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1), inset 0 2px 5px rgba(0, 0, 0, 0.05);
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        button,
        .btn {
            width: 100%;
            padding: 11px;
            background: linear-gradient(145deg, #1a1a1a, #000000);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            box-shadow: 0 5px 16px rgba(0, 0, 0, 0.28), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
        }

        button:hover {
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.2);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(145deg, #757575, #424242);
        }

        .btn-success {
            background: linear-gradient(145deg, #2e7d32, #1b5e20);
        }

        .btn-danger {
            background: linear-gradient(145deg, #d32f2f, #b71c1c);
        }

        .btn-small {
            padding: 6px 10px;
            font-size: 12px;
            width: auto;
        }

        .item {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 0, 0, 0.08);
            border-radius: 12px;
            padding: 10px;
            margin-bottom: 8px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.07),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        .item:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.12),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        .item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .item-title {
            font-weight: 700;
            font-size: 14px;
            color: #1a1a1a;
        }

        .item-subtitle {
            font-size: 13px;
            color: #666;
            margin-top: 4px;
        }

        .badge {
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 11px;
            font-weight: 700;
            display: inline-block;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .badge-success {
            background: linear-gradient(145deg, #66bb6a, #43a047);
            color: white;
        }

        .badge-warning {
            background: linear-gradient(145deg, #ffeb3b, #fbc02d);
            color: #333;
        }

        .badge-danger {
            background: linear-gradient(145deg, #ef5350, #c62828);
            color: white;
        }

        .badge-paid {
            background: linear-gradient(145deg, #66bb6a, #43a047);
            color: white;
        }

        .badge-unpaid {
            background: linear-gradient(145deg, #ef5350, #c62828);
            color: white;
        }

        .badge-mpesa {
            background: linear-gradient(145deg, #ef5350, #c62828);
            color: white;
        }

        .badge-crdb {
            background: linear-gradient(145deg, #66bb6a, #43a047);
            color: white;
        }

        .badge-nmb {
            background: linear-gradient(145deg, #ff9800, #e65100);
            color: white;
        }

        .badge-yas {
            background: linear-gradient(145deg, #42a5f5, #1976d2);
            color: white;
        }

        .badge-airtel {
            background: linear-gradient(145deg, #d32f2f, #b71c1c);
            color: white;
        }

        .badge-halopesa {
            background: linear-gradient(145deg, #ffeb3b, #fbc02d);
            color: #333;
        }

        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            display: flex;
            overflow-x: auto;
            box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.15);
            z-index: 100;
            padding-bottom: calc(env(safe-area-inset-bottom) + 12px);
            padding-left: env (safe-area-inset-left);
            padding-right: env (safe-area-inset-right);
            touch-action: pan-x;
            column-gap: 8px;
            padding-top: 6px;
        }

        .nav-item {
            flex: 1;
            min-width: 70px;
            max-width: 90px;
            padding: 10px 4px;
            text-align: center;
            cursor: pointer;
            border: none;
            background: transparent;
            color: #666;
            font-size: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            word-wrap: break-word;
            overflow: hidden;
            position: relative;
            border-radius: 12px;
            transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
            border: 2px solid rgba(102, 126, 234, 0.25);
            touch-action: manipulation;
        }

        .nav-item span:last-child {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            width: 100%;
        }

        .nav-item.active {
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: #fff;
            box-shadow: 0 4px 15px rgba(118, 75, 162, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(102, 126, 234, 0.5);
        }

        .nav-item.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 3px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.8);
        }

        .nav-item:hover:not(.active) {
            background: rgba(102, 126, 234, 0.10);
            border-color: rgba(102, 126, 234, 0.35);
        }

        .nav-item:active {
            transform: scale(0.98);
        }

        .nav-icon {
            font-size: 20px;
            line-height: 1;
        }

        .info-box {
            background: linear-gradient(145deg, #f5f5f5, #e0e0e0);
            padding: 12px;
            border-radius: 12px;
            margin-top: 12px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .tsh-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background-color: #222;
            border: 2px solid #fff;
            outline: 1px solid #222;
            font-family: Arial, sans-serif;
            font-size: 10px;
            font-weight: 700;
            color: #fff;
            letter-spacing: -0.5px;
            margin-right: 6px;
            vertical-align: middle;
        }


        @keyframes autofillDetection {
            from {
                opacity: 1;
            }

            to {
                opacity: 1;
            }
        }

        input:-webkit-autofill {
            animation-name: autofillDetection;
            animation-duration: 0.001s;
            animation-iteration-count: 1;
            animation-timing-function: ease;
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .flex-gap {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10001;
            padding: 16px;
            overflow-x: hidden;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 28px;
            max-width: 500px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.5);
            position: relative;
            overflow-wrap: anywhere;
            scrollbar-width: thin;
            scrollbar-color: rgba(102, 126, 234, 0.6) rgba(0, 0, 0, 0.08);
        }

        .modal-content::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        .modal-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.08);
            border-radius: 8px;
        }

        .modal-content::-webkit-scrollbar-thumb {
            background: linear-gradient(145deg, #667eea, #5a67d8);
            border-radius: 8px;
        }

        .modal-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(145deg, #5a67d8, #4c51bf);
        }

        #invBulkHeader {
            display: grid;
        }

        .modal-content input[type="text"],
        .modal-content input[type="email"],
        .modal-content input[type="password"],
        .modal-content input[type="tel"],
        .modal-content input[type="date"],
        .modal-content input[type="time"],
        .modal-content input[type="number"],
        .modal-content textarea,
        .modal-content select {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .modal-content input[type="checkbox"] {
            width: auto;
            height: 16px;
        }

        .checkbox-select {
            width: 16px;
            height: 16px;
            min-width: 16px;
            min-height: 16px;
        }

        .modal-close {
            position: sticky;
            top: 8px;
            float: right;
            z-index: 5;
            width: 28px;
            height: 28px;
            border: none;
            border-radius: 50%;
            background: linear-gradient(145deg, #757575, #424242);
            color: #fff;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
        }

        #invAddBulkBtn.floating-add {
            position: sticky;
            top: 8px;
            float: right;
            z-index: 4;
            margin-right: 40px;
            transition: all 200ms ease;
        }

        @media (max-width: 480px) {
            .modal-content {
                max-width: 95vw;
                padding: 16px;
                border-radius: 16px;
            }

            #inventoryModal .modal-content {
                max-height: 85vh;
            }

            #invToolbar {
                flex-wrap: nowrap;
            }

            #invBulkHeader {
                grid-template-columns: 1fr 1fr !important;
                row-gap: 6px;
                margin-top: 8px !important;
            }

            .inv-bulk-row {
                grid-template-columns: 1fr 1fr !important;
                row-gap: 8px;
            }

            .inv-bulk-row>div:nth-child(5) button {
                width: 100%;
            }

            .grid-2 {
                grid-template-columns: 1fr !important;
            }

            #invAddBulkBtn.floating-add {
                margin-right: 36px;
            }
        }

        .modal-title {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 16px;
            color: #1a1a1a;
            text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
        }

        .bulk-label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #555;
            margin-bottom: 4px;
        }

        select option.opt-new {
            font-weight: 600;
        }

        body.theme-dark select option.opt-new {
            color: #ffd54f;
        }

        .bulk-row {
            display: flex;
            gap: 8px;
            align-items: flex-end;
        }

        .bulk-row .form-group {
            flex: 1 1 200px;
            min-width: 200px;
        }

        .bulk-row .form-group input,
        .bulk-row .form-group select {
            width: 100%;
            box-sizing: border-box;
        }

        .bulk-row button {
            flex: 0 0 auto;
        }

        @media (max-width: 640px) {
            .bulk-row {
                flex-wrap: wrap;
            }

            .bulk-row .form-group {
                flex: 1 1 240px;
                min-width: 240px;
            }
        }

        .toast-bar {
            position: fixed;
            bottom: calc(env(safe-area-inset-bottom) + 80px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: center;
            z-index: 9999;
            pointer-events: none;
            touch-action: pan-x;
        }

        .toast {
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(10px);
            color: #fff;
            padding: 6px 12px;
            border-radius: 12px;
            font-size: 11px;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.2s, transform 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            text-align: center;
            pointer-events: auto;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }


        .toast-success {
            background: linear-gradient(145deg, #2e7d32, #1b5e20);
        }

        .toast-error {
            background: linear-gradient(145deg, #d32f2f, #b71c1c);
        }

        .toast-info {
            background: linear-gradient(145deg, #1976d2, #0d47a1);
        }

        .transaction-tabs {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
            margin-bottom: 16px;
        }

        .transaction-tab {
            padding: 14px 16px;
            border-radius: 16px;
            border: none;
            cursor: pointer;
            font-weight: 600;
            font-size: 13px;
            text-align: center;
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab:hover {
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab:active {
            transform: translateY(0);
        }

        .transaction-tab.mpesa {
            background: linear-gradient(145deg, #d32f2f, #b71c1c);
            opacity: 0.6;
        }

        .transaction-tab.mpesa.active {
            opacity: 1;
            box-shadow: 0 8px 25px rgba(211, 47, 47, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab.crdb {
            background: linear-gradient(145deg, #2e7d32, #1b5e20);
            opacity: 0.6;
        }

        .transaction-tab.crdb.active {
            opacity: 1;
            box-shadow: 0 8px 25px rgba(46, 125, 50, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab.nmb {
            background: linear-gradient(145deg, #e65100, #bf360c);
            opacity: 0.6;
        }

        .transaction-tab.nmb.active {
            opacity: 1;
            box-shadow: 0 8px 25px rgba(230, 81, 0, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab.yas {
            background: linear-gradient(145deg, #0d47a1, #01579b);
            opacity: 0.6;
        }

        .transaction-tab.yas.active {
            opacity: 1;
            box-shadow: 0 8px 25px rgba(13, 71, 161, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab.halopesa {
            background: linear-gradient(145deg, #fdd835, #f9a825);
            color: #000;
            opacity: 0.6;
        }

        .transaction-tab.halopesa.active {
            opacity: 1;
            box-shadow: 0 8px 25px rgba(253, 216, 53, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .transaction-tab.airtel {
            background: linear-gradient(145deg, #b71c1c, #7f0000);
            opacity: 0.6;
        }

        .transaction-tab.airtel.active {
            opacity: 1;
            box-shadow: 0 8px 25px rgba(183, 28, 28, 0.4), inset 0 -2px 5px rgba(0, 0, 0, 0.1);
        }

        .note-preview {
            cursor: pointer;
            max-height: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 4;
            line-clamp: 4;
            -webkit-box-orient: vertical;
            line-height: 1.5;
            background: linear-gradient(145deg, #ffffff, #f5f5f5);
            border: 2px solid rgba(102, 126, 234, 0.2);
            padding: 16px;
            border-radius: 16px;
            margin-bottom: 12px;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
        }

        .note-preview:hover {
            box-shadow: 0 12px 30px rgba(102, 126, 234, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.9);
            border-color: rgba(102, 126, 234, 0.4);
        }

        .note-preview:active {
            transform: translateY(-2px) scale(1.01);
        }

        .collapse-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(145deg, #f8f8f8, #e8e8e8);
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 12px;
            color: #555;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            margin: 12px 0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .collapse-btn:hover {
            background: linear-gradient(145deg, #ffffff, #f0f0f0);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }

        .collapse-btn:active {
            transform: translateY(0);
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.15);
        }

        .collapse-icon {
            font-size: 12px;
            transition: transform 0.3s;
        }

        .collapse-icon.expanded {
            transform: rotate(180deg);
        }

        .highlight-pulse {
            animation: highlightFade 1s ease-out;
        }

        @keyframes highlightFade {
            0% {
                background: rgba(102, 126, 234, 0.3);
                box-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
            }

            100% {
                background: transparent;
                box-shadow: none;
            }
        }

        .search-box {
            margin-bottom: 16px;
        }

        .search-box input {
            background: white;
            border: 2px solid rgba(0, 0, 0, 0.1);
        }

        .filter-row {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .filter-row input,
        .filter-row select {
            flex: 1;
            min-width: 120px;
        }

        .filter-row input[type="date"] {
            position: relative;
        }

        .filter-row input[type="date"]::-webkit-datetime-edit {
            display: block;
            padding: 0;
        }

        .filter-row input[type="date"]::-webkit-datetime-edit-fields-wrapper {
            display: block;
        }

        .filter-row input[type="date"]::-webkit-calendar-picker-indicator {
            position: absolute;
            right: 8px;
            cursor: pointer;
        }

        /* Date input sizing: prevent overflow outside cards */
        input[type="date"] {
            width: 100%;
            max-width: 220px;
            /* keep compact across devices */
            box-sizing: border-box;
            -webkit-appearance: none;
            /* normalize iOS Safari */
            appearance: none;
            height: 36px;
            line-height: 1.2;
            padding: 6px 28px 6px 10px;
            /* space for picker icon */
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 8px;
        }

        .form-group input[type="date"],
        .filter-row input[type="date"] {
            flex: 0 1 220px;
            /* allow shrink/grow but cap width */
            min-width: 0;
            /* avoid flex min-content overflow */
        }

        /* Ensure date inputs can shrink within filter groups on iOS */
        .filter-row .form-group {
            min-width: 0;
            flex: 0 1 auto;
        }

        /* iOS-specific tuning */
        @supports (-webkit-touch-callout: none) {
            input[type="date"] {
                max-width: clamp(140px, 42vw, 220px);
                /* flex-basis mirrors max-width to prevent overflow */
                /* Use both to handle different flex contexts */
            }

            .form-group input[type="date"],
            .filter-row input[type="date"] {
                flex-basis: clamp(140px, 42vw, 220px);
                font-size: 14px;
            }

            .filter-row input[type="date"]::-webkit-calendar-picker-indicator {
                right: 6px;
            }
        }

        /* Inventory page date inputs: uniform and spaced */
        #invFilterFrom,
        #invFilterTo,
        #invDate,
        #invTime {
            width: 100%;
            max-width: 220px;
            margin-top: 4px;
        }

        .alert-box {
            background: linear-gradient(145deg, #fff3e0, #ffe0b2);
            border-left: 4px solid #e65100;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            box-shadow: 0 4px 15px rgba(230, 81, 0, 0.2);
            position: sticky;
            top: calc(70px + env(safe-area-inset-top));
            z-index: 9998;
        }

        .alert-box-danger {
            background: linear-gradient(145deg, #ffebee, #ffcdd2);
            border-left: 4px solid #d32f2f;
            box-shadow: 0 4px 15px rgba(211, 47, 47, 0.2);
            position: sticky;
            top: calc(70px + env(safe-area-inset-top));
            z-index: 9998;
        }

        .alert-success {
            background: linear-gradient(145deg, #e8f5e9, #c8e6c9);
            border-left: 4px solid #2e7d32;
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 16px;
            box-shadow: 0 4px 15px rgba(46, 125, 50, 0.2);
            position: sticky;
            top: calc(70px + env(safe-area-inset-top));
            z-index: 9998;
        }

        .alert-info {
            background: linear-gradient(145deg, #e3f2fd, #bbdefb);
            border-left: 4px solid #1976d2;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 16px;
            box-shadow: 0 4px 15px rgba(25, 118, 210, 0.2);
            position: sticky;
            top: calc(70px + env(safe-area-inset-top));
            z-index: 9998;
        }

        .alert-info {
            background: linear-gradient(145deg, #e3f2fd, #bbdefb);
            border-left: 4px solid #1976d2;
            padding: 12px 16px;
            border-radius: 8px;
            margin-top: 16px;
            box-shadow: 0 4px 15px rgba(25, 118, 210, 0.2);
            position: sticky;
            top: calc(70px + env(safe-area-inset-top));
            z-index: 9998;
        }

        .float-balance-container {
            background: linear-gradient(145deg, #e3f2fd, #bbdefb);
            padding: 16px;
            border-radius: 16px;
            margin-bottom: 16px;
            box-shadow: 0 4px 15px rgba(25, 118, 210, 0.2);
            border: 2px solid rgba(25, 118, 210, 0.3);
        }

        .float-balance-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid rgba(25, 118, 210, 0.2);
        }

        .float-balance-row:last-child {
            border-bottom: none;
        }

        .float-balance-label {
            font-weight: 600;
            color: #0d47a1;
            font-size: 14px;
        }

        .float-balance-value {
            font-weight: 700;
            color: #1a1a1a;
            font-size: 16px;
        }

        .float-balance-value.positive {
            color: #2e7d32;
        }

        .float-balance-value.negative {
            color: #d32f2f;
        }

        .editable-float {
            padding: 8px 12px;
            border: 2px solid rgba(25, 118, 210, 0.3);
            border-radius: 8px;
            background: white;
            font-weight: 700;
            color: #1976d2;
            cursor: pointer;
            display: inline-block;
            min-width: 100px;
            text-align: right;
        }

        .editable-float:hover {
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .progress-bar {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 10px;
            height: 8px;
            margin-top: 8px;
            overflow: hidden;
        }

        .progress-fill {
            background: linear-gradient(90deg, #2e7d32, #66bb6a);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .welcome-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #000000 0%, #1a1a1a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeOut 0.3s ease-in-out 0.5s forwards;
        }

        @keyframes fadeOut {
            to {
                opacity: 0;
                visibility: hidden;
            }
        }

        .welcome-logo {
            font-size: 80px;
            margin-bottom: 20px;
            animation: bounce 1s ease-in-out;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-20px);
            }
        }

        .welcome-title {
            color: white;
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 8px;
            animation: slideUp 0.8s ease-out;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .welcome-subtitle {
            color: #aaa;
            font-size: 14px;
            animation: slideUp 0.8s ease-out 0.2s both;
        }

        .app-container {
            opacity: 0;
            animation: fadeIn 0.3s ease-in-out 0.8s forwards;
        }

        @keyframes fadeIn {
            to {
                opacity: 1;
            }
        }

        .quick-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 12px;
        }

        .quick-stat-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px;
            border-radius: 8px;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        @media (max-width: 640px) {
            .stat-grid {
                grid-template-columns: 1fr;
            }

            .transaction-tabs {
                grid-template-columns: repeat(2, 1fr);
            }

            .filter-row {
                flex-direction: column;
            }

            .filter-row input,
            .filter-row select {
                width: 100%;
            }

            .form-group input[type="date"],
            .filter-row input[type="date"] {
                max-width: 100%;
                flex: 1 1 auto;
            }
        }

        .sync-indicator {
            position: absolute;
            left: 62px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 13px;
            background: linear-gradient(145deg, #2e7d32, #1b5e20);
            color: white;
            display: none;
            white-space: normal;
            /* allow two-line label */
        }

        .sync-indicator.show {
            display: block;
        }

        .sync-indicator.syncing {
            background: linear-gradient(145deg, #1976d2, #0d47a1);
            animation: pulse 1s infinite;
        }

        .sync-indicator.clickable {
            cursor: pointer;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }

        }

        .checkbox-select {
            width: 18px;
            height: 18px;
            cursor: pointer;
            margin-right: 8px;
            accent-color: #1976d2;
        }

        .bulk-actions {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            padding: 12px;
            background: linear-gradient(145deg, #f5f5f5, #e8e8e8);
            border-radius: 12px;
            flex-wrap: wrap;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .bulk-actions label {
            font-size: 13px;
            font-weight: 600;
            color: #333;
            cursor: pointer;
            margin: 0;
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .side-nav {
            position: fixed;
            top: 0;
            left: -220px;
            width: 220px;
            height: 100vh;
            background: linear-gradient(180deg, #1a1a1a 0%, #000000 100%);
            box-shadow: 4px 0 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transition: left 0.3s ease;
            display: flex;
            flex-direction: column;
        }

        .side-nav.open {
            left: 0;
        }

        /* Prevent body scroll when nav is open */
        body.nav-open {
            overflow: hidden;
            position: fixed;
            width: 100%;
        }

        .side-nav-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(3px);
            z-index: 999;
            display: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .side-nav-overlay.show {
            display: block;
            opacity: 1;
        }

        .side-nav-header {
            padding: 16px;
            background: linear-gradient(145deg, #667eea, #764ba2);
            color: white;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-shrink: 0;
        }

        .side-nav-header h2 {
            font-size: 16px;
            font-weight: 700;
            margin: 0;
        }

        .side-nav-title {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .side-nav-sound {
            background: transparent;
            border: none;
            color: white;
            font-size: 18px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .side-nav-sound:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .side-nav-close {
            background: transparent;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: background 0.2s;
        }

        .side-nav-close:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .side-nav-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            color: white;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 1px solid transparent;
            font-size: 13px;
            flex-shrink: 0;
        }

        .side-nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-left-color: #667eea;
        }

        .side-nav-item.active {
            background: rgba(102, 126, 234, 0.2);
            border-left-color: #667eea;
            font-weight: 600;
        }

        .side-nav-icon {
            font-size: 14px;
            width: 16px;
            text-align: center;
            flex-shrink: 0;
        }

        .side-nav-divider {
            height: 1px;
            background: rgba(255, 255, 255, 0.1);
            margin: 4px 0;
        }

        .side-nav-section-title {
            padding: 4px 16px 2px 16px;
            font-size: 10px;
            font-weight: 700;
            color: rgba(255, 255, 255, 0.5);
            text-transform: uppercase;
            letter-spacing: 1px;
            flex-shrink: 0;
        }

        .side-nav-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-bottom: calc(env(safe-area-inset-bottom) + 240px);
        }

        .side-nav-footer {
            padding: 40px 16px;
            text-align: center;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.3);
            flex-shrink: 0;
            padding-bottom: calc(env(safe-area-inset-bottom) + 48px);
        }

        .side-nav-footer-text {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.4;
        }

        .side-nav-footer-brand {
            font-size: 13px;
            font-weight: 700;
            color: white;
            margin-top: 4px;
        }
    </style>
    <!-- Add this line -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2" defer></script>

    <!-- Your existing scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js" defer></script>
</head>

<body>
    <script>
        try {
            var raw = localStorage.getItem('financeManagerData');
            if (raw) {
                var parsed = JSON.parse(raw || '{}');
                if (parsed && parsed.theme === 'dark') {
                    document.body.classList.add('theme-dark');
                }
            }
        } catch (e) { }
        async function initPWA() {
            try {
                if ('serviceWorker' in navigator) {
                    await navigator.serviceWorker.ready;
                    navigator.serviceWorker.addEventListener('message', function (event) {
                        if (event.data && event.data.type === 'sync-queues') {
                            try { upsertQueue.process(); } catch { }
                            try { deleteQueue.process(); } catch { }
                        }
                    });
                }
            } catch { }
        }

        function requestBackgroundSync() {
            try {
                navigator.serviceWorker.ready.then(function (reg) {
                    reg.sync.register('sync-queues');
                });
            } catch { }
        }

        window.addEventListener('load', function () { try { initPWA(); } catch { } });

    </script>
    <div id="hiddenFocusTarget" tabindex="-1"
        style="position:fixed;top:-10000px;left:-10000px;width:1px;height:1px;opacity:0;"></div>
    <!-- Removed in-app pull-to-refresh indicator -->

    <!-- Side Navigation Drawer -->
    <div class="side-nav-overlay" id="sideNavOverlay" onclick="toggleSideNav()"></div>
    <div class="side-nav" id="sideNav">
        <div class="side-nav-header">
            <div class="side-nav-title">
                <h2> TUBA</h2>
                <button class="side-nav-sound" id="sideNavSoundHeaderButton" onclick="toggleSoundNotifications()"
                    title="Toggle sound" aria-label="Toggle sound">
                    <span id="sideNavSoundHeaderIcon"></span>
                </button>
                <button class="side-nav-sound" id="sideNavThemeHeaderButton" onclick="toggleTheme()"
                    title="Toggle theme" aria-label="Toggle theme">
                    <span id="sideNavThemeHeaderIcon"></span>
                </button>
            </div>
            <button class="side-nav-close" onclick="toggleSideNav()" title="Close" aria-label="Close"></button>
        </div>

        <div class="side-nav-content">
            <div class="side-nav-section-title">Main</div>
            <div class="side-nav-item" onclick="navigateToTab('account')">
                <span class="side-nav-icon"></span>
                <span>Profile</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('dashboard')">
                <span class="side-nav-icon"></span>
                <span>Dashboard</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('sales')">
                <span class="side-nav-icon"></span>
                <span>Sales</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('transactions')">
                <span class="side-nav-icon"></span>
                <span>Transactions</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('invoices')">
                <span class="side-nav-icon"></span>
                <span>Invoices</span>
            </div>

            <div class="side-nav-divider"></div>
            <div class="side-nav-section-title">Management</div>
            <div class="side-nav-item" onclick="navigateToTab('products')">
                <span class="side-nav-icon"></span>
                <span>Products/Services</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('categories')">
                <span class="side-nav-icon"></span>
                <span>Categories</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('inventory')">
                <span class="side-nav-icon"></span>
                <span>Stock</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('inventoryPurchases')">
                <span class="side-nav-icon"></span>
                <span>Inventory</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('customers')">
                <span class="side-nav-icon"></span>
                <span>Customers</span>
            </div>

            <div class="side-nav-divider"></div>
            <div class="side-nav-section-title">Finance</div>
            <div class="side-nav-item" onclick="navigateToTab('expenses')">
                <span class="side-nav-icon"></span>
                <span>Expenses</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('unpaid')">
                <span class="side-nav-icon"></span>
                <span>Unpaid</span>
            </div>
            <div class="side-nav-item" onclick="navigateToTab('analytics')">
                <span class="side-nav-icon"></span>
                <span>Analytics</span>
            </div>

            <div class="side-nav-divider"></div>
            <div class="side-nav-section-title">Quick Downloads</div>
            <div class="side-nav-item" onclick="downloadInventoryStockSheetPDF()">
                <span class="side-nav-icon"></span>
                <span>Generate Stock Sheet (PDF)</span>
            </div>
            <div class="side-nav-item" onclick="downloadDailyReportPDF()">
                <span class="side-nav-icon"></span>
                <span>Daily Report (PDF)</span>
            </div>
            <div class="side-nav-item" onclick="downloadSalesReportPDF()">
                <span class="side-nav-icon"></span>
                <span>General Report (PDF)</span>
            </div>
            <div class="side-nav-item" onclick="downloadSalesReportExcel()">
                <span class="side-nav-icon"></span>
                <span>General Report (Excel)</span>
            </div>

            <div class="side-nav-divider"></div>
            <div class="side-nav-section-title">Tools</div>
            <div class="side-nav-item" onclick="navigateToTab('notes')">
                <span class="side-nav-icon"></span>
                <span>Notes</span>
            </div>
            <div class="side-nav-item" id="sideNavSoundButton" onclick="toggleSoundNotifications()">
                <span class="side-nav-icon" id="sideNavSoundIcon"></span>
                <span id="sideNavSoundText">Sound: On</span>
            </div>
        </div>

        <!-- Offline Info Modal -->
        <div class="modal" id="offlineInfoModal">
            <div class="modal-content">
                <button class="modal-close" onclick="closeOfflineInfoModal()"></button>
                <div class="modal-title">Offline Usage</div>
                <div style="font-size: 13px; color: #333; line-height: 1.5;">
                    <p>Youre offline. All changes are saved locally and will sync when youre back online.</p>
                    <p><strong>How to save a local backup:</strong><br>
                        Tap the top-right save button () or click the Consider Local Backup toast to export a JSON
                        file.</p>
                    <p><strong>When back online:</strong><br>
                        Click the sync indicator (Synced   Click to ) to push data silently, or use Account 
                        Push to Cloud.</p>
                    <p><strong>Tip:</strong> You can continue recording sales, products, expenses, etc., while offline 
                        theyll sync later.</p>
                </div>
                <div style="display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end;">
                    <button class="btn-small btn-success" onclick="exportData('Saved', 2000)">Backup Now</button>
                    <button class="btn-small btn-secondary" onclick="closeOfflineInfoModal()">Close</button>
                </div>
            </div>
        </div>


        <div class="modal" id="pdfViewerModal">
            <div class="modal-content"
                style="width: 92%; max-width: 920px; height: 85vh; display: flex; flex-direction: column;">
                <button class="modal-close" onclick="closePdfViewer()"></button>
                <div class="modal-title" id="pdfViewerTitle">PDF Preview</div>
                <div style="flex:1; border:1px solid rgba(0,0,0,0.12); border-radius:8px; overflow:hidden;">
                    <iframe id="pdfIframe" style="width:100%; height:100%;"></iframe>
                </div>
                <div style="display: flex; gap: 8px; margin-top: 12px; justify-content: flex-end;">
                    <button class="btn-small" id="pdfDownloadBtn">Download</button>
                    <button class="btn-small btn-secondary" onclick="closePdfViewer()">Close</button>
                </div>
            </div>
        </div>



        <div class="side-nav-footer">
            <div class="side-nav-footer-text">Empowering Your Business</div>
            <div class="side-nav-footer-brand">The Ultimate Business Architecture (TUBA)</div>
        </div>
    </div>
    <div class="welcome-screen">
        <div class="welcome-logo"></div>
        <div class="welcome-title">
            TUBA
        </div>
        <div class="welcome-subtitle">The Ultimate Business Architecture</div>
    </div>

    <div class="app-container">
        <div class="header">
            <button class="header-btn-left" onclick="toggleSideNav()"></button>
            <div class="sync-indicator" id="syncIndicator">Synced </div>
            <div style="display: flex; flex-direction: column; align-items: center; gap: 2px;">
                <h1 style="margin: 0;"> TUBA</h1>
                <div id="headerDate" style="font-size: 9px; opacity: 0.8; font-weight: 400;"></div>
            </div>
            <div
                style="position: absolute; right: 16px; top: 50%; transform: translateY(-50%); display: flex; gap: 8px;">
                <button
                    style="width: 35px; height: 35px; background: linear-gradient(145deg, #2e7d32, #1b5e20); color: white; border: none; border-radius: 50%; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 3px 10px rgba(46, 125, 50, 0.35), inset 0 -2px 4px rgba(0, 0, 0, 0.18);"
                    onclick="exportData()"></button>
                <button
                    style="width: 35px; height: 35px; background: linear-gradient(145deg, #1976d2, #0d47a1); color: white; border: none; border-radius: 50%; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 3px 10px rgba(25, 118, 210, 0.35), inset 0 -2px 4px rgba(0, 0, 0, 0.18);"
                    onclick="importData()"></button>
                <button
                    style="width: 35px; height: 35px; background: linear-gradient(145deg, #667eea, #764ba2); color: white; border: none; border-radius: 50%; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 3px 10px rgba(102, 126, 234, 0.35), inset 0 -2px 4px rgba(0, 0, 0, 0.18);"
                    onclick="refreshApp()" title="Refresh" aria-label="Refresh"></button>
            </div>
        </div>

        <!-- Offline status banner inserted below header so it does not overlay content -->
        <div id="offlineBanner" class="offline-banner" role="status" aria-live="polite" aria-atomic="true"></div>
        <!-- Not signed-in banner (click to go to Sign In) -->
        <div id="authBanner" class="offline-banner auth-banner" role="status" aria-live="polite" aria-atomic="true">
        </div>

        <div class="content" id="app"></div>
        <div class="bottom-nav" id="bottomNav"></div>
    </div>

    <div class="modal" id="noteModal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeNoteModal()"></button>
            <div class="modal-title">Note Details</div>
            <div id="noteModalContent"></div>
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn-small" onclick="copyNoteFromModal()"> Copy</button>
                <button class="btn-small btn-success" onclick="shareNoteFromModal()"> Send</button>
                <button class="btn-small" onclick="editNoteFromModal()">Edit</button>
                <button class="btn-small btn-secondary" onclick="closeNoteModal()">Close</button>
            </div>
        </div>
    </div>


    <div class="modal" id="cleanupModal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeCleanupModal()"></button>
            <div class="modal-title">Clean Duplicate Records</div>
            <p>This will remove duplicate entries from your local and cloud data based on ID.</p>
            <div style="display: flex; gap: 8px; margin-top: 16px;">
                <button class="btn-small btn-success" onclick="confirmCleanup()">Proceed</button>
                <button class="btn-small btn-secondary" onclick="closeCleanupModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="modal" id="floatModal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeFloatModal()"></button>
            <div class="modal-title">Set Initial Float</div>
            <div id="floatModalContent"></div>
        </div>
    </div>

    <!-- Inventory Purchase Modal -->
    <div class="modal" id="inventoryModal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeInventoryModal()"></button>
            <div class="modal-title">Add Inventory Purchase</div>
            <div id="inventoryModalContent"></div>
            <div class="flex-gap" style="margin-top:12px;">
                <button class="btn-success btn-small" onclick="addInventoryRecord()">Save Purchase</button>
                <button class="btn-secondary btn-small" onclick="closeInventoryModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // ========================================
        // SUPABASE CONFIGURATION
        // ========================================
        const SUPABASE_URL = 'https://tusrkwljhpkylgfrikrw.supabase.co';
        const APP_BASE_URL = 'https://tuba-finances.vercel.app/';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1c3Jrd2xqaHBreWxnZnJpa3J3Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI4ODE1MDcsImV4cCI6MjA3ODQ1NzUwN30.2eWlpXzsxYhw6-Fo5QFOz_DYnoMnUGqrF0vxdSTqueQ';

        let supabase;
        // ===============================
        // ID SANITIZATION & DEDUP HELPERS
        // ===============================
        function ensureItemIDs() {
            const lists = ['sales', 'products', 'expenses', 'customers', 'transactions', 'unpaidEntries', 'notes'];
            lists.forEach(listName => {
                if (!Array.isArray(state[listName])) return;
                state[listName] = state[listName].map(item => {
                    if (!item.id) item.id = generateID(listName);
                    return item;
                });
            });
        }

        function removeDuplicatesByID(arr) {
            const seen = new Set();
            const seenHashes = new Set();

            return arr.filter(item => {
                if (!item.id) return true;

                // Check for ID duplicates
                if (seen.has(item.id)) return false;

                // Check for content duplicates (same data, different IDs)
                const content = { ...item };
                delete content.id;
                delete content.created_at;
                delete content.updated_at;
                const contentHash = JSON.stringify(content);

                if (seenHashes.has(contentHash)) return false;

                seen.add(item.id);
                seenHashes.add(contentHash);
                return true;
            });
        }
        let currentUser = null;
        let syncEnabled = false;
        let autoCloudPullDone = false;

        // Your existing code continues below...
        const SHOP_NAME = "";
        const SHOP_ADDRESS = "";
        const SHOP_PHONE = "";
        const SHOP_EMAIL = "";

        // ========================================
        // SUPABASE FUNCTIONS
        // ========================================

        function initSupabase() {
            try {
                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
                    auth: {
                        persistSession: true,
                        autoRefreshToken: true,
                        detectSessionInUrl: true,
                        multiTab: true,
                        storageKey: 'tuba-auth-token',
                        storage: window.localStorage
                    }
                });

                console.log(' Supabase initialized');

                // Listen for auth state changes
                supabase.auth.onAuthStateChange(async (event, session) => {
                    console.log('Auth event:', event);

                    if (event === 'SIGNED_IN' && session) {
                        currentUser = session.user;
                        syncEnabled = true;
                        // Ensure fresh cloud pull/merge for new session
                        autoCloudPullDone = false;
                        updateSyncIndicator('synced');
                        await maybeAutoPullCloudData();
                    } else if (event === 'SIGNED_OUT') {
                        currentUser = null;
                        syncEnabled = false;
                        // Reset auto-pull flag for next sign-in
                        autoCloudPullDone = false;
                        updateSyncIndicator('offline');
                        render();
                    } else if (event === 'TOKEN_REFRESHED' && session) {
                        console.log(' Token refreshed');
                        currentUser = session.user;
                        syncEnabled = true;
                        autoCloudPullDone = false;
                        await maybeAutoPullCloudData();
                    }
                });

            } catch (error) {
                console.error('Supabase init error:', error);
                syncEnabled = false;
            }
        }

        async function restoreSession() {
            try {
                if (!window.supabase || !supabase || !supabase.auth) return false;
                if (state.autoAuthDisabled) return false;
                const { data: { session }, error } = await supabase.auth.getSession();

                if (error) {
                    console.error('Session restore error:', error);
                    return false;
                }

                if (session) {
                    currentUser = session.user;
                    syncEnabled = true;
                    updateSyncIndicator('synced');

                    // Load user profile
                    try {
                        if (navigator.onLine) {
                            await loadUserProfile();
                        }
                    } catch { }

                    // Only pull cloud data when online
                    if (navigator.onLine) {
                        try {
                            await pullDataFromSupabase();
                        } catch (e) {
                            console.warn('Cloud pull after restore failed:', e);
                        }
                    }

                    console.log(' Session restored successfully (local data preserved)');
                    return true;
                }

                return false;
            } catch (error) {
                console.error('Restore session error:', error);
                return false;
            }
        }

        function hasAnyLocalData() {
            try {
                const nonEmptyArrays = [
                    state.products,
                    state.sales,
                    state.expenses,
                    state.customers,
                    state.invoices,
                    state.receipts,
                    state.notes,
                    state.transactions,
                    state.unpaidEntries,
                    state.categories
                ].some(arr => Array.isArray(arr) && arr.length > 0);

                const hasInventory = state.inventory && Object.keys(state.inventory).length > 0;
                return nonEmptyArrays || hasInventory;
            } catch (e) {
                return false;
            }
        }

        async function maybeAutoPullCloudData() {
            if (!syncEnabled || !currentUser) return;
            if (autoCloudPullDone) return;

            const hasLocal = hasAnyLocalData();
            if (!hasLocal) {
                try {
                    await pullDataFromSupabase();
                } finally {
                    autoCloudPullDone = true;
                }
            }
        }

        async function loadUserProfile() {
            // First, check if we have local profile data
            const localProfile = state.userProfile;
            const hasLocalProfile = localProfile && localProfile.businessName && localProfile.phone && localProfile.address;

            if (!syncEnabled || !currentUser) {
                // Not signed in - use local profile if available
                if (!hasLocalProfile) {
                    // No local profile - set up for first-time entry
                    state.profileEditMode = true;
                    state.profileLoaded = false;
                } else {
                    // Has local profile
                    state.profileEditMode = false;
                    state.profileLoaded = true;
                }
                return;
            }

            // Signed in - check cloud profile
            try {
                const { data, error } = await supabase
                    .from('user_profiles')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .single();

                if (error && error.code !== 'PGRST116') {
                    console.error('Error loading profile:', error);
                    return;
                }

                if (data) {
                    // Cloud profile exists - use it
                    state.userProfile = {
                        businessName: data.business_name || "",
                        email: data.email || currentUser.email || "",
                        phone: data.phone || "",
                        address: data.address || "",
                        country: data.country || "",
                        city: data.city || ""
                    };
                    if (data.logo_url) {
                        state.userLogoPublicUrl = data.logo_url;
                        try {
                            const res = await fetch(data.logo_url);
                            const blob = await res.blob();
                            const reader = new FileReader();
                            const base64 = await new Promise((resolve, reject) => { reader.onload = () => resolve(reader.result); reader.onerror = reject; reader.readAsDataURL(blob); });
                            state.userLogoDataUrl = base64;
                            state.userLogoMime = blob.type.includes('png') ? 'image/png' : 'image/jpeg';
                        } catch (e) {
                            console.warn('Failed to hydrate logo from URL:', e);
                        }
                    }
                    state.profileEditMode = false;
                    state.profileLoaded = true;
                    saveData();
                } else {
                    // No cloud profile
                    if (hasLocalProfile) {
                        // Has local profile - upload it to cloud
                        console.log(' Uploading local profile to cloud...');
                        await createProfileFromLocal();
                    } else {
                        // No profile at all - show edit mode
                        state.profileEditMode = true;
                        state.profileLoaded = false;
                    }
                }
            } catch (error) {
                console.error('Load profile error:', error);
            }
        }

        async function createProfileFromLocal() {
            if (!syncEnabled || !currentUser) return;

            try {
                const { error } = await supabase
                    .from('user_profiles')
                    .insert({
                        user_id: currentUser.id,
                        business_name: state.userProfile.businessName,
                        email: state.userProfile.email || currentUser.email,
                        phone: state.userProfile.phone,
                        address: state.userProfile.address,
                        country: state.userProfile.country || null,
                        city: state.userProfile.city || null,
                        logo_url: state.userLogoPublicUrl || null
                    });

                if (error) {
                    console.error('Error creating profile from local:', error);
                    return false;
                }

                console.log(' Local profile uploaded to cloud');
                state.profileLoaded = true;
                saveData();
                return true;
            } catch (error) {
                console.error('Create profile from local error:', error);
                return false;
            }
        }

        async function createDefaultProfile() {
            if (!syncEnabled || !currentUser) return;

            try {
                const { error } = await supabase
                    .from('user_profiles')
                    .insert({
                        user_id: currentUser.id,
                        business_name: state.userProfile.businessName,
                        email: currentUser.email,
                        phone: state.userProfile.phone,
                        address: state.userProfile.address,
                        country: state.userProfile.country || null,
                        city: state.userProfile.city || null
                    });

                if (error) {
                    console.error('Error creating profile:', error);
                }
            } catch (error) {
                console.error('Create profile error:', error);
            }
        }

        async function saveUserProfile(profileData) {
            // Always save locally first
            state.userProfile = { ...profileData };
            state.profileLoaded = true;
            saveData();

            // If signed in, also save to cloud
            if (syncEnabled && currentUser) {
                try {
                    updateSyncIndicator('syncing');

                    const { error } = await supabase
                        .from('user_profiles')
                        .upsert({
                            user_id: currentUser.id,
                            business_name: profileData.businessName,
                            email: profileData.email,
                            phone: profileData.phone,
                            address: profileData.address,
                            country: profileData.country || null,
                            city: profileData.city || null,
                            logo_url: state.userLogoPublicUrl || null,
                            updated_at: new Date().toISOString()
                        }, {
                            onConflict: 'user_id'
                        });

                    if (error) throw error;

                    // Verify cloud persistence
                    let verified = false;
                    try {
                        const { data: verifyData, error: verifyErr } = await supabase
                            .from('user_profiles')
                            .select('business_name,email,phone,address,country,city,logo_url')
                            .eq('user_id', currentUser.id)
                            .single();
                        if (!verifyErr && verifyData) {
                            const v = verifyData;
                            verified = (
                                String(v.business_name || '') === profileData.businessName &&
                                String(v.email || '') === profileData.email &&
                                String(v.phone || '') === profileData.phone &&
                                String(v.address || '') === profileData.address &&
                                String(v.country || '') === (profileData.country || '') &&
                                String(v.city || '') === (profileData.city || '')
                            );
                        }
                    } catch { }

                    updateSyncIndicator('synced');
                    showToast(verified ? 'Profile saved to cloud' : 'Profile saved; cloud verification pending', verified ? 'success' : 'info');
                } catch (error) {
                    console.error('Save profile to cloud error:', error);
                    updateSyncIndicator('synced');
                    showToast('Profile saved locally (cloud sync failed)', 'info');
                }
            } else {
                console.log(' Profile saved locally');
            }

            return true;
        }

        function getUserProfileData() {
            return {
                businessName: state.userProfile?.businessName || "",
                email: state.userProfile?.email || currentUser?.email || "",
                phone: state.userProfile?.phone || "",
                address: state.userProfile?.address || "",
                country: state.userProfile?.country || "",
                city: state.userProfile?.city || ""
            };
        }

        const COUNTRY_CITY_DATA = {
            "Tanzania": ["Dar es Salaam", "Dodoma", "Arusha", "Mwanza"],
            "Kenya": ["Nairobi", "Mombasa", "Kisumu"],
            "Uganda": ["Kampala", "Entebbe", "Gulu"],
            "Rwanda": ["Kigali", "Butare", "Gisenyi"],
            "South Africa": ["Johannesburg", "Cape Town", "Durban", "Pretoria"],
            "United States": ["New York", "Los Angeles", "Chicago", "Houston"],
            "United Kingdom": ["London", "Manchester", "Birmingham"],
            "India": ["Mumbai", "Delhi", "Bengaluru", "Chennai"],
            "China": ["Beijing", "Shanghai", "Shenzhen", "Guangzhou"]
        };

        function getCountryOptionsHTML() {
            const source = state.countriesCities ? Object.keys(state.countriesCities) : Object.keys(COUNTRY_CITY_DATA);
            return source.sort((a, b) => String(a).localeCompare(String(b))).map(c => `<option value="${c}"></option>`).join("");
        }

        function getCityOptionsHTML(country) {
            const map = state.countriesCities || COUNTRY_CITY_DATA;
            const cities = map[country] || [];
            return cities.sort((a, b) => String(a).localeCompare(String(b))).map(city => `<option value="${city}"></option>`).join("");
        }

        function getCountryOptionsSelectHTML() {
            const source = state.countriesCities ? Object.keys(state.countriesCities) : Object.keys(COUNTRY_CITY_DATA);
            return source.sort((a, b) => String(a).localeCompare(String(b))).map(c => `<option value="${c}">${c}</option>`).join("");
        }

        function getCityOptionsSelectHTML(country) {
            const map = state.countriesCities || COUNTRY_CITY_DATA;
            const cities = map[country] || [];
            return cities.sort((a, b) => String(a).localeCompare(String(b))).map(city => `<option value="${city}">${city}</option>`).join("");
        }

        function onProfileCountrySelect(val) {
            const input = document.getElementById('profileCountry');
            const sel = document.getElementById('profileCountrySelect');
            const citySel = document.getElementById('profileCitySelect');
            const cityInput = document.getElementById('profileCity');
            if (!input || !sel) return;
            if (val === '__manual__') {
                input.style.display = 'block';
                input.value = '';
            } else {
                input.style.display = 'none';
                input.value = val;
            }
            if (citySel) {
                citySel.innerHTML = `<option value="">-- Select City --</option><option value="__manual__">Manual entry</option>` + getCityOptionsSelectHTML(val);
                citySel.disabled = !state.profileEditMode;
                if (cityInput) { cityInput.style.display = 'none'; }
            }
        }

        function onProfileCitySelect(val) {
            const input = document.getElementById('profileCity');
            const sel = document.getElementById('profileCitySelect');
            if (!input || !sel) return;
            if (val === '__manual__' && state.profileEditMode) {
                input.style.display = 'block';
            } else {
                input.style.display = 'none';
                if (val !== '__manual__') input.value = val;
            }
        }

        async function initCountryCityData() {
            if (state.countriesCities) return;
            try {
                const resp = await fetch('https://countriesnow.space/api/v0.1/countries');
                const json = await resp.json();
                if (json && json.data) {
                    const map = {};
                    json.data.forEach(item => { if (item.country) map[item.country] = item.cities || []; });
                    state.countriesCities = map;
                    saveData();
                }
            } catch { }
        }

        function onProfileCountryChange(val) {
            try {
                const list = document.getElementById('profileCityList');
                if (list) list.innerHTML = getCityOptionsHTML(val);
                const cityInput = document.getElementById('profileCity');
                if (cityInput) cityInput.value = '';
            } catch { }
        }

        function updateSyncIndicator(status) {
            const indicator = document.getElementById('syncIndicator');
            if (!indicator) return;

            if (status === 'synced' && syncEnabled) {
                const upCount = (upsertQueue?.items || []).length;
                const delCount = (deleteQueue?.items || []).length;
                indicator.innerHTML = `Synced <br><span style="font-size:9px;opacity:0.9;">Click to </span><br><span style="font-size:9px;opacity:0.8;">Queued: ${upCount}  / ${delCount} </span>`;
                indicator.className = 'sync-indicator show clickable';
                indicator.setAttribute('title', 'Push all data to cloud');
                indicator.onclick = function () {
                    try {
                        pushToCloudSilent();
                        upsertQueue.process();
                        deleteQueue.process();
                    } catch (e) { /* no-op */ }
                };
            } else if (status === 'syncing') {
                indicator.textContent = ' Syncing...';
                indicator.className = 'sync-indicator show syncing';
                indicator.removeAttribute('title');
                indicator.onclick = null;
            } else {
                indicator.className = 'sync-indicator';
                indicator.onclick = null;
            }
        }

        // Silent push-to-cloud for sync indicator click (no confirmation)
        async function pushToCloudSilent() {
            if (!syncEnabled || !currentUser) {
                return showToast('Not signed in', 'error');
            }

            updateSyncIndicator('syncing');
            try {
                await clearAndPushAllData();
                updateSyncIndicator('synced');
                showToast('Data pushed to cloud successfully!', 'success');
            } catch (error) {
                console.error('Push error:', error);
                updateSyncIndicator('synced');
                showToast('Push failed: ' + error.message, 'error');
            }
        }

        async function signUp(email, password) {
            try {
                const { data, error } = await supabase.auth.signUp({ email, password, options: { emailRedirectTo: APP_BASE_URL + '#signup-confirmed' } });
                if (error) throw error;
                showToast('Account created! Check your email to confirm.', 'success');
                return data;
            } catch (error) {
                showToast('Sign up error: ' + error.message, 'error');
                return null;
            }
        }

        async function signIn(email, password) {
            try {
                const { data, error } = await supabase.auth.signInWithPassword({ email, password });
                if (error) throw error;

                currentUser = data.user;
                syncEnabled = true;

                showToast('Signed in successfully!', 'success');

                // Load user profile first
                await loadUserProfile();
                // Hydrate logo base64 for immediate UI/PDF usage
                try { await ensureLogoReady(); } catch (e) { /* no-op */ }
                // Update auth banner visibility
                try { window.updateAuthBanner && window.updateAuthBanner(); } catch (e) { /* no-op */ }

                // Upload logo if selected locally
                // if (state.userLogoDataUrl) {
                //     try { await uploadLogoToSupabase(state.userLogoDataUrl, state.userLogoMime || 'image/png'); } catch (e) { console.warn('Logo upload after sign-in failed:', e); }
                // }

                // Check if local data exists
                const localHasData = state.sales.length > 0 || state.products.length > 0;

                try {
                    if (localHasData) {
                        // Smart merge - combine unique items by ID
                        await smartMergeData();
                        showToast('Local and cloud data merged successfully', 'success');
                    } else {
                        // No local data, just pull from cloud
                        await pullDataFromSupabase();
                        showToast('Cloud data loaded', 'success');
                    }
                } catch (syncError) {
                    console.error('Sync error after sign in:', syncError);
                    showToast('Signed in but sync failed. Try manual sync.', 'error');
                }

                return data;
            } catch (error) {
                console.error('Sign in error:', error);
                showToast('Sign in error: ' + error.message, 'error');
                currentUser = null;
                syncEnabled = false;
                return null;
            }
        }

        async function smartMergeData() {
            try {
                updateSyncIndicator('syncing');
                showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);
                console.log(' Starting smart merge...');

                // Save local data BEFORE pulling from cloud
                const localData = {
                    sales: [...(state.sales || [])],
                    products: [...(state.products || [])],
                    expenses: [...(state.expenses || [])],
                    customers: [...(state.customers || [])],
                    transactions: [...(state.transactions || [])],
                    unpaidEntries: [...(state.unpaidEntries || [])],
                    notes: [...(state.notes || [])],
                    categories: [...(state.categories || [])]
                };

                console.log(' Local data counts:', {
                    sales: localData.sales.length,
                    products: localData.products.length,
                    expenses: localData.expenses.length,
                    customers: localData.customers.length,
                    transactions: localData.transactions.length,
                    unpaidEntries: localData.unpaidEntries.length,
                    notes: localData.notes.length
                });

                // Fetch cloud data directly from Supabase (don't overwrite state yet)
                const cloudData = await fetchCloudDataDirect();

                console.log(' Cloud data counts:', {
                    sales: cloudData.sales.length,
                    products: cloudData.products.length,
                    expenses: cloudData.expenses.length,
                    customers: cloudData.customers.length,
                    transactions: cloudData.transactions.length,
                    unpaidEntries: cloudData.unpaidEntries.length,
                    notes: cloudData.notes.length
                });

                // Enhanced merge function with better duplicate detection
                const mergeByID = (local, cloud, dataType) => {
                    const idMap = new Map();
                    const seenHashes = new Set();

                    // Helper function to create content hash for duplicate detection
                    const createContentHash = (item) => {
                        const content = { ...item };
                        delete content.id;
                        delete content.created_at;
                        delete content.updated_at;
                        // Strip DB-only ownership/meta fields to compare local vs cloud consistently
                        delete content.user_id;
                        delete content.userId;
                        delete content.inserted_at;
                        delete content.deleted_at;
                        return JSON.stringify(content);
                    };

                    // Add cloud items first (they take priority for same IDs)
                    cloud.forEach(item => {
                        if (!item.id) item.id = generateID(dataType);
                        const contentHash = createContentHash(item);

                        idMap.set(item.id, item);
                        seenHashes.add(contentHash);
                    });

                    // Add local items only if ID doesn't exist AND content is unique
                    local.forEach(item => {
                        if (!item.id) item.id = generateID(dataType);
                        const contentHash = createContentHash(item);

                        // Only add if both ID and content are unique
                        if (!idMap.has(item.id) && !seenHashes.has(contentHash)) {
                            idMap.set(item.id, item);
                            seenHashes.add(contentHash);
                        }
                    });

                    return Array.from(idMap.values());
                };

                // Merge each array with proper data type identification
                state.sales = mergeByID(localData.sales, cloudData.sales, 'sales');
                state.products = mergeByID(localData.products, cloudData.products, 'products');
                state.expenses = mergeByID(localData.expenses, cloudData.expenses, 'expenses');
                state.customers = mergeByID(localData.customers, cloudData.customers, 'customers');
                state.transactions = mergeByID(localData.transactions, cloudData.transactions, 'transactions');
                state.unpaidEntries = mergeByID(localData.unpaidEntries, cloudData.unpaidEntries, 'unpaid');
                state.notes = mergeByID(localData.notes, cloudData.notes, 'notes');
                // Categories: merge by name (set uniqueness)
                state.categories = Array.from(new Set([...(localData.categories || []), ...((cloudData.categories) || [])]));

                // Final pass: content-based deduplication per type
                state.sales = deduplicateByContent(state.sales, 'sales');
                state.products = deduplicateByContent(state.products, 'products');
                state.expenses = deduplicateByContent(state.expenses, 'expenses');
                state.customers = deduplicateByContent(state.customers, 'customers');
                state.transactions = deduplicateByContent(state.transactions, 'transactions');
                state.unpaidEntries = deduplicateByContent(state.unpaidEntries, 'unpaid');
                state.notes = deduplicateByContent(state.notes, 'notes');

                console.log(' Merged data counts:', {
                    sales: state.sales.length,
                    products: state.products.length,
                    expenses: state.expenses.length,
                    customers: state.customers.length,
                    transactions: state.transactions.length,
                    unpaidEntries: state.unpaidEntries.length,
                    notes: state.notes.length
                });

                // Save merged data locally
                saveData();

                // Push merged data back to cloud (clear and push to avoid server-side duplicates)
                await clearAndPushAllData();
                updateSyncIndicator('synced');

                console.log(' Smart merge completed successfully');
            } catch (error) {
                console.error('Smart merge error:', error);
                updateSyncIndicator('synced');
                throw error;
            }
        }

        // Helper function to fetch cloud data without overwriting local state
        async function fetchCloudDataDirect() {
            if (!syncEnabled || !currentUser) return {
                sales: [], products: [], expenses: [], customers: [],
                transactions: [], unpaidEntries: [], notes: []
            };

            try {
                const [
                    { data: products },
                    { data: sales },
                    { data: expenses },
                    { data: customers },
                    { data: transactions },
                    { data: unpaidEntries },
                    { data: notes },
                    { data: categories }
                ] = await Promise.all([
                    supabase.from('products').select('*').eq('user_id', currentUser.id),
                    supabase.from('sales').select('*').eq('user_id', currentUser.id),
                    supabase.from('expenses').select('*').eq('user_id', currentUser.id),
                    supabase.from('customers').select('*').eq('user_id', currentUser.id),
                    supabase.from('transactions').select('*').eq('user_id', currentUser.id),
                    supabase.from('unpaid_entries').select('*').eq('user_id', currentUser.id),
                    supabase.from('notes').select('*').eq('user_id', currentUser.id),
                    supabase.from('categories').select('*').eq('user_id', currentUser.id)
                ]);

                return {
                    sales: sales || [],
                    products: products || [],
                    expenses: expenses || [],
                    customers: customers || [],
                    transactions: transactions || [],
                    unpaidEntries: unpaidEntries || [],
                    notes: notes || [],
                    categories: (categories || [])
                        .map(c => (c.name || '').trim())
                        .filter(Boolean)
                };
            } catch (error) {
                console.error('Error fetching cloud data:', error);
                return {
                    sales: [], products: [], expenses: [], customers: [],
                    transactions: [], unpaidEntries: [], notes: [], categories: []
                };
            }
        }

        function getTypeFromItem(item) {
            if (item.productName) return 'sales';
            if (item.cost !== undefined && item.price !== undefined) return 'products';
            if (item.description && item.category) return 'expenses';
            if (item.email !== undefined) return 'customers';
            if (item.channel) return 'transactions';
            if (item.paid !== undefined) return 'unpaid';
            if (item.content) return 'notes';
            return 'unknown';
        }

        async function signOut() {
            playTapSound();
            hapticShort();
            try {
                // Set these first in case signOut fails
                currentUser = null;
                syncEnabled = false;
                updateSyncIndicator('offline');
                try { state.autoAuthDisabled = true; saveData(); } catch { }

                const { error } = await supabase.auth.signOut();
                if (error) {
                    console.error('Sign out error:', error);
                    // Still consider it signed out locally
                }

                showToast('Signed out successfully', 'info');
                try { window.updateAuthBanner && window.updateAuthBanner(); } catch (e) { /* no-op */ }
                render();
            } catch (error) {
                console.error('Sign out error:', error);
                showToast('Signed out (with errors)', 'info');
                try { window.updateAuthBanner && window.updateAuthBanner(); } catch (e) { /* no-op */ }
                render();
            }
        }
        async function pushAllDataToSupabase() {
            if (!syncEnabled || !currentUser) return;

            updateSyncIndicator('syncing');

            try {
                // Sync products
                if (state.products.length > 0) {
                    const productsData = state.products.map(p => ({
                        user_id: currentUser.id,
                        name: p.name,
                        category: p.category || '',
                        cost: p.cost,
                        price: p.price,
                        has_stock: (p.hasStock === false) ? false : true
                    }));
                    const { error } = await supabase
                        .from('products')
                        .upsert(productsData, { onConflict: 'user_id,name,category' });
                    if (error) throw error;
                }

                // Sync categories
                if (state.categories.length > 0) {
                    const categoriesData = state.categories.map(c => ({
                        user_id: currentUser.id,
                        name: c
                    }));
                    const { error } = await supabase
                        .from('categories')
                        .upsert(categoriesData, { onConflict: 'user_id,name' });
                    if (error) console.warn('Categories upsert skipped:', error.message || error);
                }

                // Sync sales
                if (state.sales.length > 0) {
                    const salesData = state.sales.map(s => ({
                        user_id: currentUser.id,
                        date: s.date,
                        time: s.time,
                        timestamp: s.timestamp,
                        product_name: s.productName,
                        customer: s.customer,
                        quantity: s.quantity,
                        cost_per_unit: s.costPerUnit,
                        price_per_unit: s.pricePerUnit,
                        total_cost: s.totalCost,
                        total_price: s.totalPrice,
                        profit: s.profit,
                        payment: s.payment
                    }));
                    const { error } = await supabase
                        .from('sales')
                        .upsert(salesData, { onConflict: 'user_id,timestamp' });
                    if (error) throw error;
                }

                // Sync expenses
                if (state.expenses.length > 0) {
                    const expensesData = state.expenses.map(e => ({
                        user_id: currentUser.id,
                        date: e.date,
                        time: e.time,
                        timestamp: e.timestamp,
                        description: e.description,
                        category: e.category,
                        amount: e.amount,
                        payment: e.payment,
                        comment: e.comment || ''
                    }));
                    const { error } = await supabase
                        .from('expenses')
                        .upsert(expensesData, { onConflict: 'user_id,timestamp' });
                    if (error) throw error;
                }

                // Sync customers
                if (state.customers.length > 0) {
                    const customersData = state.customers.map(c => ({
                        user_id: currentUser.id,
                        name: c.name,
                        email: c.email || '',
                        phone: c.phone || '',
                        address: c.address || '',
                        total_purchases: c.totalPurchases || 0
                    }));
                    const { error } = await supabase
                        .from('customers')
                        .upsert(customersData, { onConflict: 'user_id,name,email' });
                    if (error) throw error;
                }

                // Sync invoices
                if (state.invoices.length > 0) {
                    const invoicesData = state.invoices.map(i => ({
                        user_id: currentUser.id,
                        number: i.number,
                        customer: i.customer,
                        date: i.date,
                        due_date: i.dueDate,
                        items: i.items,
                        amount: i.amount,
                        status: i.status
                    }));
                    const { error } = await supabase
                        .from('invoices')
                        .upsert(invoicesData, { onConflict: 'user_id,number' });
                    if (error) throw error;
                }

                // Sync receipts
                if (state.receipts && state.receipts.length > 0) {
                    const receiptsData = state.receipts.map(r => ({
                        user_id: currentUser.id,
                        number: r.number,
                        customer: r.customer,
                        customer_email: r.customerEmail || '',
                        date: r.date,
                        time: r.time,
                        timestamp: r.timestamp,
                        description: r.description,
                        amount: r.amount,
                        payment_method: r.paymentMethod
                    }));
                    const { error } = await supabase
                        .from('receipts')
                        .upsert(receiptsData, { onConflict: 'user_id,timestamp' });
                    if (error) throw error;
                }

                // Sync inventory
                if (Object.keys(state.inventory).length > 0) {
                    const inventoryData = Object.entries(state.inventory).map(([productName, inv]) => ({
                        user_id: currentUser.id,
                        product_name: productName,
                        stock: inv.stock,
                        min_alert: inv.minAlert
                    }));
                    const { error } = await supabase
                        .from('inventory')
                        .upsert(inventoryData, { onConflict: 'user_id,product_name' });
                    if (error) throw error;
                }

                // Sync notes
                if (state.notes.length > 0) {
                    const notesData = state.notes.map(n => ({
                        user_id: currentUser.id,
                        title: n.title || '',
                        content: n.content,
                        date: n.date,
                        time: n.time,
                        timestamp: n.timestamp
                    }));
                    const { error } = await supabase
                        .from('notes')
                        .upsert(notesData, { onConflict: 'user_id,timestamp' });
                    if (error) throw error;
                }

                // Sync inventory purchase Periods
                if (state.inventoryPurchaseCycles && state.inventoryPurchaseCycles.length > 0) {
                    const periodsData = state.inventoryPurchaseCycles.map(c => ({
                        user_id: currentUser.id,
                        period_number: c.number,
                        title: c.title || '',
                        start_date: c.startDate || null,
                        end_date: c.endDate || null,
                        notes: c.notes || ''
                    }));
                    const { error: periodsErr } = await supabase
                        .from('inventory_purchase_periods')
                        .upsert(periodsData, { onConflict: 'user_id,period_number' });
                    if (periodsErr) throw periodsErr;
                }

                // Sync inventory purchases
                if (state.inventoryPurchases && state.inventoryPurchases.length > 0) {
                    const purchasesData = state.inventoryPurchases.map(p => ({
                        user_id: currentUser.id,
                        period_number: p.cycleNumber,
                        item_name: p.itemName,
                        quantity: p.quantity || 0,
                        unit_cost: p.unitCost || p.buyingPrice || 0,
                        total_cost: p.totalCost || p.buyingPrice || 0,
                        purchase_date: p.purchaseDate,
                        supplier_name: p.supplierName || '',
                        supplier_phone: p.supplierPhone || p.supplierContact || '',
                        supplier_address: p.supplierAddress || '',
                        notes: p.notes || '',
                        timestamp: p.timestamp
                    }));
                    const { error: purchasesErr } = await supabase
                        .from('inventory_purchases')
                        .upsert(purchasesData, { onConflict: 'user_id,timestamp' });
                    if (purchasesErr) throw purchasesErr;
                }

                // Sync transactions
                if (state.transactions.length > 0) {
                    const transactionsData = state.transactions.map(t => ({
                        user_id: currentUser.id,
                        channel: t.channel,
                        customer_name: t.customerName,
                        type: t.type,
                        amount: t.amount,
                        date: t.date,
                        time: t.time,
                        timestamp: t.timestamp
                    }));
                    const { error } = await supabase
                        .from('transactions')
                        .upsert(transactionsData, { onConflict: 'user_id,timestamp' });
                    if (error) throw error;
                }

                // Sync unpaid entries
                if (state.unpaidEntries.length > 0) {
                    const unpaidData = state.unpaidEntries.map(u => ({
                        user_id: currentUser.id,
                        name: u.name,
                        type: u.type,
                        amount: u.amount,
                        date: u.date,
                        time: u.time,
                        timestamp: u.timestamp,
                        paid: u.paid
                    }));
                    const { error } = await supabase
                        .from('unpaid_entries')
                        .upsert(unpaidData, { onConflict: 'user_id,timestamp' });
                    if (error) throw error;
                }

                // Sync transaction floats
                const floatsData = Object.entries(state.transactionFloats).map(([channel, floatData]) => ({
                    user_id: currentUser.id,
                    channel: channel,
                    initial_float: floatData.initial
                }));
                {
                    const { error } = await supabase
                        .from('transaction_floats')
                        .upsert(floatsData, { onConflict: 'user_id,channel' });
                    if (error) console.warn('Transaction floats upsert skipped:', error.message || error);
                }

                // Sync settings
                {
                    const { error } = await supabase
                        .from('settings')
                        .upsert({
                            user_id: currentUser.id,
                            daily_target: state.dailyTarget || 0,
                            monthly_target: state.monthlyTarget || 0
                        }, { onConflict: 'user_id' });
                    if (error) console.warn('Settings upsert skipped:', error.message || error);
                }

                updateSyncIndicator('synced');
            } catch (error) {
                console.error('Push error:', error);
                updateSyncIndicator('synced');
                throw error;
            }
        }

        async function syncAllData() {
            playTapSound();
            hapticShort();
            if (!syncEnabled || !currentUser) return;
            if (isSyncing) {
                console.log('Sync already in progress, skipping...');
                return;
            }

            isSyncing = true;
            updateSyncIndicator('syncing');

            try {
                console.log(' Starting sync...');

                // Check if local data is essentially empty
                const localIsEmpty =
                    state.sales.length === 0 &&
                    state.products.length === 0 &&
                    state.expenses.length === 0;

                if (localIsEmpty) {
                    // Pull from cloud if local is empty
                    console.log(' Local data is empty, pulling from cloud...');
                    await pullDataFromSupabase();
                } else {
                    // Push local data to cloud
                    console.log(' Pushing local data to cloud...');
                    await clearAndPushAllData();
                }

                updateSyncIndicator('synced');
                showToast('Data synced successfully!', 'success');
                console.log(' Sync complete');
                render();
            } catch (error) {
                console.error(' Sync error:', error);
                updateSyncIndicator('synced');
                showToast('Sync failed: ' + error.message, 'error');
            } finally {
                isSyncing = false;
            }
        }

        async function clearAndPushAllData() {
            if (!syncEnabled || !currentUser) return;

            try {
                console.log(' Merging local data to cloud (upsert, no delete)...');
                await pushAllDataToSupabase();
                console.log(' Local data merged to cloud');
            } catch (error) {
                console.error('Merge and push error:', error);
                throw error;
            }
        }

        async function syncInBackground() {
            if (!syncEnabled || !currentUser) return;

            try {
                // Silent background sync - no loading indicators
                await clearAndPushAllData();
                console.log(' Background sync complete');
            } catch (error) {
                console.error(' Background sync error:', error);
                // Don't show error toast for background operations
            }
        }

        async function pullDataFromSupabase() {
            if (!syncEnabled || !currentUser) return;

            try {
                showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);
                console.log(' Pulling data from cloud (parallel)...');

                const uid = currentUser.id;
                const fetch = (table, cols) => supabase.from(table).select(cols).eq('user_id', uid);

                const [
                    productsRes,
                    salesRes,
                    categoriesRes,
                    expensesRes,
                    customersRes,
                    invoicesRes,
                    receiptsRes,
                    inventoryRes,
                    notesRes,
                    transactionsRes,
                    unpaidRes,
                    floatsRes,
                    settingsRes,
                    periodsRes,
                    purchasesRes
                ] = await Promise.all([
                    fetch('products', 'name,category,cost,price,has_stock'),
                    supabase.from('sales').select('date,time,timestamp,product_name,customer,quantity,cost_per_unit,price_per_unit,total_cost,total_price,profit,payment').eq('user_id', uid).order('timestamp', { ascending: false }),
                    fetch('categories', 'name'),
                    fetch('expenses', 'date,time,timestamp,description,category,amount,payment,comment'),
                    fetch('customers', 'name,email,phone,address,total_purchases'),
                    fetch('invoices', 'number,customer,date,due_date,items,amount,status'),
                    fetch('receipts', 'number,customer,customer_email,date,time,timestamp,description,amount,payment_method'),
                    fetch('inventory', 'product_name,stock,min_alert'),
                    fetch('notes', 'title,content,date,time,timestamp'),
                    fetch('transactions', 'channel,customer_name,type,amount,date,time,timestamp'),
                    fetch('unpaid_entries', 'name,type,amount,date,time,timestamp,paid'),
                    fetch('transaction_floats', 'channel,initial_float'),
                    supabase.from('settings').select('daily_target,monthly_target').eq('user_id', uid).single(),
                    fetch('inventory_purchase_periods', 'period_number,title,start_date,end_date,notes'),
                    fetch('inventory_purchases', 'period_number,item_name,quantity,unit_cost,total_cost,purchase_date,supplier_name,supplier_phone,supplier_address,notes,timestamp')
                ]);

                const products = productsRes.data || [];
                if (products.length) {
                    const cloudProducts = products.map(p => ({
                        id: `P-${(p.name || '').toLowerCase().replace(/[^a-z0-9]+/g, '_')}`,
                        name: p.name,
                        category: p.category,
                        cost: parseFloat(p.cost),
                        price: parseFloat(p.price),
                        hasStock: (p.has_stock === false) ? false : true
                    }));
                    state.products = deduplicateByContent([...state.products, ...cloudProducts], 'products');
                }

                const sales = salesRes.data || [];
                if (sales.length) {
                    const cloudSales = sales.map(s => ({
                        id: `S-${s.timestamp}`,
                        date: s.date,
                        time: s.time,
                        timestamp: s.timestamp,
                        productName: s.product_name,
                        customer: s.customer,
                        quantity: s.quantity,
                        costPerUnit: parseFloat(s.cost_per_unit),
                        pricePerUnit: parseFloat(s.price_per_unit),
                        totalCost: parseFloat(s.total_cost),
                        totalPrice: parseFloat(s.total_price),
                        profit: parseFloat(s.profit),
                        payment: s.payment
                    }));
                    state.sales = deduplicateByContent([...state.sales, ...cloudSales], 'sales');
                }

                const categories = categoriesRes.data || [];
                if (categories.length) {
                    const cloudCategories = categories.map(c => (c.name || '').trim()).filter(Boolean);
                    state.categories = Array.from(new Set([...(state.categories || []), ...cloudCategories]));
                }

                const expenses = expensesRes.data || [];
                if (expenses.length) {
                    const cloudExpenses = expenses.map(e => ({
                        id: `E-${e.timestamp}`,
                        date: e.date,
                        time: e.time,
                        timestamp: e.timestamp,
                        description: e.description,
                        category: e.category,
                        amount: parseFloat(e.amount),
                        payment: e.payment,
                        comment: e.comment
                    }));
                    state.expenses = deduplicateByContent([...state.expenses, ...cloudExpenses], 'expenses');
                }

                const customers = customersRes.data || [];
                if (customers.length) {
                    const cloudCustomers = customers.map(c => ({
                        id: `C-${c.name.replace(/\s+/g, '_')}_${Date.now()}`,
                        name: c.name,
                        email: c.email || '',
                        phone: c.phone || '',
                        address: c.address || '',
                        totalPurchases: parseFloat(c.total_purchases || 0)
                    }));
                    state.customers = deduplicateByContent([...state.customers, ...cloudCustomers], 'customers');
                }

                const invoices = invoicesRes.data || [];
                if (invoices.length) {
                    const cloudInvoices = invoices.map(i => ({
                        id: `INV-${i.number}`,
                        number: i.number,
                        customer: i.customer,
                        date: i.date,
                        dueDate: i.due_date,
                        items: i.items,
                        amount: parseFloat(i.amount),
                        status: i.status
                    }));
                    state.invoices = deduplicateByContent([...(state.invoices || []), ...cloudInvoices], 'invoices');
                }

                const receipts = receiptsRes.data || [];
                if (receipts.length) {
                    const cloudReceipts = receipts.map(r => ({
                        id: `RCPT-${r.timestamp}`,
                        number: r.number,
                        customer: r.customer,
                        customerEmail: r.customer_email || '',
                        date: r.date,
                        time: r.time,
                        timestamp: r.timestamp,
                        description: r.description,
                        amount: parseFloat(r.amount),
                        paymentMethod: r.payment_method
                    }));
                    state.receipts = deduplicateByContent([...(state.receipts || []), ...cloudReceipts], 'receipts');
                }

                const inventory = inventoryRes.data || [];
                if (inventory.length) {
                    if (!state.inventory) state.inventory = {};
                    inventory.forEach(item => {
                        const name = item.product_name;
                        if (!(name in state.inventory)) {
                            state.inventory[name] = {
                                stock: parseInt(item.stock) || 0,
                                minAlert: parseInt(item.min_alert) || 5
                            };
                        } else {
                            const existing = state.inventory[name];
                            if (existing.stock == null) existing.stock = parseInt(item.stock) || 0;
                            if (existing.minAlert == null) existing.minAlert = parseInt(item.min_alert) || 5;
                        }
                    });
                }

                const notes = notesRes.data || [];
                if (notes.length) {
                    const cloudNotes = notes.map(n => ({
                        id: `N-${n.timestamp}`,
                        title: n.title || '',
                        content: n.content,
                        date: n.date,
                        time: n.time,
                        timestamp: n.timestamp
                    }));
                    state.notes = deduplicateByContent([...(state.notes || []), ...cloudNotes], 'notes');
                }

                const transactions = transactionsRes.data || [];
                if (transactions.length) {
                    const cloudTransactions = transactions.map(t => ({
                        id: `T-${t.timestamp}`,
                        channel: t.channel,
                        customerName: t.customer_name,
                        type: t.type,
                        amount: parseFloat(t.amount),
                        date: t.date,
                        time: t.time,
                        timestamp: t.timestamp
                    }));
                    state.transactions = deduplicateByContent([...(state.transactions || []), ...cloudTransactions], 'transactions');
                }

                const unpaidEntries = unpaidRes.data || [];
                if (unpaidEntries.length) {
                    const cloudUnpaid = unpaidEntries.map(u => ({
                        id: `U-${u.timestamp}`,
                        name: u.name,
                        type: u.type,
                        amount: parseFloat(u.amount),
                        date: u.date,
                        time: u.time,
                        timestamp: u.timestamp,
                        paid: u.paid
                    }));
                    state.unpaidEntries = deduplicateByContent([...(state.unpaidEntries || []), ...cloudUnpaid], 'unpaid');
                }

                const floats = floatsRes.data || [];
                if (floats.length) {
                    floats.forEach(f => {
                        if (state.transactionFloats[f.channel]) {
                            state.transactionFloats[f.channel].initial = parseFloat(f.initial_float);
                        }
                    });
                }

                const settings = settingsRes.data || null;
                if (settings) {
                    state.dailyTarget = parseFloat(settings.daily_target || 0);
                    state.monthlyTarget = parseFloat(settings.monthly_target || 0);
                }

                const cloudCycles = periodsRes.data || [];
                if (cloudCycles.length) {
                    state.inventoryPurchaseCycles = cloudCycles.map(c => ({
                        id: generateID('invCycle'),
                        number: c.period_number,
                        title: c.title || '',
                        startDate: c.start_date || '',
                        endDate: c.end_date || '',
                        notes: c.notes || ''
                    }));
                }

                const cloudPurchases = purchasesRes.data || [];
                if (cloudPurchases.length) {
                    state.inventoryPurchases = cloudPurchases.map(p => ({
                        id: generateID('invPurchase'),
                        cycleNumber: p.period_number,
                        itemName: p.item_name,
                        quantity: parseInt(p.quantity || 0, 10),
                        unitCost: parseFloat(p.unit_cost || 0),
                        totalCost: parseFloat(p.total_cost || 0),
                        purchaseDate: p.purchase_date || '',
                        supplierName: p.supplier_name || '',
                        supplierPhone: p.supplier_phone || '',
                        supplierAddress: p.supplier_address || '',
                        notes: p.notes || '',
                        timestamp: p.timestamp
                    }));
                }

                calculateFloatBalances();
                saveData();
                render();
            } catch (error) {
                console.error('Pull error:', error);
            }
        }
        async function pushToSupabase(table, data) {
            if (!syncEnabled || !currentUser) return;
            try {
                data.user_id = currentUser.id;
                await supabase.from(table).insert(data);
            } catch (error) {
                console.error(`Error syncing to ${table}:`, error);
            }
        }
        const conflictTargets = {
            products: 'user_id,name,category',
            categories: 'user_id,name',
            sales: 'user_id,timestamp',
            expenses: 'user_id,timestamp',
            customers: 'user_id,name,email',
            invoices: 'user_id,number',
            receipts: 'user_id,timestamp',
            inventory: 'user_id,product_name',
            inventory_purchases: 'user_id,timestamp',
            inventory_purchase_periods: 'user_id,period_number',
            notes: 'user_id,timestamp',
            transactions: 'user_id,timestamp',
            unpaid_entries: 'user_id,timestamp',
            transaction_floats: 'user_id,channel',
            settings: 'user_id'
        };


        const DELETE_QUEUE_KEY = 'tuba-delete-queue-v1';
        const deleteQueue = {
            items: [],
            load() {
                try {
                    const raw = localStorage.getItem(DELETE_QUEUE_KEY);
                    this.items = raw ? JSON.parse(raw) : [];
                } catch { this.items = []; }
            },
            save() {
                try { localStorage.setItem(DELETE_QUEUE_KEY, JSON.stringify(this.items)); } catch { }
            },
            enqueue(table, keySource) {
                this.items.push({
                    id: `${table}-del-${Date.now()}-${Math.random().toString(36).slice(2)}`,
                    table,
                    keySource,
                    attempts: 0,
                    nextTryAt: Date.now() + 1000
                });
                this.save();
                console.log(' Enqueued delete', table, keySource);
            },
            backoffDelay(attempts) {
                const schedule = [1000, 2000, 5000, 10000, 30000, 60000];
                return schedule[Math.min(attempts, schedule.length - 1)];
            },
            buildDeleteKeys(table, src) {
                const k = {};
                switch (table) {
                    case 'sales':
                    case 'expenses':
                    case 'notes':
                    case 'transactions':
                    case 'receipts':
                    case 'unpaid_entries':
                        k.timestamp = src.timestamp;
                        break;
                    case 'invoices':
                        k.number = src.number;
                        break;
                    case 'customers':
                        k.name = src.name;
                        k.email = src.email || '';
                        break;
                    case 'products':
                        k.name = src.name;
                        k.category = src.category || '';
                        break;
                    case 'categories':
                        k.name = typeof src === 'string' ? src : (src.name || src);
                        break;
                    case 'inventory_purchases':
                        k.timestamp = src.timestamp;
                        break;
                    case 'inventory_purchase_periods':
                        k.period_number = src.period_number || src.cycleNumber || src.number;
                        break;
                    default:
                        if (src.timestamp) k.timestamp = src.timestamp;
                        break;
                }
                return k;
            },
            async process() {
                if (!navigator.onLine || !syncEnabled || !currentUser) return;
                if (!Array.isArray(this.items) || this.items.length === 0) return;
                const now = Date.now();
                for (const item of [...this.items]) {
                    if (item.nextTryAt && item.nextTryAt > now) continue;
                    try {
                        const keys = this.buildDeleteKeys(item.table, item.keySource);
                        const { error } = await supabase.from(item.table)
                            .delete()
                            .match({ user_id: currentUser.id, ...keys });
                        if (error) throw error;
                        this.items = this.items.filter(q => q.id !== item.id);
                        this.save();
                        console.log(' Delete queue processed', item.table);
                    } catch (err) {
                        console.warn(' Delete retry scheduled', item.table, err?.message || err);
                        item.attempts = (item.attempts || 0) + 1;
                        item.nextTryAt = Date.now() + this.backoffDelay(item.attempts);
                        this.save();
                    }
                }
            }
        };
        deleteQueue.load();
        setInterval(() => { try { deleteQueue.process(); } catch { } }, 30000);
        window.addEventListener('online', () => { try { deleteQueue.process(); } catch { } });

        async function deleteOne(table, keySource) {
            if (!syncEnabled || !currentUser) {
                try { deleteQueue.enqueue(table, keySource); } catch { }
                return;
            }
            try {
                const keys = deleteQueue.buildDeleteKeys(table, keySource);
                const { error } = await supabase.from(table)
                    .delete()
                    .match({ user_id: currentUser.id, ...keys });
                if (error) throw error;
            } catch (error) {
                console.error(`Delete error on ${table}:`, error);
                try { deleteQueue.enqueue(table, keySource); } catch { }
            }
        }

        // ============================================
        // Offline Upsert Queue with Backoff
        // ============================================
        const UPSERT_QUEUE_KEY = 'tuba-upsert-queue-v1';
        const upsertQueue = {
            items: [],
            load() {
                try {
                    const raw = localStorage.getItem(UPSERT_QUEUE_KEY);
                    this.items = raw ? JSON.parse(raw) : [];
                } catch { this.items = []; }
            },
            save() {
                try { localStorage.setItem(UPSERT_QUEUE_KEY, JSON.stringify(this.items)); } catch { }
            },
            enqueue(table, payload) {
                const conflict = conflictTargets[table] || null;
                this.items.push({
                    id: `${table}-${Date.now()}-${Math.random().toString(36).slice(2)}`,
                    table,
                    payload,
                    conflict,
                    attempts: 0,
                    nextTryAt: Date.now() + 1000
                });
                this.save();
                console.log(' Enqueued upsert', table, payload);
            },
            backoffDelay(attempts) {
                // 1s, 2s, 5s, 10s, 30s, 60s
                const schedule = [1000, 2000, 5000, 10000, 30000, 60000];
                return schedule[Math.min(attempts, schedule.length - 1)];
            },
            async process() {
                if (!navigator.onLine || !syncEnabled || !currentUser) return;
                if (!Array.isArray(this.items) || this.items.length === 0) return;
                const now = Date.now();
                // Work on a shallow copy to avoid mutation issues
                for (const item of [...this.items]) {
                    if (item.nextTryAt && item.nextTryAt > now) continue;
                    try {
                        const data = { ...item.payload, user_id: currentUser.id };
                        if (item.table === 'products') { data.category = data.category || ''; }
                        if (item.conflict) {
                            const { error } = await supabase.from(item.table).upsert(data, { onConflict: item.conflict });
                            if (error) throw error;
                        } else {
                            const { error } = await supabase.from(item.table).upsert(data);
                            if (error) throw error;
                        }
                        // Success: remove from queue
                        this.items = this.items.filter(q => q.id !== item.id);
                        this.save();
                        console.log(' Upsert queue processed', item.table);
                    } catch (err) {
                        console.warn(' Upsert retry scheduled', item.table, err?.message || err);
                        item.attempts = (item.attempts || 0) + 1;
                        item.nextTryAt = Date.now() + this.backoffDelay(item.attempts);
                        // If too many attempts, keep but slow down; do not drop silently
                        this.save();
                    }
                }
            }
        };
        // Initialize queue and periodic processing
        upsertQueue.load();
        setInterval(() => { try { upsertQueue.process(); } catch { } }, 30000);
        window.addEventListener('online', () => { try { upsertQueue.process(); } catch { } });
        async function upsertOne(table, payload) {
            if (!syncEnabled || !currentUser) {
                try { upsertQueue.enqueue(table, payload); } catch { }
                return;
            }
            try {
                const data = { ...payload, user_id: currentUser.id };
                if (table === 'products') { data.category = data.category || ''; }
                const conflict = conflictTargets[table];
                if (conflict) {
                    const { error } = await supabase.from(table).upsert(data, { onConflict: conflict });
                    if (error) throw error;
                } else {
                    const { error } = await supabase.from(table).upsert(data);
                    if (error) throw error;
                }
            } catch (error) {
                console.error(`Upsert error on ${table}:`, error);
                // If offline or error, enqueue for retry
                try { upsertQueue.enqueue(table, payload); } catch { }
            }
        }
        let state = {
            activeTab: 'sales',
            activeTransactionChannel: 'mpesa',
            dashboardPrivacyBlurred: true,
            products: [],
            sales: [],
            expenses: [],
            customers: [],
            invoices: [],
            receipts: [],
            categories: [],
            inventory: {},
            notes: [],
            transactions: [],
            unpaidEntries: [],
            currentNoteIndex: null,
            editingNoteIndex: null,
            collapsedSections: {},
            listExpanded: {},
            selectedItems: {},
            navBusy: false,
            transactionFloats: {
                mpesa: { initial: 0, current: 0 },
                crdb: { initial: 0, current: 0 },
                nmb: { initial: 0, current: 0 },
                airtel: { initial: 0, current: 0 },
                halopesa: { initial: 0, current: 0 },
                yas: { initial: 0, current: 0 }
            },
            inventoryFilters: {
                PeriodNumber: '',
                supplier: '',
                dateFrom: '',
                dateTo: ''
            },
            searchPeriod: '',
            stockSearch: '',
            productSearch: '',
            categorySearch: '',
            customerSearch: '',
            filterDateFrom: '',
            filterDateTo: '',
            filterCategory: '',
            filterCustomer: '',
            dailyTarget: 0,
            monthlyTarget: 0,
            userProfile: {
                businessName: "",
                email: "",
                phone: "",
                address: "",
                country: "",
                city: ""
            },
            // User logo
            userLogoDataUrl: '',
            userLogoMime: '',
            userLogoPublicUrl: '',
            profileEditMode: false,
            profileLoaded: false,
            privacyBlurred: true,  // ADD THIS LINE
            // Daily backup reminder tracking
            backupReminder: { date: '', count: 0 }
            , soundEnabled: true
            , theme: 'light'
            , autoAuthDisabled: false
            , bulkProductRows: []
            , bulkProductStatus: []
        };

        let chartInstance = null;
        let cachedStats = null;
        let lastStatsUpdate = 0;
        let isSyncing = false;
        let idCounters = {              // ADD THIS ENTIRE OBJECT
            sales: 0,
            products: 0,
            expenses: 0,
            customers: 0,
            invoices: 0,
            categories: 0,
            notes: 0,
            transactions: 0,
            unpaid: 0
        };

        function getTodayDateString() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`; // Returns: 2025-01-15
        }

        // Show a backup reminder up to 3 times per day
        function maybeShowBackupReminder() {
            try {
                const today = getTodayDateString();
                if (!state.backupReminder || state.backupReminder.date !== today) {
                    state.backupReminder = { date: today, count: 0 };
                }
                if ((state.backupReminder.count || 0) < 3) {
                    setTimeout(() => {
                        showToast('Consider Local Backup', 'info', null, null, 3000);
                    }, 600);
                    state.backupReminder.count = (state.backupReminder.count || 0) + 1;
                    saveData();
                }
            } catch (e) { /* no-op */ }
        }

        // ID Generation Functions
        function generateID(type) {
            const prefix = {
                'sales': 'S',
                'products': 'P',
                'expenses': 'E',
                'customers': 'C',
                'transactions': 'T',
                'unpaid': 'U',
                'notes': 'N',
                'categories': 'CAT',
                'invoices': 'INV'
            }[type] || 'X';

            let maxId = 0;
            const items = type === 'unpaid' ? state.unpaidEntries : (state[type] || []);

            items.forEach(item => {
                if (item.id && item.id.startsWith(prefix + '-')) {
                    const num = parseInt(item.id.split('-')[1]);
                    if (!isNaN(num) && num > maxId) maxId = num;
                }
            });

            return `${prefix}-${String(maxId + 1).padStart(6, '0')}`;
        }

        function ensureIDs() {
            // Add IDs to existing data
            state.sales.forEach(s => { if (!s.id) s.id = generateID('sales'); });
            state.products.forEach(p => { if (!p.id) p.id = generateID('products'); });
            state.expenses.forEach(e => { if (!e.id) e.id = generateID('expenses'); });
            state.customers.forEach(c => { if (!c.id) c.id = generateID('customers'); });
            state.transactions.forEach(t => { if (!t.id) t.id = generateID('transactions'); });
            state.unpaidEntries.forEach(u => { if (!u.id) u.id = generateID('unpaid'); });
            state.notes.forEach(n => { if (!n.id) n.id = generateID('notes'); });
        }

        function normalizeLegacyBulkTimestamps() {
            try {
                const items = Array.isArray(state.inventoryPurchases) ? state.inventoryPurchases : [];
                const tsGroups = items.reduce((acc, p) => {
                    const key = String(p.timestamp || '');
                    if (!acc[key]) acc[key] = [];
                    acc[key].push(p);
                    return acc;
                }, {});
                Object.keys(tsGroups).forEach(ts => {
                    const group = tsGroups[ts];
                    if (group.length > 1) {
                        group.forEach((p, idx) => {
                            const newTs = Number(ts) + idx;
                            if (p.timestamp !== newTs) {
                                p.timestamp = newTs;
                                try { upsertOne('inventory_purchases', p); } catch { }
                            }
                        });
                    }
                });
                saveData();
            } catch { }
        }

        function formatNumber(num) {
            try {
                if (num === null || num === undefined || isNaN(num)) return '0';
                const n = Math.round(parseFloat(num));
                const fmt = new Intl.NumberFormat(navigator.language || 'en-US');
                return fmt.format(n);
            } catch {
                if (num === null || num === undefined || isNaN(num)) return '0';
                const n = Math.round(parseFloat(num));
                const sign = n < 0 ? '-' : '';
                const abs = Math.abs(n);
                return sign + String(abs).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            }
        }
        function formatMoney(num) { return formatNumber(num); }
        function escapeHTML(str) {
            try {
                return String(str)
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/"/g, '&quot;')
                    .replace(/'/g, '&#39;');
            } catch { return String(str || ''); }
        }
        function parseMoney(str) {
            if (typeof str === 'number') return str;
            if (!str) return 0;
            const cleaned = String(str).replace(/[^0-9\-]/g, '');
            const n = parseInt(cleaned || '0', 10);
            return isNaN(n) ? 0 : n;
        }
        function attachMoneyFormatter(el, { max = 999999999, min = 0 } = {}) {
            if (!el) return;
            const fmt = (v) => formatMoney(Math.max(min, Math.min(max, v)));
            const handle = () => {
                const val = parseMoney(el.value);
                el.dataset.numeric = String(val);
                el.value = fmt(val);
            };
            el.addEventListener('input', handle);
            el.addEventListener('blur', handle);
            // Initialize
            handle();
        }

        function capitalizeFirstWordValue(str) {
            const s = String(str || '');
            const i = s.search(/[A-Za-z]/);
            if (i < 0) return s;
            return s.slice(0, i) + s.charAt(i).toUpperCase() + s.slice(i + 1);
        }

        function attachFirstWordCapitalizer(el) {
            if (!el) return;
            const applyCap = () => {
                try {
                    const start = el.selectionStart;
                    const end = el.selectionEnd;
                    const v = String(el.value || '');
                    const i = v.search(/[A-Za-z]/);
                    if (i >= 0 && v.charAt(i) !== v.charAt(i).toUpperCase()) {
                        el.value = v.slice(0, i) + v.charAt(i).toUpperCase() + v.slice(i + 1);
                        if (typeof start === 'number' && typeof end === 'number' && el.setSelectionRange) {
                            el.setSelectionRange(start, end);
                        }
                    }
                } catch { }
            };
            el.addEventListener('input', applyCap);
            el.addEventListener('blur', applyCap);
            applyCap();
        }

        function loadData() {
            const saved = localStorage.getItem('financeManagerData');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    state = { ...state, ...parsed };

                    // Ensure userProfile exists
                    if (!state.userProfile) {
                        state.userProfile = {
                            businessName: "",
                            email: "",
                            phone: "",
                            address: "",
                            country: "",
                            city: ""
                        };
                    }

                    // Ensure profileEditMode exists
                    if (state.profileEditMode === undefined) {
                        state.profileEditMode = false;
                    }

                    if (state.soundEnabled === undefined) {
                        state.soundEnabled = true;
                    }

                    if (state.theme === undefined || !state.theme) {
                        state.theme = 'light';
                    }

                    // Calculate current float balances
                    calculateFloatBalances();
                } catch (e) {
                    console.error('Error loading data:', e);
                }
            }
        }

        // Logo helpers
        // function triggerLogoUpload() {
        //     const input = document.createElement('input');
        //     input.type = 'file';
        //     input.accept = 'image/png,image/jpeg';
        //     input.onchange = async (e) => {
        //         const file = e.target.files && e.target.files[0];
        //         if (!file) return;
        //         try {
        //             const resized = await resizeImageFile(file, 256);
        //             state.userLogoDataUrl = resized.dataUrl;
        //             state.userLogoMime = resized.mime;
        //             saveData();
        //             render();
        //             if (syncEnabled && currentUser) {
        //                 await uploadLogoToSupabase(resized.dataUrl, resized.mime);
        //             }
        //             showToast('Logo saved', 'success');
        //         } catch (err) {
        //             console.error('Logo upload error:', err);
        //             showToast('Failed to process logo', 'error');
        //         }
        //     };
        //     input.click();
        // }

        async function resizeImageFile(file, size = 256) {
            const img = document.createElement('img');
            const reader = new FileReader();
            const mime = file.type.includes('png') ? 'image/png' : 'image/jpeg';
            const dataUrl = await new Promise((resolve, reject) => {
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = reject;
                img.src = dataUrl;
            });

            const canvas = document.createElement('canvas');
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, size, size);
            // contain image
            const ratio = Math.min(size / img.width, size / img.height);
            const w = Math.round(img.width * ratio);
            const h = Math.round(img.height * ratio);
            const x = Math.round((size - w) / 2);
            const y = Math.round((size - h) / 2);
            ctx.drawImage(img, x, y, w, h);
            const outDataUrl = canvas.toDataURL(mime, 0.92);
            return { dataUrl: outDataUrl, mime };
        }

        // async function uploadLogoToSupabase(dataUrl, mime = 'image/png') {
        //     try {
        //         if (!supabase || !currentUser) return;
        //         const blob = await (await fetch(dataUrl)).blob();
        //         const ext = mime === 'image/png' ? 'png' : 'jpg';
        //         const path = `${currentUser.id}/logo.${ext}`;
        //         const { error: upErr } = await supabase.storage.from('logos').upload(path, blob, { upsert: true, contentType: mime });
        //         if (upErr) { console.error('Supabase storage upload error:', upErr); return; }
        //         const { data: pub } = supabase.storage.from('logos').getPublicUrl(path);
        //         if (pub && pub.publicUrl) {
        //             state.userLogoPublicUrl = pub.publicUrl;
        //             saveData();
        //             // Persist into profile for portability (create if missing)
        //             try {
        //                 const { error: upsertErr } = await supabase
        //                     .from('user_profiles')
        //                     .upsert({ user_id: currentUser.id, logo_url: state.userLogoPublicUrl }, { onConflict: 'user_id' });
        //                 if (upsertErr) console.warn('Failed to upsert logo_url to profile:', upsertErr);
        //             } catch (e) { console.warn('Failed to save logo_url to profile:', e); }
        //         }
        //     } catch (e) {
        //         console.error('Upload logo error:', e);
        //     }
        // }

        function getLogoForPdf() {
            const dataUrl = state.userLogoDataUrl || '';
            if (!dataUrl) return null;
            const format = dataUrl.startsWith('data:image/png') ? 'PNG' : 'JPEG';
            return { dataUrl, format };
        }

        // Ensure logo base64 is hydrated before PDF generation
        async function ensureLogoReady() {
            if (state.userLogoDataUrl) return true;
            if (state.userLogoPublicUrl) {
                try {
                    const res = await fetch(state.userLogoPublicUrl, { cache: 'no-cache' });
                    const blob = await res.blob();
                    const reader = new FileReader();
                    const base64 = await new Promise((resolve, reject) => {
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                    state.userLogoDataUrl = base64;
                    state.userLogoMime = blob.type.includes('png') ? 'image/png' : 'image/jpeg';
                    saveData();
                    return true;
                } catch (e) {
                    console.warn('ensureLogoReady: failed to hydrate logo from URL', e);
                }
            }
            return false;
        }

        // Draw logo inside a circular placeholder, clipped to the circle and filling it
        function drawLogo(doc, x, y, size, options = {}) {
            const logo = getLogoForPdf();
            if (!logo) return false;

            const {
                borderColor = [180, 180, 180],
                borderWidth = 1
            } = options;

            const cx = x + size / 2;
            const cy = y + size / 2;
            const r = size / 2;

            try {
                // Clip to circle and draw image to fully fill the circle
                doc.saveGraphicsState();
                doc.beginPath();
                doc.circle(cx, cy, r);
                doc.clip();
                doc.addImage(logo.dataUrl, logo.format, x, y, size, size);
                doc.restoreGraphicsState();

                // Circle border on top
                doc.setDrawColor(...borderColor);
                doc.setLineWidth(borderWidth);
                doc.circle(cx, cy, r, 'S');
                return true;
            } catch (e) {
                console.warn('Logo draw error:', e);
                return false;
            }
        }

        function saveData() {
            cachedStats = null; // Clear cache when data changes
            try {
                localStorage.setItem('financeManagerData', JSON.stringify(state));
            } catch (e) {
                console.error('Error saving data:', e);
                showToast('Error saving data!', 'error');
            }
        }

        function calculateFloatBalances() {
            // Reset to initial values
            Object.keys(state.transactionFloats).forEach(channel => {
                state.transactionFloats[channel].current = state.transactionFloats[channel].initial;
            });

            // Apply all transactions
            (state.transactions || []).forEach(t => {
                if (state.transactionFloats[t.channel]) {
                    if (t.type === 'deposit') {
                        state.transactionFloats[t.channel].current += t.amount;
                    } else if (t.type === 'withdrawal') {
                        state.transactionFloats[t.channel].current -= t.amount;
                    }
                }
            });
        }

        function getStats() {
            const currentTime = Date.now();

            // Return cached stats if less than 3 seconds old
            if (cachedStats && (currentTime - lastStatsUpdate) < 3000) {
                return cachedStats;
            }

            const totalCapital = state.sales.reduce((sum, s) => sum + (s.totalCost || 0), 0);
            const totalProfit = state.sales.reduce((sum, s) => sum + (s.profit || 0), 0);
            const totalRevenue = state.sales.reduce((sum, s) => sum + (s.totalPrice || 0), 0);

            const today = getTodayDateString();
            const todaySales = state.sales.filter(s => s.date === today);
            const todayProfit = todaySales.reduce((sum, s) => sum + (s.profit || 0), 0);
            const todayRevenue = todaySales.reduce((sum, s) => sum + (s.totalPrice || 0), 0);

            const yesterdayDate = new Date(Date.now() - 86400000);
            const yesterday = `${yesterdayDate.getFullYear()}-${String(yesterdayDate.getMonth() + 1).padStart(2, '0')}-${String(yesterdayDate.getDate()).padStart(2, '0')}`;
            const yesterdayProfit = state.sales.filter(s => s.date === yesterday).reduce((sum, s) => sum + (s.profit || 0), 0);

            const now = new Date();
            const monthStartDate = new Date(now.getFullYear(), now.getMonth(), 1);
            const monthStart = `${monthStartDate.getFullYear()}-${String(monthStartDate.getMonth() + 1).padStart(2, '0')}-${String(monthStartDate.getDate()).padStart(2, '0')}`;
            const monthSales = state.sales.filter(s => new Date(s.date) >= new Date(monthStart));
            const monthProfit = monthSales.reduce((sum, s) => sum + (s.profit || 0), 0);
            const monthRevenue = monthSales.reduce((sum, s) => sum + (s.totalPrice || 0), 0);

            const totalExpenses = state.expenses.reduce((sum, e) => sum + (e.amount || 0), 0);
            const monthExpenses = state.expenses.filter(e => new Date(e.date) >= new Date(monthStart)).reduce((sum, e) => sum + (e.amount || 0), 0);

            const totalInvoiced = state.invoices.reduce((sum, inv) => sum + (inv.amount || 0), 0);
            const totalPaid = state.invoices.filter(inv => inv.status === 'Paid').reduce((sum, inv) => sum + (inv.amount || 0), 0);

            const netProfit = totalProfit - totalExpenses;
            const monthNetProfit = monthProfit - monthExpenses;

            cachedStats = {
                totalCapital,
                totalProfit,
                totalRevenue,
                todayProfit,
                todayRevenue,
                yesterdayProfit,
                monthProfit,
                monthRevenue,
                monthNetProfit,
                totalExpenses,
                monthExpenses,
                totalInvoiced,
                totalPaid,
                netProfit,
                totalSalesCount: state.sales.length,
                todaySalesCount: todaySales.length
            };

            lastStatsUpdate = now;
            return cachedStats;
        }


        const tabs = [
            { id: 'dashboard', label: 'Dashboard', icon: '' },
            { id: 'account', label: 'Account', icon: '' },  // ADD THIS LINE
            { id: 'sales', label: 'Sales', icon: '' },
            { id: 'transactions', label: 'Money', icon: '' },
            { id: 'products', label: 'Products/Services', icon: '' },
            { id: 'categories', label: 'Categories', icon: '' },
            { id: 'expenses', label: 'Expenses', icon: '' },
            { id: 'inventory', label: 'Stock', icon: '' },
            { id: 'inventoryPurchases', label: 'Inventory', icon: '' },
            { id: 'customers', label: 'Customers', icon: '' },
            { id: 'invoices', label: 'Invoices & Receipts', icon: '' },
            { id: 'analytics', label: 'Analytics', icon: '' },
            { id: 'unpaid', label: 'Unpaid', icon: '' },
            { id: 'notes', label: 'Notes', icon: '' }
        ];

        function renderNav() {
            const nav = document.getElementById('bottomNav');
            nav.innerHTML = tabs.map(tab => `
                <button class="nav-item ${state.activeTab === tab.id ? 'active' : ''}" data-tab="${tab.id}" onclick="switchTab('${tab.id}')">
                    <span class="nav-icon">${tab.icon}</span>
                    <span>${tab.label}</span>
                </button>
            `).join('');
        }

        (function setupGlobalModalAccessibility() {
            try {
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        try { closeNoteModal(); } catch { }
                        try { closeInventoryModal(); } catch { }
                        try { closeCleanupModal(); } catch { }
                        try { closePdfViewer(); } catch { }
                        try { closeOfflineInfoModal && closeOfflineInfoModal(); } catch { }
                        try { closeFloatModal(); } catch { }
                    }
                });
            } catch { }
        })();

        function switchTab(tabId) {
            if (state.navBusy) return;
            state.navBusy = true;
            try { hapticShort(); } catch { }
            state.activeTab = tabId;
            try { window.scrollTo({ top: 0, behavior: 'instant' }); } catch { try { window.scrollTo(0, 0); } catch { } }
            // Reset privacy blur when switching away from sales
            if (tabId !== 'sales') {
                state.privacyBlurred = true;
            }
            if (tabId !== 'dashboard') {
                state.dashboardPrivacyBlurred = true;
            }
            state.listExpanded = {};
            state.listShowCount = {};
            state.collapsedSections = {};
            state.inventoryPeriodsShowCount = 3;
            state.unpaidEntriesShowCount = 2;
            state.paidEntriesShowCount = 2;
            render();
            if (tabId === 'unpaid') {
                setTimeout(() => {
                    try {
                        if (state.scrollToUnpaidAfterNav) {
                            const target = document.getElementById('unpaidEntriesCard');
                            if (target) target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            state.scrollToUnpaidAfterNav = false;
                        } else {
                            const content = document.querySelector('.content');
                            if (content && typeof content.scrollTo === 'function') {
                                content.scrollTo({ top: 0, behavior: 'smooth' });
                            }
                        }
                    } catch (e) { }
                }, 100);
            }
            setTimeout(() => { state.navBusy = false; }, 250);
        }

        function goToUnpaidFromDashboard() {
            try { playTapSound(); } catch { }
            state.scrollToUnpaidAfterNav = true;
            switchTab('unpaid');
        }

        function refreshApp() {
            try { window.location.reload(); } catch (e) { }
        }

        // FAB features removed; bottom tabs restored

        function showToast(message, type = "info", actionText = null, actionHandler = null, durationMs = 3000, onClickHandler = null) {
            let bar = document.getElementById('toastBar');
            if (!bar) {
                bar = document.createElement('div');
                bar.id = 'toastBar';
                bar.className = 'toast-bar';
                document.body.appendChild(bar);
            }

            const t = document.createElement('div');
            t.className = 'toast toast-' + type;
            const key = (type + ':' + message).toLowerCase();
            t.setAttribute('data-key', key);
            try {
                const existing = Array.from(bar.querySelectorAll('.toast')).find(el => el.getAttribute('data-key') === key);
                if (existing) {
                    existing.classList.remove('show');
                    setTimeout(() => existing.remove(), 0);
                }
            } catch { }
            const span = document.createElement('span');
            span.textContent = message;
            t.appendChild(span);
            if (actionText && typeof actionHandler === 'function') {
                const btn = document.createElement('button');
                btn.textContent = actionText;
                btn.style.cssText = 'margin-left:8px; padding:4px 8px; font-size:10px; border-radius:8px; border:none; background:#fff; color:#000; cursor:pointer;';
                btn.onclick = (e) => { e.stopPropagation(); try { actionHandler(); } finally { t.classList.remove('show'); setTimeout(() => t.remove(), 150); } };
                t.appendChild(btn);
            }
            if (typeof onClickHandler === 'function') {
                t.onclick = () => { try { onClickHandler(); } finally { t.classList.remove('show'); setTimeout(() => t.remove(), 150); } };
            }
            bar.prepend(t);
            requestAnimationFrame(() => t.classList.add('show'));
            setTimeout(() => { t.classList.remove('show'); setTimeout(() => t.remove(), 300); }, Math.max(1000, durationMs || 3000));
        }

        function hapticShort() {
            const n = navigator;
            if (!n || typeof n.vibrate !== 'function') return;
            const ua = navigator.userAgent || navigator.vendor || window.opera;
            const isMobile = /Android|iPhone|iPad|iPod/i.test(ua);
            if (!isMobile) return;
            try { n.vibrate(30); } catch (e) { }
        }

        async function playTapSound() {
            if (state && state.soundEnabled === false) return;
            try {
                let a = window.__tapSoundAudio;
                if (a) {
                    try {
                        const base = a.src.split('?')[0];
                        a.src = base + '?v=' + Date.now();
                        a.load();
                    } catch (e) { }
                    try { a.volume = 0.5; } catch (e) { }
                    try { a.currentTime = 0; } catch (e) { }
                    await a.play();
                    return;
                }
                const srcs = ['button audio.mp3', 'tap.mp3', 'tap.wav'];
                for (let i = 0; i < srcs.length; i++) {
                    const url = encodeURI(srcs[i]) + '?v=' + Date.now();
                    const candidate = new Audio(url);
                    candidate.preload = 'auto';
                    candidate.volume = 0.5;
                    try { candidate.currentTime = 0; } catch (e) { }
                    try {
                        await candidate.play();
                        window.__tapSoundAudio = candidate;
                        return;
                    } catch (e) { }
                }
            } catch (e) { }
            try {
                let ctx = window.__tapAudioContext;
                if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
                window.__tapAudioContext = ctx;
                try { await ctx.resume(); } catch (e) { }
                const o = ctx.createOscillator();
                const g = ctx.createGain();
                o.type = 'square';
                o.frequency.value = 600;
                g.gain.value = 0.05;
                o.connect(g);
                g.connect(ctx.destination);
                o.start();
                setTimeout(() => { try { o.stop(); o.disconnect(); g.disconnect(); } catch (e) { } }, 60);
            } catch (e) { }
        }

        async function playDeleteSound() {
            if (state && state.soundEnabled === false) return;
            try {
                let a = window.__deleteSoundAudio;
                if (a) {
                    try {
                        const base = a.src.split('?')[0];
                        a.src = base + '?v=' + Date.now();
                        a.load();
                    } catch (e) { }
                    try { a.volume = 0.5; } catch (e) { }
                    try { a.currentTime = 0; } catch (e) { }
                    await a.play();
                    return;
                }
                const srcs = ['delete sound.mp3', 'delete.mp3', 'delete.wav'];
                for (let i = 0; i < srcs.length; i++) {
                    const url = encodeURI(srcs[i]) + '?v=' + Date.now();
                    const candidate = new Audio(url);
                    candidate.preload = 'auto';
                    candidate.volume = 0.5;
                    try { candidate.currentTime = 0; } catch (e) { }
                    try {
                        await candidate.play();
                        window.__deleteSoundAudio = candidate;
                        return;
                    } catch (e) { }
                }
            } catch (e) { }
            try {
                let ctx = window.__deleteAudioContext;
                if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
                window.__deleteAudioContext = ctx;
                try { await ctx.resume(); } catch (e) { }
                const o = ctx.createOscillator();
                const g = ctx.createGain();
                o.type = 'square';
                o.frequency.value = 250;
                g.gain.value = 0.05;
                o.connect(g);
                g.connect(ctx.destination);
                o.start();
                setTimeout(() => { try { o.stop(); o.disconnect(); g.disconnect(); } catch (e) { } }, 80);
            } catch (e) { }
        }

        async function downloadPDFSafe(doc, filename) {
            try {
                const ua = navigator.userAgent || navigator.vendor || window.opera;
                const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                const isAndroid = /Android/i.test(ua);
                const blob = doc.output('blob');
                const url = URL.createObjectURL(blob);

                // iOS: prefer share sheet if supported, else open viewer in new tab
                if (isIOS) {
                    if (navigator.share && navigator.canShare) {
                        try {
                            const file = new File([blob], filename, { type: 'application/pdf' });
                            if (navigator.canShare({ files: [file] })) {
                                await navigator.share({ files: [file], title: filename, text: APP_BASE_URL });
                                setTimeout(() => { try { URL.revokeObjectURL(url); } catch { } }, 10000);
                                return;
                            }
                        } catch { }
                    }
                    const w = window.open(url, '_blank');
                    if (w && typeof w.focus === 'function') { w.focus(); setTimeout(() => { try { URL.revokeObjectURL(url); } catch { } }, 10000); return; }
                }

                // Android: use native viewer (new tab), fallback to same-tab navigation
                if (isAndroid) {
                    const triggerDownload = () => {
                        try {
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = filename;
                            document.body.appendChild(a);
                            a.click();
                            setTimeout(() => { try { URL.revokeObjectURL(url); } catch { } a.remove(); }, 1000);
                        } catch { }
                    };
                    const w = window.open(url, '_blank');
                    if (w && typeof w.focus === 'function') { w.focus(); triggerDownload(); return; }
                    try { window.location.assign(url); triggerDownload(); return; } catch { }
                }

                // Other platforms or fallbacks: trigger direct download
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { try { URL.revokeObjectURL(url); } catch { } a.remove(); }, 1000);
            } catch {
                try { doc.save(filename); } catch { }
            }
        }

        let __pdfViewerURL = null;
        let __pdfFilename = 'document.pdf';
        function openPdfViewer(url, filename) {
            __pdfFilename = filename || 'document.pdf';
            const modal = document.getElementById('pdfViewerModal');
            const iframe = document.getElementById('pdfIframe');
            const btn = document.getElementById('pdfDownloadBtn');
            const titleEl = document.getElementById('pdfViewerTitle');
            iframe.src = url;
            modal.classList.add('show');
            modal.setAttribute('aria-modal', 'true');
            const handleOutside = (e) => { if (e.target === modal) { closePdfViewer(); } };
            modal.addEventListener('click', handleOutside, { once: true });
            if (titleEl) {
                try { titleEl.textContent = 'PDF Preview  ' + __pdfFilename; } catch { }
            }
            btn.onclick = function () {
                (async function () {
                    try {
                        const ua = navigator.userAgent || navigator.vendor || window.opera;
                        const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
                        if (isIOS && navigator.share && navigator.canShare) {
                            let blob;
                            try {
                                const res = await fetch(url);
                                blob = await res.blob();
                            } catch { }
                            if (blob) {
                                const file = new File([blob], __pdfFilename, { type: 'application/pdf' });
                                if (navigator.canShare({ files: [file] })) {
                                    try { await navigator.share({ files: [file], title: __pdfFilename }); return; } catch { }
                                }
                            }
                        }
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = __pdfFilename;
                        document.body.appendChild(a);
                        a.click();
                        setTimeout(() => { a.remove(); }, 100);
                    } catch { }
                })();
            };
            __pdfViewerURL = url;
        }
        function closePdfViewer() {
            const modal = document.getElementById('pdfViewerModal');
            const iframe = document.getElementById('pdfIframe');
            const titleEl = document.getElementById('pdfViewerTitle');
            modal.classList.remove('show');
            iframe.src = '';
            if (titleEl) {
                try { titleEl.textContent = 'PDF Preview'; } catch { }
            }
            if (__pdfViewerURL && __pdfViewerURL.startsWith('blob:')) {
                try { URL.revokeObjectURL(__pdfViewerURL); } catch { }
            }
            __pdfViewerURL = null;
        }

        function closeFloatModal() {
            const modal = document.getElementById('floatModal');
            if (modal) modal.classList.remove('show');
        }

        (function () {
            const modal = document.getElementById('floatModal');
            if (modal) {
                modal.addEventListener('click', function (e) {
                    if (e.target === modal) {
                        closeFloatModal();
                    }
                });
            }
        })();

        function showConfirm(text, onYes) {
            if (confirm(text)) {
                onYes();
            }
        }

        function ensureWalkIn() {
            if (!state.customers) state.customers = [];
            const exists = state.customers.some(c => c && c.name && c.name.toString().toLowerCase().includes('walk'));
            if (!exists) {
                state.customers.unshift({ name: 'WALK IN', email: '', phone: '', address: '', totalPurchases: 0 });
                saveData();
            }
        }
        ensureWalkIn();

        function renderDashboard() {
            const stats = getStats();
            const lowStockProducts = state.products.filter(p => {
                const inv = state.inventory[p.name] || { stock: 0, minAlert: 5 };
                return (p.hasStock !== false) && (inv.stock <= inv.minAlert);
            });

            const unpaidCount = state.unpaidEntries.filter(e => !e.paid).length;
            const unpaidAmount = state.unpaidEntries.filter(e => !e.paid).reduce((sum, e) => sum + (e.amount || 0), 0);

            const dailyProgress = state.dailyTarget > 0 ? (stats.todayProfit / state.dailyTarget * 100) : 0;
            const monthlyProgress = state.monthlyTarget > 0 ? (stats.monthProfit / state.monthlyTarget * 100) : 0;

            return `
    <div class="privacy-container">
        <button class="privacy-toggle-btn show" id="dashboardPrivacyToggleBtn" onclick="toggleDashboardPrivacy()" aria-pressed="${state.dashboardPrivacyBlurred ? 'true' : 'false'}" title="Toggle privacy" aria-label="Toggle privacy">
            ${state.dashboardPrivacyBlurred ? '' : ''}
        </button>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
        <div class="stat-card ${state.dashboardPrivacyBlurred ? 'privacy-blur' : ''}" onclick="switchTab('sales')" style="padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">TODAY'S PROFIT</div>
            <div class="stat-value" style="font-size: 16px;"> ${formatMoney(stats.todayProfit)} Tsh</div>
            <div class="stat-subvalue" style="font-size: 11px;">${stats.todaySalesCount} sales today</div>
            ${state.dailyTarget > 0 ? `
                <div class="progress-bar" style="height: 6px; margin-top: 6px;">
                    <div class="progress-fill" style="width: ${Math.min(dailyProgress, 100)}%"></div>
                </div>
                <div class="stat-subvalue" style="font-size: 10px; margin-top: 4px;">${dailyProgress.toFixed(0)}% of target</div>
            ` : ''}
        </div>
        
        <div class="stat-card ${state.dashboardPrivacyBlurred ? 'privacy-blur' : ''}" onclick="switchTab('sales')" style="padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">YESTERDAY'S PROFIT</div>
            <div class="stat-value" style="font-size: 16px;"> ${formatMoney(stats.yesterdayProfit)} Tsh</div>
            <div class="stat-subvalue" style="font-size: 10px;">
                ${stats.todayProfit > stats.yesterdayProfit ? ' Better!' :
                    stats.todayProfit < stats.yesterdayProfit ? ' Lower' : ' Same'}
            </div>
        </div>

        <div class="stat-card ${state.dashboardPrivacyBlurred ? 'privacy-blur' : ''}" onclick="switchTab('analytics')" style="padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">MONTH PROFIT</div>
            <div class="stat-value" style="font-size: 16px;"> ${formatMoney(stats.monthProfit)} Tsh</div>
            <div class="stat-subvalue" style="font-size: 10px;">Revenue: ${formatMoney(stats.monthRevenue)} Tsh</div>
            ${state.monthlyTarget > 0 ? `
                <div class="progress-bar" style="height: 6px; margin-top: 6px;">
                    <div class="progress-fill" style="width: ${Math.min(monthlyProgress, 100)}%"></div>
                </div>
                <div class="stat-subvalue" style="font-size: 10px; margin-top: 4px;">${monthlyProgress.toFixed(0)}% of target</div>
            ` : ''}
        </div>

        <div class="stat-card ${state.dashboardPrivacyBlurred ? 'privacy-blur' : ''}" onclick="switchTab('analytics')" style="background: ${stats.monthNetProfit >= 0 ? '#2e7d32' : '#d32f2f'}; padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">NET PROFIT (MONTH)</div>
            <div class="stat-value" style="font-size: 16px;"> ${formatMoney(stats.monthNetProfit)} Tsh</div>
            <div class="stat-subvalue" style="font-size: 10px;">Expenses: ${formatMoney(stats.monthExpenses)} Tsh</div>
        </div>

        <div class="stat-card ${state.dashboardPrivacyBlurred ? 'privacy-blur' : ''}" onclick="goToUnpaidFromDashboard()" style="padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">UNPAID ENTRIES</div>
            <div class="stat-value" style="font-size: 18px;">${unpaidCount}</div>
            <div class="stat-subvalue" style="font-size: 10px;">Total: ${formatMoney(unpaidAmount)} Tsh</div>
        </div>

        <div class="stat-card ${state.dashboardPrivacyBlurred ? 'privacy-blur' : ''}" onclick="switchTab('inventory')" style="padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">LOW STOCK ALERT</div>
            <div class="stat-value" style="font-size: 18px;">${lowStockProducts.length}</div>
            <div class="stat-subvalue" style="font-size: 10px;">${lowStockProducts.length > 0 ? ' Check inventory' : ' All good'}</div>
        </div>
    </div>
    </div>

                ${lowStockProducts.length > 0 ? `
                    <button class="collapse-btn" onclick="switchTab('inventory')" aria-label="Go to Inventory">
                        <span style="font-weight:700;"> Low Stock Alert</span>
                        <span style="font-size:12px;display:block;margin-top:4px;">${lowStockProducts.slice(0, 3).map(p => `${p.name}`).join(', ')}${lowStockProducts.length > 3 ? `, +${lowStockProducts.length - 3} more` : ''}</span>
                    </button>
                ` : ''}

                ${unpaidCount > 0 ? `
                    <button class="collapse-btn" onclick="goToUnpaidFromDashboard()" aria-label="Go to Unpaid Entries">
                        <span style="font-weight:700;"> Pending Payments</span>
                        <span style="font-size:12px;display:block;margin-top:4px;">${unpaidCount} unpaid entries  Total ${formatNumber(unpaidAmount)} Tsh</span>
                    </button>
                ` : ''}

                <div class="card">
                    <h2>Quick Actions</h2>
                    <div class="flex-gap">
                        <button class="btn-success btn-small" onclick="switchTab('sales')"> New Sale</button>
                        <button class="btn-danger btn-small" onclick="switchTab('expenses')"> Add Expense</button>
                        <button class="btn-small" onclick="switchTab('products')"> Manage Products/Services</button>
                        <button class="btn-small" onclick="switchTab('transactions')"> Transactions</button>
                        <button class="btn-small" onclick="switchTab('inventoryPurchases')"> Inventory</button>
                        <button class="btn-small" onclick="switchTab('invoices')" style="background: linear-gradient(145deg, #1976d2, #0d47a1); color: white;"> Invoices</button>
                        <button class="btn-small" onclick="switchTab('notes')" style="background: linear-gradient(145deg, #e65100, #bf360c); color: white;"> Notes</button>
                        <button class="btn-small" onclick="switchTab('analytics')" style="background: linear-gradient(145deg, #7b1fa2, #4a148c); color: white;"> Analytics</button>
                    </div>
                </div>

                <div class="card">
                    <h2>Set Daily Target</h2>
                    <div class="form-group">
                        <label>Daily Profit Target (Tsh)</label>
                        <input type="text" class="money-input" id="dailyTarget" value="${formatMoney(state.dailyTarget || 0)}">
                    </div>
                    <button onclick="setDailyTarget()">Save Target</button>
                </div>

                <div class="card">
                    <h2>Set Monthly Target</h2>
                    <div class="form-group">
                        <label>Monthly Profit Target (Tsh)</label>
                        <input type="text" class="money-input" id="monthlyTarget" value="${formatMoney(state.monthlyTarget || 0)}">
                    </div>
                    <button onclick="setMonthlyTarget()">Save Target</button>
                </div>

                <div class="card">
                    <h2>Recent Activity</h2>
                    ${state.sales.slice().reverse().slice(0, 5).map(s => `
                        <div class="item">
                            <div class="item-header">
                                <span class="item-title">${s.productName}</span>
                                <span style="color: #2e7d32; font-weight: 700;"> ${formatNumber(s.profit)} Tsh</span>
                            </div>
                            <div class="item-subtitle">
                                ${s.date} ${s.time} | ${s.customer}
                            </div>
                        </div>
                    `).join('') || '<p style="text-align: center; color: #666;">No recent activity</p>'}
                </div>
            `;
        }

        async function setDailyTarget() {
            const el = document.getElementById('dailyTarget');
            const value = parseMoney(el?.value) || 0;
            if (value < 0 || value > 999999999) return showToast('Enter amount between 0 and 999,999,999', 'error');
            state.dailyTarget = value;
            saveData();
            showToast('Daily target updated', 'success');
            if (syncEnabled) {
                await upsertOne('settings', { daily_target: value });
                const ok = await verifyCloudSettings('daily_target', value);
                if (!ok) { showToast('Cloud verify failed; will retry', 'info'); }
                syncInBackground();
            }
            render();
        }

        async function setMonthlyTarget() {
            const el = document.getElementById('monthlyTarget');
            const value = parseMoney(el?.value) || 0;
            if (value < 0 || value > 999999999) return showToast('Enter amount between 0 and 999,999,999', 'error');
            state.monthlyTarget = value;
            saveData();
            showToast('Monthly target updated', 'success');
            if (syncEnabled) {
                await upsertOne('settings', { monthly_target: value });
                const ok = await verifyCloudSettings('monthly_target', value);
                if (!ok) { showToast('Cloud verify failed; will retry', 'info'); }
                syncInBackground();
            }
            render();
        }

        async function verifyCloudSettings(field, expected) {
            try {
                const { data, error } = await supabase.from('settings').select(field).eq('user_id', currentUser.id).single();
                if (error) return false;
                const val = parseFloat(data?.[field] || 0);
                return Math.round(val) === Math.round(expected);
            } catch { return false; }
        }

        function renderAccount() {
            // Get profile data (works offline or online)
            const profile = getUserProfileData();

            // Check if profile is incomplete
            const isProfileIncomplete = !profile.businessName || !profile.phone || !profile.address;

            if (!currentUser) {
                // NOT SIGNED IN VIEW
                return `
            ${isProfileIncomplete && state.profileEditMode ? `
                <div class="alert-box" style="animation: highlightFade 2s ease-out;">
                    <strong> Complete Your Profile!</strong><br>
                    Please fill in your business information below for personalized invoices and reports.
                </div>
            ` : ''}
            
            <div class="card" id="userProfileCard">
                <h2> User Profile (Offline Mode)</h2>
                <div class="alert-info" style="margin-bottom: 16px;">
                    <strong> Offline Profile:</strong> Your profile is saved locally. Sign in to sync across devices.
                </div>
                <form onsubmit="updateUserProfile(event)">
                    <div class="form-group">
                        <label>Business Name</label>
                        <input 
                            type="text"
                            id="profileBusinessName"
                            value="${profile.businessName}"
                            placeholder="Enter business name"
                            ${state.profileEditMode ? '' : 'readonly'}
                            required>
                    </div>
                    <div class="form-group">
                        <label>Email</label>
                        <input 
                            type="email" 
                            id="profileEmail" 
                            value="${profile.email}" 
                            placeholder="youremail@domain.com" 
                            ${state.profileEditMode ? '' : 'readonly'}
                            required>
                    </div>
                    <div class="form-group">
                        <label>Phone Number</label>
                        <input 
                            type="tel" 
                            id="profilePhone" 
                            value="${profile.phone}" 
                            placeholder="+00000000000" 
                            ${state.profileEditMode ? '' : 'readonly'}
                            required>
                    </div>
                    <div class="form-group">
                        <label>Country</label>
                        <select id="profileCountrySelect" onchange="onProfileCountrySelect(this.value)" ${state.profileEditMode ? '' : 'disabled'}>
                            <option value="">-- Select Country --</option>
                            <option value="__manual__">Manual entry</option>
                            ${getCountryOptionsSelectHTML()}
                        </select>
                        <input type="text" id="profileCountry" value="${profile.country}" placeholder="Type country" ${state.profileEditMode ? '' : 'disabled readonly'} style="margin-top:6px; display:none;">
                    </div>
                    <div class="form-group">
                        <label>City</label>
                        <select id="profileCitySelect" onchange="onProfileCitySelect(this.value)" ${state.profileEditMode ? '' : 'disabled'}>
                            <option value="">-- Select City --</option>
                            <option value="__manual__">Manual entry</option>
                            ${getCityOptionsSelectHTML(profile.country)}
                        </select>
                        <input type="text" id="profileCity" value="${profile.city}" placeholder="Type city" ${state.profileEditMode ? '' : 'disabled readonly'} style="margin-top:6px; display:none;">
                    </div>
                    <div class="form-group">
                        <label>Address</label>
                        <input 
                            type="text" 
                            id="profileAddress" 
                            value="${profile.address}" 
                            placeholder="your Address" 
                            ${state.profileEditMode ? '' : 'readonly'}
                            required>
                    </div>
                    
                    <div style="display: flex; gap: 12px;">
                        <button 
                            type="submit" 
                            class="btn-success" 
                            style="flex: 1; ${state.profileEditMode ? '' : 'opacity: 0.5; cursor: not-allowed;'}"
                            ${state.profileEditMode ? '' : 'disabled'}>
                             Save Profile
                        </button>
                        
                        ${!state.profileEditMode ? `
                            <button 
                                type="button" 
                                class="btn" 
                                style="flex: 1;"
                                onclick="enableProfileEdit()">
                                 Edit
                            </button>
                        ` : ''}
                    </div>
                </form>
            </div>
            
            <div class="card">
                <h2> Cloud Sync</h2>
                <p style="margin-bottom: 16px; color: #666;">
                    Sign in to sync your data across all devices!
                </p>
                
                <div class="transaction-tabs" style="margin-bottom: 20px;">
                    <button class="transaction-tab mpesa active" id="loginTab" onclick="switchAuthTab('login')">
                        Sign In
                    </button>
                    <button class="transaction-tab crdb" id="signupTab" onclick="switchAuthTab('signup')">
                        Sign Up
                    </button>
                </div>

                <div id="loginForm">
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="loginEmail" placeholder="your@email.com" name="username" autocomplete="username" autocapitalize="none" autocorrect="off">
                    </div>
                    <div class="form-group">
                        <label>Password</label>
                        <input type="password" id="loginPassword" placeholder="" name="current-password" autocomplete="current-password">
                    </div>
                    <button onclick="handleSignIn()">Sign In</button>
                </div>

                <div id="signupForm" style="display: none;">
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="signupEmail" placeholder="your@email.com">
                    </div>
                    <div class="form-group">
                        <label>Password (min 6 characters)</label>
                        <input type="password" id="signupPassword" placeholder="">
                    </div>
                    <div class="form-group">
                        <label>Confirm Password</label>
                        <input type="password" id="signupPasswordConfirm" placeholder="">
                    </div>
                    <button onclick="handleSignUp()">Create Account</button>
                </div>

                <!--
                <div class="card" style="margin-top: 12px;">
                    <h3> Business Logo</h3>
                    <p style="color:#666;font-size:13px;margin-bottom:8px;">Upload your logo (PNG/JPEG). It appears on all PDFs before your business name.</p>
                    <div style="display:flex;align-items:center;gap:12px;">
                        <div id="logoPreview" style="width:64px;height:64px;border-radius:50%;background:#f5f5f5;border:2px solid rgba(0,0,0,0.12);display:flex;align-items:center;justify-content:center;overflow:hidden;">
                            ${(state.userLogoDataUrl || state.userLogoPublicUrl)
                        ? `<img src="${state.userLogoDataUrl || state.userLogoPublicUrl}" alt="Logo" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
                        : '<span style="font-size:12px;color:#999;">No logo</span>'}
                        </div>
                        <button class="btn-secondary" onclick="triggerLogoUpload()">Upload Logo</button>
                    </div>
                    <small style="display:block;color:#888;margin-top:6px;">Recommended size: 256256 px (auto-resized).</small>
                </div>
                -->

                <div class="alert-info">
                    <strong>Benefits of Cloud Sync:</strong>
                    <ul style="margin-top: 8px; padding-left: 20px; font-size: 13px; color: #666;">
                        <li>Access from any device</li>
                        <li>Automatic backup</li>
                        <li>Real-time updates</li>
                        <li>Never lose data</li>
                    </ul>
                </div>
            </div>
        `;
            }

            // SIGNED IN VIEW
            return `
        <div class="card">
            <h2> Account</h2>
            <div class="alert-success">
                <div style="font-size: 14px; margin-bottom: 8px;">
                     Connected to Cloud
                </div>
                <div style="font-size: 13px;">
                     ${currentUser.email}
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                <button onclick="pullFromCloud()" class="btn-success">
                     Pull from Cloud
                </button>
                <button onclick="pushToCloud()" class="btn-success">
                     Push to Cloud
                </button>
            </div>

            <button onclick="syncAllData()" class="btn" style="margin-bottom: 12px;">
                 Smart Sync
            </button>

            <button onclick="cleanDuplicatesFromUI()" class="btn-danger" style="margin-bottom: 12px;">
                 Clean Cloud Duplicates
            </button>
            
            <button onclick="signOut()" class="btn-danger" style="margin-bottom: 12px;">
                Sign Out
            </button>
            
            <!--
            <div class="card" style="margin-top: 12px;">
                <h3> Business Logo</h3>
                <p style="color:#666;font-size:13px;margin-bottom:8px;">Upload your logo (PNG/JPEG). It appears on all PDFs before your business name.</p>
                <div style="display:flex;align-items:center;gap:12px;">
                    <div id="logoPreview" style="width:64px;height:64px;border-radius:50%;background:#f5f5f5;border:2px solid rgba(0,0,0,0.12);display:flex;align-items:center;justify-content:center;overflow:hidden;">
                        ${(state.userLogoDataUrl || state.userLogoPublicUrl)
                    ? `<img src="${state.userLogoDataUrl || state.userLogoPublicUrl}" alt="Logo" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">`
                    : '<span style="font-size:12px;color:#999;">No logo</span>'}
                    </div>
                    <button class="btn-secondary" onclick="triggerLogoUpload()">Upload Logo</button>
                </div>
                <small style="display:block;color:#888;margin-top:6px;">Recommended size: 256256 px (auto-resized).</small>
            </div>
            -->
            
            <!-- Removed in-app dashboard refresh button -->

            <div class="alert-info">
                <strong>Sync Options:</strong><br>
                 <strong>Pull from Cloud:</strong> Download cloud data (overwrites local)<br>
                 <strong>Push to Cloud:</strong> Upload local data (overwrites cloud)<br>
                 <strong>Smart Sync:</strong> Auto-detect which direction to sync
            </div>
        </div>

        ${isProfileIncomplete && state.profileEditMode ? `
            <div class="alert-box" style="animation: highlightFade 2s ease-out;">
                <strong> Complete Your Profile!</strong><br>
                Please fill in your business information below for personalized invoices and reports.
            </div>
        ` : ''}

        <div class="card" id="userProfileCard">
            <h2> User Profile</h2>
            <form onsubmit="updateUserProfile(event)">
                <div class="form-group">
                    <label>Business Name</label>
                   <input 
                    type="text"
                    id="profileBusinessName"
                    value="${profile.businessName}"
                    placeholder="Enter business name"
                    ${state.profileEditMode ? '' : 'readonly'}
                    required>
                </div>
                <div class="form-group">
                    <label>Email</label>
                    <input 
                        type="email" 
                        id="profileEmail" 
                        value="${profile.email}" 
                        placeholder="youremail@domain.com" 
                        ${state.profileEditMode ? '' : 'readonly'}
                        required>
                </div>
                <div class="form-group">
                    <label>Phone Number</label>
                    <input 
                        type="tel" 
                        id="profilePhone" 
                        value="${profile.phone}" 
                        placeholder="+00000000000" 
                        ${state.profileEditMode ? '' : 'readonly'}
                        required>
                </div>
                <div class="form-group">
                    <label>Country</label>
                    <select id="profileCountrySelect" onchange="onProfileCountrySelect(this.value)" ${state.profileEditMode ? '' : 'disabled'}>
                        <option value="">-- Select Country --</option>
                        <option value="__manual__">Manual entry</option>
                        ${getCountryOptionsSelectHTML()}
                    </select>
                    <input type="text" id="profileCountry" value="${profile.country}" placeholder="Type country" ${state.profileEditMode ? '' : 'disabled readonly'} style="margin-top:6px; display:none;">
                </div>
                <div class="form-group">
                    <label>City</label>
                    <select id="profileCitySelect" onchange="onProfileCitySelect(this.value)" ${state.profileEditMode ? '' : 'disabled'}>
                        <option value="">-- Select City --</option>
                        <option value="__manual__">Manual entry</option>
                        ${getCityOptionsSelectHTML(profile.country)}
                    </select>
                    <input type="text" id="profileCity" value="${profile.city}" placeholder="Type city" ${state.profileEditMode ? '' : 'disabled readonly'} style="margin-top:6px; display:none;">
                </div>
                <div class="form-group">
                    <label>Address</label>
                    <input 
                        type="text" 
                        id="profileAddress" 
                        value="${profile.address}" 
                        placeholder="your Address" 
                        ${state.profileEditMode ? '' : 'readonly'}
                        required>
                </div>
                
                <div style="display: flex; gap: 12px;">
                    <button 
                        type="submit" 
                        class="btn-success" 
                        style="flex: 1; ${state.profileEditMode ? '' : 'opacity: 0.5; cursor: not-allowed;'}"
                        ${state.profileEditMode ? '' : 'disabled'}>
                         Save Profile
                    </button>
                    
                    ${!state.profileEditMode ? `
                        <button 
                            type="button" 
                            class="btn" 
                            style="flex: 1;"
                            onclick="enableProfileEdit()">
                             Edit
                        </button>
                    ` : ''}
                </div>
            </form>
            
        <div class="alert-info" style="margin-top: 16px;">
            <strong> Note:</strong> This information will be used in invoices, reports, and other documents throughout the app.
        </div>
        </div>

        
    `;
        }

        async function updateUserProfile(e) {
            e.preventDefault();
            playTapSound();
            hapticShort();

            const profileData = {
                businessName: document.getElementById('profileBusinessName').value.trim(),
                email: document.getElementById('profileEmail').value.trim(),
                phone: document.getElementById('profilePhone').value.trim(),
                address: document.getElementById('profileAddress').value.trim(),
                country: (document.getElementById('profileCountry')?.value || '').trim(),
                city: (document.getElementById('profileCity')?.value || '').trim()
            };

            const success = await saveUserProfile(profileData);

            if (success) {
                state.profileEditMode = false;
                saveData();
                showToast('Profile saved successfully!', 'success');
                render();
            }
        }

        function enableProfileEdit() {
            state.profileEditMode = true;
            saveData();
            render();
        }

        async function submitDeleteAccount(e) {
            e.preventDefault();
            try {
                if (!navigator.onLine) { showToast('Go online to delete your account', 'error'); return; }
                if (!currentUser) { showToast('Not signed in', 'error'); return; }
                const email = (document.getElementById('deleteEmail')?.value || '').trim();
                const password = (document.getElementById('deletePassword')?.value || '').trim();
                if (!email || !password) { showToast('Provide email and password', 'error'); return; }
                if (email.toLowerCase() !== String(currentUser.email || '').toLowerCase()) { showToast('Email does not match signed-in account', 'error'); return; }
                const formEl = e.target;
                const btn = formEl.querySelector('.submit');
                if (btn) { btn.disabled = true; btn.style.opacity = '0.6'; btn.style.cursor = 'not-allowed'; }
                showToast('Verifying credentials', 'info', null, null, 3000);
                const { data, error } = await supabase.auth.signInWithPassword({ email, password });
                if (error) { showToast('Invalid email or password', 'error'); if (btn) { btn.disabled = false; btn.style.opacity = '1'; btn.style.cursor = 'pointer'; } return; }
                await deleteUserDataAndSignOut();
            } catch (err) { showToast('Delete failed. Try again.', 'error'); } finally {
                const btn = document.querySelector('.form .submit');
                if (btn) { btn.disabled = false; btn.style.opacity = '1'; btn.style.cursor = 'pointer'; }
            }
        }

        /*
        async function handleDeleteAccount() {
            // commented out by request
        }
        */

        /*
        async function deleteUserDataAndSignOut() {
            // commented out by request
        }
        */

        /*
        async function deleteAuthUserServerSide(uid) {
            // commented out by request
        }
        */


        function switchAuthTab(tab) {
            if (tab === 'login') {
                document.getElementById('loginForm').style.display = 'block';
                document.getElementById('signupForm').style.display = 'none';
                document.getElementById('loginTab').classList.add('active');
                document.getElementById('signupTab').classList.remove('active');
                try { autoSubmitLoginIfAutofilled(); } catch (e) { }
                try {
                    if (typeof isIOSSafari === 'function' && isIOSSafari()) {
                        const emailEl = document.getElementById('loginEmail');
                        emailEl && emailEl.focus();
                    }
                } catch (e) { }
            } else {
                document.getElementById('loginForm').style.display = 'none';
                document.getElementById('signupForm').style.display = 'block';
                document.getElementById('loginTab').classList.remove('active');
                document.getElementById('signupTab').classList.add('active');
            }
        }

        // Detect autofill and auto submit sign in
        function autoSubmitLoginIfAutofilled() {
            if (!navigator.onLine) return;
            if (state.autoAuthDisabled) return;
            const emailEl = document.getElementById('loginEmail');
            const passEl = document.getElementById('loginPassword');
            const btn = document.querySelector('#loginForm button[onclick="handleSignIn()"]');
            if (!emailEl || !passEl || !btn) return;

            // On iOS Safari, rely on autofill animation/visibility triggers and avoid polling
            try {
                if (typeof isIOSSafari === 'function' && isIOSSafari()) {
                    const email = (emailEl.value || '').trim();
                    const pwd = (passEl.value || '').trim();
                    if (email && pwd) {
                        try { handleSignIn(); } catch (e) { /* no-op */ }
                    }
                    return; // Skip polling on iOS Safari
                }
            } catch (e) { /* no-op */ }

            let attempts = 0;
            const maxAttempts = 10; // ~1 second
            const timer = setInterval(() => {
                attempts++;
                const email = (emailEl.value || '').trim();
                const pwd = (passEl.value || '').trim();
                if (email && pwd) {
                    clearInterval(timer);
                    try { handleSignIn(); } catch (e) { /* no-op */ }
                } else if (attempts >= maxAttempts) {
                    clearInterval(timer);
                }
            }, 200);
        }

        // iOS Face ID autofill detection via CSS animationstart (Safari only)
        function isIOSSafari() {
            const ua = navigator.userAgent || navigator.vendor || window.opera;
            const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
            return isIOS && isSafari;
        }
        if (isIOSSafari()) {
            document.addEventListener('animationstart', function (e) {
                if (e.animationName === 'autofillDetection') {
                    try { autoSubmitLoginIfAutofilled(); } catch (err) { }
                }
            }, true);
        }

        // Also trigger detection on visibility change and when inputs receive focus
        document.addEventListener('visibilitychange', function () {
            if (document.visibilityState === 'visible' && !currentUser) {
                try { attemptSilentCredentialSignIn(); } catch (e) { }
                if (!currentUser && (typeof isIOSSafari === 'function' && isIOSSafari())) {
                    try { switchTab('account'); } catch (e) { }
                    try { autoSubmitLoginIfAutofilled(); } catch (e) { }
                } else if (state.activeTab === 'account') {
                    try { autoSubmitLoginIfAutofilled(); } catch (e) { }
                }
            }
        });
        async function attemptSilentCredentialSignIn() {
            if (!navigator.onLine) return false;
            if (state.autoAuthDisabled) return false;
            if (!window.isSecureContext) return false;
            if (!navigator.credentials) return false;
            if (!window.supabase || !supabase || !supabase.auth) return false;
            try {
                const cred = await navigator.credentials.get({ password: true, mediation: 'silent' });
                if (cred && cred.type === 'password' && cred.id && cred.password) {
                    try {
                        const { data, error } = await supabase.auth.signInWithPassword({ email: cred.id, password: cred.password });
                        if (!error && data && data.user) {
                            try { refreshAuthState(); } catch (e) { }
                            return true;
                        }
                    } catch (e) { }
                }
            } catch (e) { }
            return false;
        }
        async function pullFromCloud() {
            playTapSound();
            hapticShort();
            if (!syncEnabled || !currentUser) {
                return showToast('Not signed in', 'error');
            }

            if (!confirm('This will replace ALL local data with cloud data. Continue?')) {
                return;
            }

            updateSyncIndicator('syncing');
            showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);

            try {
                console.log(' Pulling data from cloud...');

                // Clear local storage first
                localStorage.removeItem('financeManagerData');

                // Pull everything from cloud
                await pullDataFromSupabase();

                updateSyncIndicator('synced');
                showToast('Data pulled from cloud successfully!', 'success');
                render();
            } catch (error) {
                console.error('Pull error:', error);
                showToast('Pull failed: ' + error.message, 'error');
                updateSyncIndicator('synced');
            }
        }

        async function pushToCloud() {
            playTapSound();
            hapticShort();
            if (!syncEnabled || !currentUser) {
                return showToast('Not signed in', 'error');
            }

            if (!confirm('This will replace ALL cloud data with local data. Continue?')) {
                return;
            }

            updateSyncIndicator('syncing');
            showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);

            try {
                console.log(' Pushing data to cloud...');
                await clearAndPushAllData();
                updateSyncIndicator('synced');
                showToast('Data pushed to cloud successfully!', 'success');
            } catch (error) {
                console.error('Push error:', error);
                showToast('Push failed: ' + error.message, 'error');
                updateSyncIndicator('synced');
            }
        }
        // Removed in-app forceRefresh function


        async function handleSignIn() {
            playTapSound();
            hapticShort();
            try { state.autoAuthDisabled = false; saveData(); } catch { }
            const email = document.getElementById('loginEmail')?.value;
            const password = document.getElementById('loginPassword')?.value;

            if (!email || !password) {
                return showToast('Please fill in all fields', 'error');
            }

            // Disable button during sign in
            const loginForm = document.getElementById('loginForm');
            if (loginForm) {
                const buttons = loginForm.querySelectorAll('button');
                buttons.forEach(btn => btn.disabled = true);
            }

            try {
                const result = await signIn(email, password);
                if (result) {
                    // Success - just render normally
                    render();
                } else {
                    // Failed - re-enable buttons
                    if (loginForm) {
                        const buttons = loginForm.querySelectorAll('button');
                        buttons.forEach(btn => btn.disabled = false);
                    }
                }
            } catch (error) {
                console.error('Handle sign in error:', error);
                if (loginForm) {
                    const buttons = loginForm.querySelectorAll('button');
                    buttons.forEach(btn => btn.disabled = false);
                }
            }
        }
        async function handleSignUp() {
            const email = document.getElementById('signupEmail')?.value;
            const password = document.getElementById('signupPassword')?.value;
            const confirm = document.getElementById('signupPasswordConfirm')?.value;

            if (!email || !password || !confirm) {
                return showToast('Please fill in all fields', 'error');
            }

            if (password !== confirm) {
                return showToast('Passwords do not match', 'error');
            }

            if (password.length < 6) {
                return showToast('Password must be at least 6 characters', 'error');
            }

            await signUp(email, password);
        }

        function renderSales() {
            const stats = getStats();

            // Filter sales based on search and filters
            let filteredSales = state.sales.slice();

            if (state.searchPeriod) {
                const Period = state.searchPeriod.toLowerCase();
                filteredSales = filteredSales.filter(s =>
                    s.productName.toLowerCase().includes(Period) ||
                    s.customer.toLowerCase().includes(Period) ||
                    s.payment.toLowerCase().includes(Period)
                );
            }

            if (state.filterDateFrom) {
                filteredSales = filteredSales.filter(s => new Date(s.date) >= new Date(state.filterDateFrom));
            }

            if (state.filterDateTo) {
                filteredSales = filteredSales.filter(s => new Date(s.date) <= new Date(state.filterDateTo));
            }

            if (state.filterCustomer) {
                filteredSales = filteredSales.filter(s => s.customer === state.filterCustomer);
            }

            return `
        <div class="privacy-container">
            <button class="privacy-toggle-btn show" id="privacyToggleBtn" onclick="togglePrivacy()">
                ${state.privacyBlurred ? '' : ''}
            </button>

        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">TOTAL CAPITAL</div>
                <div class="stat-value" style="font-size: 16px;"> ${formatNumber(stats.totalCapital)} Tsh</div>
            </div>
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">TOTAL PROFIT</div>
                <div class="stat-value" style="font-size: 16px;"> ${formatNumber(stats.totalProfit)} Tsh</div>
            </div>
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">TODAY'S PROFIT</div>
                <div class="stat-value" style="font-size: 16px;"> ${formatNumber(stats.todayProfit)} Tsh</div>
            </div>
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">10% TODAY</div>
                <div class="stat-value" style="font-size: 16px;"> ${formatNumber(stats.todayProfit * 0.1)} Tsh</div>
            </div>
        </div>
    </div>
</div>

        <div class="card">
            <h2>Add Sale</h2>
            <div class="card-header-buttons">
                <button class="save-offline-btn" onclick="exportData('Saved', 2000)">
                    <span>Click to save records for offline</span>
                </button>
            </div>
            <form onsubmit="addSale(event)">
                <div class="form-group">
                    <label>Product/Service</label>
                    <select id="saleProduct" onchange="updateSaleTotal()" required>
                        <option value="">-- Select Product/Service --</option>
                        ${(() => {
                    const recentNames = [];
                    const seen = new Set();
                    (state.sales || []).slice().sort((a, b) => b.timestamp - a.timestamp).forEach(s => {
                        if (!seen.has(s.productName)) { recentNames.push(s.productName); seen.add(s.productName); }
                    });
                    const prioritized = recentNames.slice(0, 3);
                    const entries = state.products.map((p, i) => ({ p, i }));
                    const prioritizedEntries = entries.filter(e => prioritized.includes(e.p.name));
                    const restEntries = entries.filter(e => !prioritized.includes(e.p.name)).sort((a, b) => String(a.p.name).localeCompare(String(b.p.name)));
                    const merged = [...prioritizedEntries, ...restEntries];
                    return merged.map(({ p, i }) => { const stockText = (p.hasStock === false) ? 'N/A' : ((state.inventory[p.name] || { stock: 0 }).stock); const typeTag = p.hasStock === false ? '[Service]' : '[Product]'; return `<option value="${i}">${p.name} - ${p.category} ${typeTag}${p.hasStock === false ? '' : ` (Stock: ${stockText})`}</option>`; }).join('');
                })()}
                    </select>
                </div>
                <div class="form-group">
                    <label>Customer</label>
                    <select id="saleCustomer" onchange="toggleCustomerInput()">
                        <option value="">-- Walk-in --</option>
                        ${state.customers
                    .map((c, i) => ({ c, i }))
                    .sort((a, b) => String(a.c.name).localeCompare(String(b.c.name)))
                    .map(({ c, i }) => `<option value="${i}">${c.name}</option>`).join('')}
                        <option value="new">+ Add New Customer</option>
                    </select>
                </div>
                <div id="newCustomerFields" style="display:none;">
                    <div class="form-group">
                        <label>New Customer Name</label>
                        <input type="text" id="newCustomerName" placeholder="Enter customer name">
                    </div>
                    <div class="form-group">
                        <label>Phone (Optional)</label>
                        <input type="tel" id="newCustomerPhone" placeholder="+255...">
                    </div>
                </div>
                <div class="form-group">
                    <label>Quantity</label>
                    <input type="text" id="saleQuantity" class="money-input" placeholder="Qty" onchange="updateSaleTotal()" required>
                </div>
                <div class="form-group">
                    <label>Payment Method</label>
                    <select id="salePayment">
                        <option>Cash</option>
                        <option>Card</option>
                        <option>Mobile Money</option>
                        <option>M-Pesa Lipa Number</option>
                        <option>Bank Transfer</option>
                    </select>
                </div>
                <div id="saleInfo"></div>
                <button type="submit">Record Sale</button>
            </form>
        </div>

        <div class="card">
            <h2>Recent Sales (${filteredSales.length})</h2>
            
            <div class="search-box">
                <input type="text" placeholder=" Search sales..." oninput="updateSearchPeriod(this.value)">
            </div>

            <div class="filter-row">
                <div class="form-group">
                    <label>From...</label>
                    <input type="date" onchange="updateFilterDateFrom(this.value)" value="${state.filterDateFrom || ''}" placeholder="mm/dd/yyyy">
                </div>
                <div class="form-group">
                    <label>To...</label>
                    <input type="date" onchange="updateFilterDateTo(this.value)" value="${state.filterDateTo || ''}" placeholder="mm/dd/yyyy">
                </div>
                <div class="form-group">
                    <label>Customer</label>
                    <select onchange="updateFilterCustomer(this.value)">
                        <option value="">All Customers</option>
                        ${[...new Set(state.sales.map(s => s.customer))]
                    .filter(c => !!c)
                    .sort((a, b) => String(a).localeCompare(String(b)))
                    .map(c =>
                        `<option value="${c}" ${state.filterCustomer === c ? 'selected' : ''}>${c}</option>`
                    ).join('')}
                    </select>
                </div>
                <button class="btn-small btn-secondary" onclick="clearFilters()">Clear</button>
            </div>

            ${(() => {
                    const arr = filteredSales.slice().reverse();
                    const count = (state.listShowCount && state.listShowCount.sales) ? state.listShowCount.sales : 3;
                    const bulk = (state.searchPeriod || state.filterDateFrom || state.filterDateTo || state.filterCustomer) ? `
                <div class="bulk-actions">
                    <input type="checkbox" id="selectAll_sales" onchange="toggleSelectAll('sales')" class="checkbox-select">
                    <label for="selectAll_sales">Select All</label>
                    <span style="color: #666; font-size: 12px; margin-left: 8px;">${getSelectedCount('sales')} selected</span>
                    <button class="btn-small btn-danger" onclick="bulkDelete('sales')" ${!hasSelected('sales') ? 'disabled' : ''}> Delete Selected</button>
                </div>` : '';
                    const items = arr.slice(0, count).map((s) => {
                        const isService = (state.products.find(p => p.name === s.productName)?.hasStock === false);
                        const typeBadge = isService ? '<span class="badge badge-warning">Service</span>' : '<span class="badge badge-success">Product</span>';
                        return `
                    <div class="item">
                        <div style="display: flex; gap: 12px; align-items: start;">
                            <input type="checkbox" class="checkbox-select" ${state.selectedItems.sales && state.selectedItems.sales[s.id] ? 'checked' : ''} onchange="toggleSelect('sales', '${s.id}')">
                            <div style="flex: 1;">
                                <div class="item-header">
                                    <span class="item-title">${s.productName} ${typeBadge}</span>
                                    <span style="color: #2e7d32; font-weight: 700;"> ${formatNumber(s.profit)} Tsh</span>
                                </div>
                                <div class="item-subtitle">
                                    ${s.date} ${s.time}<br>
                                    ${s.customer} | Qty: ${s.quantity} | ${s.payment}<br>
                                    Cost: ${formatNumber(s.totalCost)} | Price: ${formatNumber(s.totalPrice)}
                                </div>
                                <div class="flex-gap" style="margin-top:8px;">
                                    <button class="btn-small" style="background: linear-gradient(145deg, #ffeb3b, #fbc02d); color: #333;" onclick="downloadSaleReceiptPDF(${s.timestamp})"> Receipt</button>
                                    <button class="btn-small" onclick="editSaleByTimestamp(${s.timestamp})">Edit</button>
                                    <button class="btn-small btn-danger" onclick="deleteSaleByTimestamp(${s.timestamp})">Delete</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    `;
                    }).join('') || '<p style="text-align: center; color: #666;">No sales found</p>';
                    const total = arr.length;
                    const hasMore = count < total;
                    const moreBtn = `<button class="collapse-btn" onclick="${hasMore ? `showMoreList('sales')` : `collapseList('sales')`}"><span class="collapse-icon ${hasMore ? '' : 'expanded'}"></span><span>${hasMore ? 'See more' : 'Hide'}</span></button>`;
                    return bulk + items + moreBtn;
                })()}
        </div>
    `;
        }


        function updateSearchPeriod(value) {
            state.searchPeriod = value;
            render();
        }

        function renderSalesList() {
            const container = document.getElementById('salesList');
            if (!container) return;

            let filteredSales = state.sales.slice();

            if (state.searchPeriod) {
                const Period = state.searchPeriod.toLowerCase();
                filteredSales = filteredSales.filter(s =>
                    s.productName.toLowerCase().includes(Period) ||
                    s.customer.toLowerCase().includes(Period) ||
                    s.payment.toLowerCase().includes(Period)
                );
            }

            if (state.filterDateFrom) {
                filteredSales = filteredSales.filter(s => new Date(s.date) >= new Date(state.filterDateFrom));
            }

            if (state.filterDateTo) {
                filteredSales = filteredSales.filter(s => new Date(s.date) <= new Date(state.filterDateTo));
            }

            if (state.filterCustomer) {
                filteredSales = filteredSales.filter(s => s.customer === state.filterCustomer);
            }

            container.innerHTML = filteredSales.slice().reverse().slice(0, 50).map(s => {
                const isService = (state.products.find(p => p.name === s.productName)?.hasStock === false);
                const typeBadge = isService ? '<span class="badge badge-warning">Service</span>' : '<span class="badge badge-success">Product</span>';
                return `
        <div class="item">
            <div class="item-header">
                <span class="item-title">${s.productName} ${typeBadge}</span>
                <span style="color: #2e7d32; font-weight: 700;"> ${formatNumber(s.profit)} Tsh</span>
            </div>
            <div class="item-subtitle">
                ${s.date} ${s.time}<br>
                ${s.customer} | Qty: ${s.quantity} | ${s.payment}<br>
                Cost: ${formatNumber(s.totalCost)} | Price: ${formatNumber(s.totalPrice)}
            </div>
            <div class="flex-gap" style="margin-top:8px;">
                <button class="btn-small" onclick="editSaleByTimestamp(${s.timestamp})">Edit</button>
                <button class="btn-small btn-danger" onclick="deleteSaleByTimestamp(${s.timestamp})">Delete</button>
            </div>
        </div>
    `}).join('') || '<p style="text-align: center; color: #666;">No sales found</p>';
        }

        function updateFilterDateFrom(value) {
            state.filterDateFrom = value;
            render();
        }

        function updateFilterDateTo(value) {
            state.filterDateTo = value;
            render();
        }

        function updateFilterCustomer(value) {
            state.filterCustomer = value;
            render();
        }

        function clearFilters() {
            state.searchPeriod = '';
            state.filterDateFrom = '';
            state.filterDateTo = '';
            state.filterCategory = '';
            state.filterCustomer = '';
            render();
        }

        function renderCollapsibleList(items, chunkSize, sectionKey, renderItem, emptyMessage) {
            if (!items || items.length === 0) {
                return `<p style="text-align: center; color: #666;">${emptyMessage}</p>`;
            }

            let html = '';
            for (let i = 0; i < items.length; i += chunkSize) {
                const chunk = items.slice(i, i + chunkSize);
                const chunkId = `${sectionKey}_chunk_${i}`;
                const isCollapsed = state.collapsedSections[chunkId];

                html += chunk.map((item, idx) => renderItem(item, i + idx)).join('');

                if (i + chunkSize < items.length) {
                    html += `
                        <button class="collapse-btn" onclick="toggleCollapse('${chunkId}')">
                            <span class="collapse-icon ${isCollapsed ? '' : 'expanded'}"></span>
                            <span>${isCollapsed ? 'Show More' : 'Show Less'}</span>
                        </button>
                    `;

                    if (isCollapsed) {
                        break;
                    }
                }
            }
            return html;
        }

        function toggleCollapse(chunkId) {
            state.collapsedSections[chunkId] = !state.collapsedSections[chunkId];
            render();
        }

        function toggleListExpanded(key) {
            if (!state.listExpanded) state.listExpanded = {};
            state.listExpanded[key] = !state.listExpanded[key];
            render();
        }

        function showMoreList(key) {
            if (!state.listShowCount) state.listShowCount = {};
            const inc = 3;
            const current = state.listShowCount[key] || 3;
            state.listShowCount[key] = current + inc;
            saveData();
            render();
        }

        function collapseList(key) {
            if (!state.listShowCount) state.listShowCount = {};
            state.listShowCount[key] = 3;
            saveData();
            render();
        }

        function toggleSelectAll(type) {
            if (!state.selectedItems[type]) state.selectedItems[type] = {};

            const items = type === 'unpaidEntries' ? state.unpaidEntries : state[type];

            // Ensure all items have IDs
            items.forEach(item => {
                if (!item.id) {
                    item.id = generateID(type);
                }
            });

            // Check if ALL items are currently selected
            const allSelected = items.every(item => state.selectedItems[type][item.id]);

            // Toggle: if all selected, unselect all; otherwise, select all
            const newState = !allSelected;

            // Apply the new state to all items
            items.forEach(item => {
                state.selectedItems[type][item.id] = newState;
            });

            saveData();
            render(); // Re-render to update UI
        }

        function updateSelectAllCheckbox(type) {
            // Use setTimeout to ensure DOM is ready
            setTimeout(() => {
                const items = type === 'unpaidEntries' ? state.unpaidEntries : state[type];
                const checkbox = document.getElementById(`selectAll_${type}`);

                if (!checkbox || !items || items.length === 0) return;

                // Ensure all items have IDs
                items.forEach(item => {
                    if (!item.id) {
                        item.id = generateID(type);
                    }
                });

                // Check if all items are selected
                const allSelected = items.every(item => state.selectedItems[type] && state.selectedItems[type][item.id]);

                // Update the "Select All" checkbox state
                checkbox.checked = allSelected;
            }, 0);
        }

        function toggleSelect(type, id) {
            if (!state.selectedItems[type]) state.selectedItems[type] = {};
            state.selectedItems[type][id] = !state.selectedItems[type][id];
            saveData();

            // Update the "Select All" checkbox state
            updateSelectAllCheckbox(type);

            // Update count display
            render();
        }

        function hasSelected(type) {
            return state.selectedItems[type] && Object.values(state.selectedItems[type]).some(v => v);
        }

        function getSelectedCount(type) {
            if (!state.selectedItems[type]) return 0;
            return Object.values(state.selectedItems[type]).filter(v => v).length;
        }

        function bulkDelete(type) {
            const selected = Object.keys(state.selectedItems[type] || {}).filter(id => state.selectedItems[type][id]);

            if (selected.length === 0) return showToast('No items selected', 'info');

            showConfirm(`Delete ${selected.length} selected items?`, async function () {
                try { playDeleteSound(); } catch (e) { }
                const items = type === 'unpaidEntries' ? state.unpaidEntries : state[type];
                // Issue cloud deletes for each selected item
                if (syncEnabled) {
                    try {
                        selected.forEach(selId => {
                            const it = items.find(x => x.id === selId);
                            if (!it) return;
                            switch (type) {
                                case 'sales':
                                    deleteOne('sales', { timestamp: it.timestamp });
                                    break;
                                case 'expenses':
                                    deleteOne('expenses', { timestamp: it.timestamp });
                                    break;
                                case 'customers':
                                    deleteOne('customers', { name: it.name, email: it.email || '' });
                                    break;
                                case 'products':
                                    deleteOne('products', { name: it.name, category: it.category || '' });
                                    break;
                                case 'transactions':
                                    deleteOne('transactions', { timestamp: it.timestamp });
                                    break;
                                case 'unpaidEntries':
                                    deleteOne('unpaid_entries', { timestamp: it.timestamp });
                                    break;
                                case 'notes':
                                    deleteOne('notes', { timestamp: it.timestamp });
                                    break;
                                default:
                                    break;
                            }
                        });
                    } catch { }
                }
                const filtered = items.filter(item => !selected.includes(item.id));

                if (type === 'unpaidEntries') {
                    state.unpaidEntries = filtered;
                } else {
                    state[type] = filtered;
                }

                // Reset selection state
                state.selectedItems[type] = {};
                saveData();
                render();

                // Uncheck select all checkbox after deletion
                setTimeout(() => {
                    const checkbox = document.getElementById(`selectAll_${type}`);
                    if (checkbox) checkbox.checked = false;
                }, 100);

                showToast(`${selected.length} items deleted`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        function bulkMarkPaid() {
            const selected = Object.keys(state.selectedItems.unpaidEntries || {})
                .filter(id => state.selectedItems.unpaidEntries[id]);

            if (selected.length === 0) return showToast('No items selected', 'info');

            showConfirm(`Mark ${selected.length} entries as paid?`, function () {
                selected.forEach(id => {
                    const entry = state.unpaidEntries.find(e => e.id === id);
                    if (entry) {
                        entry.paid = true;
                        const now = new Date();
                        state.sales.push({
                            id: generateID('sales'),
                            date: getTodayDateString(),
                            time: now.toLocaleTimeString(),
                            timestamp: now.getTime(),
                            productName: entry.type,
                            customer: entry.name,
                            quantity: 1,
                            costPerUnit: 0,
                            pricePerUnit: entry.amount,
                            totalCost: 0,
                            totalPrice: entry.amount,
                            profit: entry.amount,
                            payment: 'Unpaid Entry - Now Paid'
                        });
                    }
                });

                state.selectedItems.unpaidEntries = {};
                saveData();
                render();

                // Uncheck select all checkbox
                setTimeout(() => {
                    const checkbox = document.getElementById('selectAll_unpaidEntries');
                    if (checkbox) checkbox.checked = false;
                }, 100);

                showToast(`${selected.length} entries marked as paid`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        function editSaleByTimestamp(ts) {
            const idx = state.sales.findIndex(s => s.timestamp === ts);
            if (idx === -1) return showToast("Sale not found", "error");
            const s = state.sales[idx];
            const qty = prompt("Quantity:", s.quantity);
            const price = prompt("Price per unit:", s.pricePerUnit);
            if (qty && price && !isNaN(qty) && !isNaN(price)) {
                const qtyNum = parseInt(qty);
                const priceNum = parseFloat(price);
                s.quantity = qtyNum;
                s.pricePerUnit = priceNum;
                s.totalPrice = +(priceNum * qtyNum).toFixed(2);
                s.totalCost = s.costPerUnit * qtyNum;
                s.profit = +(s.totalPrice - s.totalCost).toFixed(2);
                s.timestamp = Date.now();
                saveData();
                render();
                showToast("Sale updated", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            }
        }

        function deleteSaleByTimestamp(ts) {
            showConfirm("Delete this sale?", async function () {
                try { playDeleteSound(); } catch (e) { }
                const idx = state.sales.findIndex(s => s.timestamp === ts);
                if (idx === -1) return showToast("Sale not found", "error");
                const sale = state.sales[idx];

                // Return stock to inventory only if product tracks stock
                const productForSale = state.products.find(p => p.name === sale.productName);
                if (productForSale && productForSale.hasStock !== false && state.inventory[sale.productName]) {
                    state.inventory[sale.productName].stock += sale.quantity;
                }

                if (sale) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('sales', { timestamp: sale.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('sales', { timestamp: sale.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.sales.splice(idx, 1);
                saveData();
                render();
                showToast("Sale deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }

        function toggleCustomerInput() {
            const select = document.getElementById('saleCustomer');
            const fields = document.getElementById('newCustomerFields');
            if (select && fields) {
                if (select.value === 'new') {
                    fields.style.display = 'block';
                } else {
                    fields.style.display = 'none';
                }
            }
        }

        function updateSaleTotal() {
            const productIndex = document.getElementById('saleProduct')?.value;
            let quantity = parseMoney(document.getElementById('saleQuantity')?.value) || 1;
            if (quantity < 1) { showToast('Quantity must be at least 1', 'error'); return; }
            const infoDiv = document.getElementById('saleInfo');
            if (!infoDiv) return;
            if (!productIndex && productIndex !== '0') { infoDiv.innerHTML = ''; return; }
            const product = state.products[productIndex];
            if (!product) { infoDiv.innerHTML = ''; return; }

            const isService = product.hasStock === false;
            let availableStock = null;
            if (!isService) {
                const inventoryItem = state.inventory[product.name] || { stock: 0, minAlert: 5 };
                availableStock = inventoryItem.stock;
                if (quantity > availableStock) {
                    infoDiv.innerHTML = `
                        <div class="alert-box-danger">
                            <strong> Insufficient Stock!</strong><br>
                            Available: ${availableStock} units<br>
                            Requested: ${quantity} units
                        </div>
                    `;
                    return;
                }
            }

            const totalCost = product.cost * quantity;
            const totalPrice = product.price * quantity;
            infoDiv.innerHTML = `
                <div class="info-box">
                    <div class="info-row"><span>Cost/unit:</span><span> ${formatNumber(product.cost)} Tsh</span></div>
                    <div class="info-row"><span>Price/unit:</span>
                        <input type="text" id="manualPrice" class="money-input" value="${formatMoney(product.price)}" style="width:120px;text-align:right;padding:6px;border-radius:6px;border:1px solid #ddd;">
                    </div>
                    ${isService ? `<div class=\"info-row\"><span>Item Type:</span><span>Service (no stock)</span></div>` : `<div class=\"info-row\"><span>Available Stock:</span><span>${availableStock} units</span></div>`}
                    <div class="info-row" style="font-weight:700;"><span>Total Cost:</span><span id="totalCost"> ${formatNumber(totalCost)} Tsh</span></div>
                    <div class="info-row" style="font-weight:700;"><span>Total Price:</span><span id="totalPrice"> ${formatNumber(product.price * quantity)} Tsh</span></div>
                    <div class="info-row" style="font-weight:700; color: #2e7d32;"><span>Profit:</span><span id="totalProfit"> ${formatNumber((product.price - product.cost) * quantity)} Tsh</span></div>
                </div>
            `;
            const manual = document.getElementById('manualPrice');
            manual && manual.addEventListener('input', function () {
                const p = parseMoney(this.value) || 0;
                document.getElementById('totalPrice').textContent = ` ${formatNumber(p * quantity)} Tsh`;
                document.getElementById('totalProfit').textContent = ` ${formatNumber((p - product.cost) * quantity)} Tsh`;
            });
        }

        async function addSale(e) {
            e && e.preventDefault && e.preventDefault();
            playTapSound();
            hapticShort();
            const productIndex = document.getElementById('saleProduct')?.value;
            if (productIndex === null || productIndex === '' || productIndex === undefined) return showToast('Please select a product', 'error');
            const product = state.products[productIndex];
            if (!product) return showToast('Product not found', 'error');
            const isService = product.hasStock === false;

            const customerSelect = document.getElementById('saleCustomer')?.value;
            let customer;

            if (customerSelect === 'new') {
                const newName = document.getElementById('newCustomerName')?.value.trim();
                if (!newName) return showToast('Please enter customer name', 'error');
                const newPhone = document.getElementById('newCustomerPhone')?.value.trim();
                customer = { name: newName, email: '', phone: newPhone, address: '', totalPurchases: 0 };
                state.customers.push(customer);
            } else if (customerSelect) {
                customer = state.customers[customerSelect];
            } else {
                customer = { name: 'WALK IN' };
            }

            const quantity = parseMoney(document.getElementById('saleQuantity')?.value) || 1;
            const payment = document.getElementById('salePayment')?.value || 'Cash';
            const manualPriceInput = document.getElementById('manualPrice');
            const pricePerUnit = manualPriceInput ? (parseMoney(manualPriceInput.value) || product.price) : product.price;
            if (pricePerUnit < 0) return showToast('Price cannot be negative', 'error');

            // Check stock only for stock-tracked products
            if (!isService) {
                const inventoryItem = state.inventory[product.name] || { stock: 0, minAlert: 5 };
                if (quantity > inventoryItem.stock) {
                    return showToast(`Insufficient stock! Available: ${inventoryItem.stock}`, 'error');
                }
            }

            const now = new Date();
            const totalCost = product.cost * quantity;
            const totalPrice = +(pricePerUnit * quantity).toFixed(2);
            const sale = {
                id: generateID('sales'),
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime(),
                productName: product.name,
                customer: customer ? customer.name : 'WALK IN',
                quantity,
                costPerUnit: product.cost,
                pricePerUnit,
                totalCost,
                totalPrice,
                profit: +(totalPrice - totalCost).toFixed(2),
                payment
            };
            state.sales = state.sales || [];
            state.sales.push(sale);

            // Update customer total purchases
            if (customer && customer.name !== 'WALK IN') {
                const custIndex = state.customers.findIndex(c => c.name === customer.name);
                if (custIndex !== -1) {
                    state.customers[custIndex].totalPurchases = (state.customers[custIndex].totalPurchases || 0) + totalPrice;
                }
            }

            // Update inventory only if product tracks stock
            if (!isService && state.inventory && state.inventory[product.name]) {
                state.inventory[product.name].stock = Math.max(0, (state.inventory[product.name].stock || 0) - quantity);
            }

            saveData();
            render();
            showToast("Sale recorded successfully!", "success");

            // Friendly reminder to save a local backup (max 3 per day)
            maybeShowBackupReminder();

            try { window.scrollTo({ top: 0, behavior: 'smooth' }); } catch (e) { try { document.documentElement.scrollTop = 0; document.body.scrollTop = 0; } catch (e2) { } }

            try {
                document.querySelectorAll('.save-offline-btn').forEach(btn => {
                    btn.classList.add('attention');
                    setTimeout(() => { try { btn.classList.remove('attention'); } catch (e) { } }, 2000);
                });
            } catch (e) { }

            if (syncEnabled) {
                await upsertOne('sales', {
                    date: sale.date,
                    time: sale.time,
                    timestamp: sale.timestamp,
                    product_name: sale.productName,
                    customer: sale.customer,
                    quantity: sale.quantity,
                    cost_per_unit: sale.costPerUnit,
                    price_per_unit: sale.pricePerUnit,
                    total_cost: sale.totalCost,
                    total_price: sale.totalPrice,
                    profit: sale.profit,
                    payment: sale.payment
                });
                if (customer && customer.name !== 'WALK IN') {
                    const cust = state.customers.find(c => c.name === customer.name) || customer;
                    await upsertOne('customers', {
                        name: cust.name,
                        email: cust.email || '',
                        phone: cust.phone || '',
                        address: cust.address || '',
                        total_purchases: cust.totalPurchases || 0
                    });
                }
                if (product && product.hasStock !== false) {
                    const inv = state.inventory[product.name] || { stock: 0, minAlert: 5 };
                    await upsertOne('inventory', { product_name: product.name, stock: inv.stock || 0, min_alert: inv.minAlert || 5 });
                }
                syncInBackground();
            }
        }

        function renderTransactions() {
            const channels = [
                { id: 'mpesa', label: 'M-Pesa' },
                { id: 'crdb', label: 'CRDB' },
                { id: 'nmb', label: 'NMB' },
                { id: 'airtel', label: 'Airtel Money' },
                { id: 'halopesa', label: 'Halopesa' },
                { id: 'yas', label: 'Yas Tanzania' }
            ];
            const currentChannel = state.activeTransactionChannel || 'mpesa';
            const channelTransactions = (state.transactions || []).filter(t => t.channel === currentChannel);

            const floatData = state.transactionFloats[currentChannel];
            const floatDifference = floatData.current - floatData.initial;

            return `
                <div class="transaction-tabs">
                    ${channels.map(ch => `
                        <button class="transaction-tab ${ch.id} ${currentChannel === ch.id ? 'active' : ''}" 
                             onclick="switchTransactionChannel('${ch.id}')">
                            ${ch.label}
                        </button>
                    `).join('')}
                </div>

                <div class="float-balance-container">
                    <h3 style="margin-bottom: 12px; color: #0d47a1; font-size: 16px;"> Float Balance</h3>
                    <div class="float-balance-row">
                        <span class="float-balance-label">Initial Float:</span>
                        <span class="editable-float" onclick="editInitialFloat('${currentChannel}')">
                             ${formatNumber(floatData.initial)} Tsh
                        </span>
                    </div>
                    <div class="float-balance-row">
                        <span class="float-balance-label">Current Float Balance:</span>
                        <span class="float-balance-value ${floatDifference >= 0 ? 'positive' : 'negative'}">
                             ${formatNumber(floatData.current)} Tsh
                        </span>
                    </div>
                    <div class="float-balance-row">
                        <span class="float-balance-label"> Cash Balance:</span>
                        <span class="float-balance-value ${floatDifference >= 0 ? 'positive' : 'negative'}">
                            ${floatDifference >= 0 ? '+' : ''}${formatNumber(floatDifference)} Tsh
                        </span>
                    </div>
                </div>

                </div>

        <div class="card">
            <h2>${channels.find(c => c.id === currentChannel).label} Transactions (${channelTransactions.length})</h2>
            
            <div class="search-box">
                <input type="text" placeholder=" Search transactions..." 
                       oninput="searchTransactions(this.value)" 
                       id="transactionSearch">
            </div>
                <div class="card">
                    <h2>Add ${channels.find(c => c.id === currentChannel).label} Transaction</h2>
                    <form onsubmit="addTransaction(event)">
                        <div class="form-group">
                            <label>Customer Name (Optional)</label>
                            <input type="text" id="transactionCustomer" placeholder="Enter customer name">
                        </div>
                        <div class="form-group">
                            <label>Transaction Type</label>
                            <select id="transactionType" required>
                                <option value="deposit">Deposit (+)</option>
                                <option value="withdrawal">Withdrawal (-)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Amount</label>
                            <input type="text" id="transactionAmount" class="money-input" placeholder="0" required>
                        </div>
                        <button type="submit">Save Transaction</button>
                    </form>
                </div>

                <div class="card">
                    <h2>${channels.find(c => c.id === currentChannel).label} Transactions (${channelTransactions.length})</h2>
                    
                    ${(() => {
                    const bulk = (state.transactionSearch && String(state.transactionSearch).trim()) ? `
                        <div class="bulk-actions">
                            <input type="checkbox" id="selectAll_transactions" onchange="toggleSelectAll('transactions')" class="checkbox-select">
                            <label for="selectAll_transactions">Select All</label>
                            <span style="color: #666; font-size: 12px; margin-left: 8px;">${getSelectedCount('transactions')} selected</span>
                            <button class="btn-small btn-danger" onclick="bulkDelete('transactions')" ${!hasSelected('transactions') ? 'disabled' : ''}> Delete Selected</button>
                        </div>` : '';
                    const list = `<div id="transactionsList">${renderTransactionsList(channelTransactions)}</div>`;
                    const total = (() => { const q = (state.transactionSearch || '').toLowerCase(); return channelTransactions.filter(t => !q || (t.customerName && t.customerName.toLowerCase().includes(q)) || t.type.toLowerCase().includes(q) || t.channel.toLowerCase().includes(q)).length; })();
                    const count = (state.listShowCount && state.listShowCount.transactions) ? state.listShowCount.transactions : 3;
                    const hasMore = count < total;
                    const moreBtn = `<button class=\"collapse-btn\" onclick=\"${hasMore ? `showMoreList('transactions')` : `collapseList('transactions')`}\"><span class=\"collapse-icon ${hasMore ? '' : 'expanded'}\"></span><span>${hasMore ? 'See more' : 'Hide'}</span></button>`;
                    return bulk + list + moreBtn;
                })()}
                </div>
            `;
        }

        function renderTransactionsList(transactions, searchPeriod = '') {
            const q = (searchPeriod || state.transactionSearch || '').toLowerCase();
            let filtered = transactions.filter(t => !q || (t.customerName && t.customerName.toLowerCase().includes(q)) || t.type.toLowerCase().includes(q) || t.channel.toLowerCase().includes(q));

            if (filtered.length === 0) {
                return '<p style="text-align: center; color: #666;">No transactions found</p>';
            }

            const count = (state.listShowCount && state.listShowCount.transactions) ? state.listShowCount.transactions : 3;
            return filtered.slice().reverse().slice(0, count).map((t, idx) => `
        <div class="item">
            <div style="display: flex; gap: 12px; align-items: start;">
                <input type="checkbox" class="checkbox-select" 
                       ${state.selectedItems.transactions && state.selectedItems.transactions[t.id] ? 'checked' : ''}
                       onchange="toggleSelect('transactions', '${t.id}')">
                <div style="flex: 1;">
                    <div class="item-header">
                        <span class="item-title">${t.customerName || 'N/A'}</span>
                        <span class="badge badge-${t.channel}">${t.type.toUpperCase()}</span>
                    </div>
                    <div class="item-subtitle">
                        ${t.date} ${t.time}<br>
                        Amount: <strong style="color: ${t.type === 'deposit' ? '#2e7d32' : '#d32f2f'};">
                            ${t.type === 'deposit' ? '+' : '-'} ${formatNumber(t.amount)} Tsh
                        </strong>
                    </div>
                    <div class="flex-gap" style="margin-top:8px;">
                        <button class="btn-small" onclick="editTransactionByTimestamp(${t.timestamp})">Edit</button>
                        <button class="btn-small btn-danger" onclick="deleteTransactionByTimestamp(${t.timestamp})">Delete</button>
                    </div>
                </div>
            </div>
        </div>
    `).join('');
        }

        function searchTransactions(Period) {
            state.transactionSearch = Period;
            render();
        }

        async function editInitialFloat(channel) {
            const current = state.transactionFloats[channel].initial;
            const newValue = prompt(`Set initial float for ${channel.toUpperCase()}:`, current);
            if (newValue !== null) {
                const val = parseFloat(newValue);
                if (!isNaN(val) && val >= 0) {
                    state.transactionFloats[channel].initial = val;
                    calculateFloatBalances();
                    saveData();
                    render();
                    showToast('Float updated', 'success');

                    // Sync to cloud immediately and then background merge
                    if (syncEnabled) {
                        await upsertOne('transaction_floats', { channel, initial_float: val });
                        syncInBackground();
                    }
                } else {
                    showToast('Invalid amount', 'error');
                }
            }
        }
        function switchTransactionChannel(channel) {
            state.activeTransactionChannel = channel;
            render();
        }

        async function addTransaction(e) {
            e.preventDefault();
            playTapSound();
            hapticShort();
            const now = new Date();
            const amount = parseMoney(document.getElementById('transactionAmount').value);

            if (isNaN(amount) || amount <= 0) {
                return showToast('Please enter a valid amount', 'error');
            }

            const transaction = {
                id: generateID('transactions'),
                channel: state.activeTransactionChannel,
                customerName: document.getElementById('transactionCustomer').value.trim() || 'N/A',
                type: document.getElementById('transactionType').value,
                amount: amount,
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime()
            };

            state.transactions = state.transactions || [];
            state.transactions.push(transaction);

            calculateFloatBalances();
            saveData();
            render();
            showToast("Transaction recorded", "success");

            if (syncEnabled) {
                await upsertOne('transactions', {
                    channel: transaction.channel,
                    customer_name: transaction.customerName,
                    type: transaction.type,
                    amount: transaction.amount,
                    date: transaction.date,
                    time: transaction.time,
                    timestamp: transaction.timestamp
                });
                syncInBackground();
            }
        }

        async function editTransactionByTimestamp(ts) {
            const idx = state.transactions.findIndex(t => t.timestamp === ts);
            if (idx === -1) return showToast("Transaction not found", "error");
            const t = state.transactions[idx];
            const customer = prompt("Customer Name:", t.customerName);
            const type = confirm("Is this a DEPOSIT? (Cancel for Withdrawal)") ? 'deposit' : 'withdrawal';
            const amount = prompt("Amount:", t.amount);
            if (customer !== null && amount) {
                const amountNum = parseFloat(amount);
                if (!isNaN(amountNum) && amountNum > 0) {
                    t.customerName = customer.trim() || 'N/A';
                    t.type = type;
                    t.amount = amountNum;
                    t.timestamp = Date.now();
                    calculateFloatBalances();
                    saveData();
                    render();
                    showToast("Transaction updated", "success");

                    if (syncEnabled) {
                        await upsertOne('transactions', {
                            channel: t.channel,
                            customer_name: t.customerName,
                            type: t.type,
                            amount: t.amount,
                            date: t.date,
                            time: t.time,
                            timestamp: t.timestamp
                        });
                        syncInBackground();
                    }
                } else {
                    showToast("Invalid amount", "error");
                }
            }
        }

        function deleteTransactionByTimestamp(ts) {
            showConfirm("Delete this transaction?", async function () {
                try { playDeleteSound(); } catch (e) { }
                const idx = state.transactions.findIndex(t => t.timestamp === ts);
                if (idx === -1) return showToast("Transaction not found", "error");
                const t = state.transactions[idx];
                if (t) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('transactions', { timestamp: t.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('transactions', { timestamp: t.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.transactions.splice(idx, 1);
                calculateFloatBalances();
                saveData();
                render();
                showToast("Transaction deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }

        function renderProducts() {
            const q = state.productSearch || '';
            return `
                ${renderBulkProductsSection()}
                <div class="card">
                    <h2>Add Product/Service</h2>
                    <div class="card-header-buttons">
                        <button class="quick-nav-btn back" onclick="switchTab('sales')"> Sales</button>
                    </div>
                    <form onsubmit="addProduct(event)">
                        <div class="form-group">
                            <label>Item Type</label>
                            <select id="productHasStock" onchange="toggleInitialStock()">
                                <option value="yes" selected>Product (has stock)</option>
                                <option value="no">Service (no stock)</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Category</label>
                            <select id="productCategory" required onchange="toggleNewProductCategory()">
                                <option value="">-- Select Category --</option>
                                <option class="opt-new" value="new">+ Add New Category</option>
                                ${state.categories.slice().sort((a, b) => String(a).localeCompare(String(b))).map(c => `<option value="${c}">${c}</option>`).join('')}
                            </select>
                        </div>
                        <div class="form-group" id="newCategoryFields" style="display:none;">
                            <label>New Category Name</label>
                            <input type="text" id="newCategoryName" placeholder="Enter new category name">
                        </div>
                        <div class="form-group">
                            <label>Item Name</label>
                            <input type="text" id="productName" placeholder="Enter item name" required>
                        </div>
                        <div class="form-group">
                            <label>Cost (Capital)</label>
                            <input type="text" id="productCost" class="money-input" placeholder="0" required>
                        </div>
                        <div class="form-group">
                            <label>Price (Selling)</label>
                            <input type="text" id="productPrice" class="money-input" placeholder="0" required>
                        </div>
                        <div class="form-group" id="initialStockGroup">
                            <label>Initial Stock</label>
                            <input type="text" id="productStock" class="money-input" placeholder="0" value="0">
                        </div>
                        <button type="submit">Add Product</button>
                    </form>
                </div>

                <div class="card">
                    <h2>All Items (${state.products.length})</h2>
    <div class="search-box">
        <input type="text" placeholder=" Search items..." oninput="searchProducts(this.value)" id="productSearch" value="${q}">
    </div>
    
    ${state.products.length > 0 ? `
        <div class="bulk-actions">
            <input type="checkbox" id="selectAll_products" onchange="toggleSelectAll('products')" class="checkbox-select">
            <label for="selectAll_products">Select All</label>
            <span style="color: #666; font-size: 12px; margin-left: 8px;">
                ${getSelectedCount('products')} selected
            </span>
            <button class="btn-small btn-danger" onclick="bulkDelete('products')" ${!hasSelected('products') ? 'disabled' : ''}>
                 Delete Selected
            </button>
        </div>
    ` : ''}
    
                <div id="productsList">${renderProductsList(q)}</div>
                ${(() => { const total = (state.products || []).filter(p => !q || p.name.toLowerCase().includes(q.toLowerCase()) || String(p.category || '').toLowerCase().includes(q.toLowerCase())).length; const count = (state.listShowCount && state.listShowCount.products) ? state.listShowCount.products : 3; const hasMore = count < total; return `<button class="collapse-btn" onclick="${hasMore ? `showMoreList('products')` : `collapseList('products')`}"><span class="collapse-icon ${hasMore ? '' : 'expanded'}"></span><span>${hasMore ? 'See more' : 'Hide'}</span></button>`; })()}
</div>
            `;
        }

        function renderBulkProductsSection() {
            state.bulkProductRows = state.bulkProductRows || [];
            const rows = state.bulkProductRows.map(r => `
                <div class="bulk-row" style="display:flex; gap:8px; align-items:flex-end;">
                    <div class="form-group" style="flex:1;">
                        <label>Item Type</label>
                        <select onchange="updateBulkProductField('${r.id}','type',this.value)">
                            <option value="product" ${r.type === 'service' ? '' : 'selected'}>Product (has stock)</option>
                            <option value="service" ${r.type === 'service' ? 'selected' : ''}>Service (no stock)</option>
                        </select>
                    </div>
                    <div class="form-group" style="flex:2;">
                        <label>Item Name</label>
                        <input type="text" placeholder="Name" value="${r.name || ''}" oninput="updateBulkProductField('${r.id}','name',this.value)">
                    </div>
                    <div class="form-group" style="flex:1;">
                        <label>Cost (Capital)</label>
                        <input type="text" class="money-input" placeholder="0" value="${r.cost || ''}" oninput="updateBulkProductField('${r.id}','cost',this.value)">
                    </div>
                    <div class="form-group" style="flex:1;">
                        <label>Price (Selling)</label>
                        <input type="text" class="money-input" placeholder="0" value="${r.price || ''}" oninput="updateBulkProductField('${r.id}','price',this.value)">
                    </div>
                    ${r.type === 'service' ? '' : `
                    <div class="form-group" style="flex:1;">
                        <label>Stock</label>
                        <input type="text" class="money-input" placeholder="0" value="${r.stock || ''}" oninput="updateBulkProductField('${r.id}','stock',this.value)">
                    </div>`}
                    <div class="form-group" style="flex:1.5;">
                        <label>Category</label>
                        <select onchange="updateBulkProductCategorySelect('${r.id}', this.value)">
                            <option value="">-- Select Category --</option>
                            <option class="opt-new" value="new" ${r.categorySelect === 'new' ? 'selected' : ''}>+ Add New Category</option>
                            ${state.categories.slice().sort((a, b) => String(a).localeCompare(String(b))).map(c => `<option value="${c}" ${r.categorySelect === c || r.category === c ? 'selected' : ''}>${c}</option>`).join('')}
                        </select>
                    </div>
                    <div class="form-group" style="flex:1.5; ${r.categorySelect === 'new' ? '' : 'display:none;'}">
                        <label>New Category</label>
                        <input type="text" placeholder="Enter new category" value="${r.newCategoryName || ''}" oninput="updateBulkProductField('${r.id}','newCategoryName',this.value)">
                    </div>
                    <button class="btn-small btn-danger" type="button" onclick="removeBulkProductRow('${r.id}')">Remove</button>
                    <button class="btn-small" type="button" onclick="submitSingleBulkRow('${r.id}')">Submit Row</button>
                </div>
            `).join('');
            return `
                <div class="card">
                    <h2>Bulk Add Products</h2>
                    <form onsubmit="submitBulkProducts(event)">
                        <div style="display:flex; flex-direction:column; gap:8px;">${rows}</div>
                        <div class="flex-gap" style="margin-top:8px;">
                            <input type="number" id="bulkAddCount" min="1" placeholder="e.g., 3" style="width:64px;" />
                            <button type="button" id="bulkAddButton" class="btn-small" onclick="addBulkProductRow()">+ Add Row</button>
                            <button type="submit" class="btn-small">Submit All</button>
                            <button type="button" class="btn-small btn-danger" onclick="clearBulkProductRows()">Remove All Rows</button>
                        </div>
                    </form>
                </div>
            `;
        }

        function addBulkProductRow() {
            state.bulkProductRows = state.bulkProductRows || [];
            const raw = document.getElementById('bulkAddCount')?.value;
            let c = parseInt((raw || '').trim(), 10);
            if (isNaN(c) || c < 1) c = 1; else c = Math.min(c, 50);
            for (let k = 0; k < c; k++) {
                const id = Date.now() + Math.random().toString().slice(2, 8) + (k ? '_' + k : '');
                state.bulkProductRows.push({ id, type: 'product', name: '', cost: 0, price: 0, stock: 0, category: '', categorySelect: '', newCategoryName: '' });
            }
            saveData();
            render();
        }

        function removeBulkProductRow(id) {
            state.bulkProductRows = (state.bulkProductRows || []).filter(r => r.id !== id);
            saveData();
            render();
        }

        function clearBulkProductRows() {
            state.bulkProductRows = [];
            saveData();
            render();
        }

        function updateBulkProductField(id, field, value) {
            const rows = state.bulkProductRows || [];
            const r = rows.find(x => x.id === id);
            if (!r) return;
            if (field === 'cost' || field === 'price' || field === 'stock') {
                r[field] = parseMoney(value);
            } else {
                r[field] = value;
            }
            saveData();
            if (field === 'type') render();
        }
        function updateBulkProductCategorySelect(id, val) {
            const rows = state.bulkProductRows || [];
            const r = rows.find(x => x.id === id);
            if (!r) return;
            r.categorySelect = val;
            if (val !== 'new') {
                r.category = val;
                r.newCategoryName = '';
            } else {
                r.category = '';
            }
            saveData();
            render();
        }

        async function submitSingleBulkRow(id) {
            const rows = state.bulkProductRows || [];
            const r = rows.find(x => x.id === id);
            state.bulkProductStatus = state.bulkProductStatus || [];
            if (!r) { showToast('Row not found', 'error', null, null, 2000); return; }
            let name = String(r.name || '').trim();
            name = capitalizeFirstWordValue(name);
            let category = String(r.categorySelect === 'new' ? (r.newCategoryName || '') : (r.category || '')).trim();
            category = capitalizeFirstWordValue(category);
            const cost = parseFloat(r.cost) || 0;
            const price = parseFloat(r.price) || 0;
            const isService = String(r.type || '').toLowerCase() === 'service';
            const stock = isService ? 0 : (parseInt(r.stock) || 0);
            if (!name || !category || isNaN(cost) || isNaN(price) || isNaN(stock)) {
                showToast('Please fill all fields correctly', 'error', null, null, 2000);
                render();
                return;
            }
            if (cost < 0 || price < 0 || stock < 0) {
                showToast('Invalid negative values', 'error', null, null, 2000);
                render();
                return;
            }
            if ((parseFloat(price) || 0) < (parseFloat(cost) || 0)) {
                const ok = confirm('Selling price is less than cost. Continue?');
                if (!ok) return;
            }
            const existingNames = new Set((state.products || []).map(p => String(p.name || '').toLowerCase()));
            const nl = name.toLowerCase();
            if (existingNames.has(nl)) {
                showToast('Duplicate product', 'error', null, null, 2000);
                render();
                return;
            }
            if (!state.categories.includes(category)) state.categories.push(category);
            const product = { id: generateID('products'), name, category, cost, price, hasStock: !isService };
            state.products.push(product);
            state.inventory = state.inventory || {};
            if (!isService) state.inventory[name] = { stock: stock, minAlert: 5 };
            saveData();
            r.status = `${name}: Added`;
            r.statusType = 'success';
            state.bulkProductStatus.push({ type: 'success', message: r.status });
            try {
                if (syncEnabled) {
                    await upsertOne('products', { name, category: category || '', cost: cost || 0, price: price || 0, has_stock: !isService });
                    if (!isService) await upsertOne('inventory', { product_name: name, stock: stock || 0, min_alert: 5 });
                    await upsertOne('categories', { name: category });
                    syncInBackground();
                }
            } catch { }
            showToast(' Product added!', 'success');
            // Clear all rows after single submission
            state.bulkProductRows = [];
            saveData();
            render();
        }

        async function submitBulkProducts(e) {
            e.preventDefault();
            const rows = state.bulkProductRows || [];
            state.bulkProductStatus = [];
            if (!rows.length) { showToast('No rows to submit', 'info'); return; }
            const anyLoss = rows.some(r => (parseFloat(r.price) || 0) < (parseFloat(r.cost) || 0));
            if (anyLoss) { const ok = confirm('Some rows have selling price less than cost. Continue?'); if (!ok) return; }
            const existingNames = new Set((state.products || []).map(p => String(p.name || '').toLowerCase()));
            const batchNames = new Set();
            const newCats = [];
            for (let i = 0; i < rows.length; i++) {
                const r = rows[i];
                let name = String(r.name || '').trim();
                name = capitalizeFirstWordValue(name);
                let category = String(r.categorySelect === 'new' ? (r.newCategoryName || '') : (r.category || '')).trim();
                category = capitalizeFirstWordValue(category);
                const cost = parseFloat(r.cost) || 0;
                const price = parseFloat(r.price) || 0;
                const isService = String(r.type || '').toLowerCase() === 'service';
                const stock = isService ? 0 : (parseInt(r.stock) || 0);
                if (!name || !category || isNaN(cost) || isNaN(price) || isNaN(stock)) {
                    showToast('Please fill all fields correctly', 'error', null, null, 2000);
                    continue;
                }
                if (cost < 0 || price < 0 || stock < 0) {
                    showToast('Invalid negative values', 'error', null, null, 2000);
                    continue;
                }
                const nl = name.toLowerCase();
                if (existingNames.has(nl) || batchNames.has(nl)) {
                    showToast('Duplicate product', 'error', null, null, 2000);
                    continue;
                }
                batchNames.add(nl);
                if (!state.categories.includes(category)) {
                    state.categories.push(category);
                    newCats.push(category);
                }
                const product = { id: generateID('products'), name, category, cost, price, hasStock: !isService };
                state.products.push(product);
                state.inventory = state.inventory || {};
                if (!isService) state.inventory[name] = { stock: stock, minAlert: 5 };
                rows[i].status = `${name}: Added`;
                rows[i].statusType = 'success';
                state.bulkProductStatus.push({ type: 'success', message: rows[i].status });
            }
            saveData();
            render();
            if (syncEnabled) {
                try {
                    for (const s of state.bulkProductStatus) {
                        if (s.type !== 'success') continue;
                        const nm = s.message.split(':')[0];
                        const p = (state.products || []).find(x => x.name === nm);
                        if (p) {
                            await upsertOne('products', { name: p.name, category: p.category || '', cost: p.cost || 0, price: p.price || 0, has_stock: p.hasStock !== false });
                            if (p.hasStock !== false) {
                                const inv = state.inventory[p.name] || { stock: 0, minAlert: 5 };
                                await upsertOne('inventory', { product_name: p.name, stock: inv.stock || 0, min_alert: inv.minAlert || 5 });
                            }
                        }
                    }
                    for (const c of newCats) { await upsertOne('categories', { name: c }); }
                    syncInBackground();
                } catch { }
            }
            // Clear all rows after bulk submission
            state.bulkProductRows = [];
            saveData();
            render();
            const successCount = (state.bulkProductStatus || []).filter(s => s.type === 'success').length;
            if (successCount > 0) {
                showToast(' Products added!', 'success');
            }
        }

        // Toggle visibility of initial stock based on has-stock selection
        function toggleInitialStock() {
            const select = document.getElementById('productHasStock');
            const group = document.getElementById('initialStockGroup');
            if (!select || !group) return;
            if (select.value === 'no') {
                group.style.display = 'none';
            } else {
                group.style.display = 'block';
            }
        }

        function renderProductsList(searchPeriod = '') {
            let products = state.products;
            if (searchPeriod) {
                const Period = searchPeriod.toLowerCase();
                products = products.filter(p =>
                    p.name.toLowerCase().includes(Period) ||
                    p.category.toLowerCase().includes(Period)
                );
            }

            if (products.length === 0) {
                return '<p style="text-align: center; color: #666;">No items found</p>';
            }
            const count = (state.listShowCount && state.listShowCount.products) ? state.listShowCount.products : 3;
            return products.slice(0, count).map((p, i) => {
                const actualIndex = state.products.indexOf(p);
                const inv = state.inventory[p.name] || { stock: 0 };
                const margin = ((p.price - p.cost) / p.cost * 100).toFixed(1);
                return `
        <div class="item">
            <div style="display: flex; gap: 12px; align-items: start;">
                <input type="checkbox" class="checkbox-select" 
                       ${state.selectedItems.products && state.selectedItems.products[p.id] ? 'checked' : ''}
                       onchange="toggleSelect('products', '${p.id}')">
                <div style="flex: 1;">
                        <div class="item-title">${p.name}</div>
                        <div class="item-subtitle">
                            Category: ${p.category} | ${p.hasStock === false ? 'Service (no stock)' : 'Stock: ' + inv.stock + ' units'}<br>
                            Margin: ${margin}%
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 14px;">
                            <span>Cost:  ${formatNumber(p.cost)} Tsh</span>
                            <span>Price:  ${formatNumber(p.price)} Tsh</span>
                            <span style="color: #2e7d32; font-weight: 600;">+${formatNumber(p.price - p.cost)} Tsh</span>
                        </div>
                        <div class="flex-gap" style="margin-top:8px;">
                        <button class="btn-small" onclick="editProductIndex(${actualIndex})">Edit</button>
                        <button class="btn-small btn-danger" onclick="deleteProductIndex(${actualIndex})">Delete</button>
                    </div>
                </div>
            </div>
        </div>
    `;
            }).join('');
        }

        function toggleNewProductCategory() {
            const select = document.getElementById('productCategory');
            const group = document.getElementById('newCategoryFields');
            if (!select || !group) return;
            group.style.display = (select.value === 'new') ? 'block' : 'none';
        }

        function searchProducts(Period) {
            state.productSearch = Period;
            document.getElementById('productsList').innerHTML = renderProductsList(Period);
        }

        async function addProduct(e) {
            e.preventDefault();
            let name = document.getElementById('productName').value.trim();
            name = capitalizeFirstWordValue(name);
            let category = document.getElementById('productCategory').value;
            if (typeof category === 'string') category = category.trim();
            const cost = parseMoney(document.getElementById('productCost').value);
            const price = parseMoney(document.getElementById('productPrice').value);
            const stock = parseMoney(document.getElementById('productStock').value) || 0;
            const hasStock = (document.getElementById('productHasStock')?.value !== 'no');

            if (cost < 0 || price < 0) {
                return showToast('Cost and price must be positive', 'error');
            }

            if (price < cost) {
                if (!confirm('Warning: Selling price is less than cost. Continue?')) {
                    return;
                }
            }

            if (state.products.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                return showToast('Product already exists', 'error');
            }

            if (category === 'new') {
                const newCat = (document.getElementById('newCategoryName')?.value || '').trim();
                if (!newCat) {
                    return showToast('Please enter new category name', 'error');
                }
                category = capitalizeFirstWordValue(newCat);
                if (!state.categories.includes(category)) {
                    state.categories.push(category);
                    saveData();
                }
            }
            if (category && category !== 'new') category = capitalizeFirstWordValue(category);

            const product = {
                id: generateID('products'),
                name,
                category,
                cost,
                price,
                hasStock
            };
            state.products.push(product);

            // Initialize inventory for new product
            if (!state.inventory) {
                state.inventory = {};
            }

            // Only set initial stock for stock-tracked products
            if (hasStock) {
                state.inventory[name] = {
                    stock: parseInt(stock) || 0,
                    minAlert: 5
                };
            }

            saveData();
            render();
            showToast("Product added", "info", null, null, 2000);

            if (syncEnabled) {
                await upsertOne('unpaid_entries', {
                    name: entry.name,
                    type: entry.type,
                    amount: entry.amount,
                    date: entry.date,
                    time: entry.time,
                    timestamp: entry.timestamp,
                    paid: entry.paid
                });
                syncInBackground();
            }
        }

        function editProductIndex(i) {
            const p = state.products[i];
            if (!p) return showToast("Product not found", "error");
            const name = prompt("Product name:", p.name);
            const cost = prompt("Cost:", p.cost);
            const price = prompt("Price:", p.price);
            if (name && cost && price) {
                const costNum = parseMoney(cost);
                const priceNum = parseMoney(price);

                if (costNum < 0 || priceNum < 0) {
                    return showToast('Cost and price must be positive', 'error');
                }

                const oldName = p.name;
                p.name = capitalizeFirstWordValue(name.trim());
                p.cost = costNum;
                p.price = priceNum;

                if (state.inventory && oldName !== p.name) {
                    if (p.hasStock === false) {
                        if (state.inventory[oldName]) delete state.inventory[oldName];
                    } else {
                        state.inventory[p.name] = state.inventory[oldName] || { stock: 0, minAlert: 5 };
                        delete state.inventory[oldName];
                    }
                }
                saveData();
                render();
                showToast("Product updated", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            }
        }

        function deleteProductIndex(i) {
            showConfirm("Delete this item?", async function () {
                try { playDeleteSound(); } catch (e) { }
                const p = state.products[i];
                if (p && p.name && state.inventory && state.inventory[p.name]) delete state.inventory[p.name];
                if (p) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('products', { name: p.name, category: p.category || '' });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('products', { name: p.name, category: p.category || '' });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.products.splice(i, 1);
                saveData();
                render();
                showToast("Product deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }
        function renderCategories() {
            const q = state.categorySearch || '';
            return `
                <div class="card">
                    <h2>Add Category</h2>
                    <div class="card-header-buttons">
                        <button class="quick-nav-btn back" onclick="switchTab('products')"> Products/Services</button>
                    </div>
                    <form onsubmit="addCategory(event)">
                        <div class="form-group">
                            <input type="text" id="categoryName" placeholder="Category Name" required>
                        </div>
                        <button type="submit">Add Category</button>
                    </form>
                </div>

               <div class="card">
    <h2>All Categories (${state.categories.length})</h2>
    <div class="search-box" style="margin:8px 0;">
        <input type="text" placeholder=" Search categories..." oninput="searchCategories(this.value)" id="categorySearch" value="${q}">
    </div>
    
    ${state.categories.length > 0 ? `
        <div class="bulk-actions">
            <input type="checkbox" id="selectAll_categories" onchange="toggleSelectAllCategories()" class="checkbox-select">
            <label for="selectAll_categories">Select All</label>
            <span style="color: #666; font-size: 12px; margin-left: 8px;">
                ${getSelectedCategoryCount()} selected
            </span>
            <button class="btn-small btn-danger" onclick="bulkDeleteCategories()" ${!hasSelectedCategories() ? 'disabled' : ''}>
                 Delete Selected
            </button>
        </div>
    ` : ''}
    <div id="categoriesList">${renderCategoriesList(q)}</div>
    ${(() => { const total = (state.categories || []).filter(cat => !q || String(cat).toLowerCase().includes(q.toLowerCase())).length; const count = (state.listShowCount && state.listShowCount.categories) ? state.listShowCount.categories : 3; const hasMore = count < total; return `<button class=\"collapse-btn\" onclick=\"${hasMore ? `showMoreList('categories')` : `collapseList('categories')`}\"><span class=\"collapse-icon ${hasMore ? '' : 'expanded'}\"></span><span>${hasMore ? 'See more' : 'Hide'}</span></button>`; })()}
</div>
            `;
        }

        function renderCategoriesList(Period) {
            const q = String(Period || '').toLowerCase();
            let cats = state.categories.map((cat, i) => ({ cat, i }))
                .filter(({ cat }) => !q || String(cat).toLowerCase().includes(q))
            const count = (state.listShowCount && state.listShowCount.categories) ? state.listShowCount.categories : 3;
            return cats.slice(0, count).map(({ cat, i }) => `
            <div class="item">
                <div style="display: flex; gap: 12px; align-items: center;">
                    <input type="checkbox" class="checkbox-select" 
                           ${state.selectedItems.categories && state.selectedItems.categories[i] ? 'checked' : ''}
                           onchange="toggleSelectCategory(${i})">
                    <div style="flex: 1; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <span class="item-title">${cat}</span>
                            <div class="item-subtitle">${state.products.filter(p => p.category === cat).length} products</div>
                        </div>
                        <div class="flex-gap">
                            <button class="btn-small" onclick="editCategoryIndex(${i})">Edit</button>
                            <button class="btn-small btn-danger" onclick="deleteCategoryIndex(${i})">Delete</button>
                        </div>
                    </div>
                </div>
            </div>
        `).join('') || '<p style="text-align: center; color: #666;">No categories yet</p>';
        }

        function searchCategories(Period) {
            state.categorySearch = Period;
            const el = document.getElementById('categoriesList');
            if (el) el.innerHTML = renderCategoriesList(Period);
        }

        function toggleSelectAllCategories() {
            if (!state.selectedItems.categories) state.selectedItems.categories = {};

            // Check if all categories are currently selected
            const allSelected = state.categories.every((cat, i) => state.selectedItems.categories[i]);

            // Toggle: if all selected, unselect all; otherwise, select all
            const newState = !allSelected;

            state.categories.forEach((cat, i) => {
                state.selectedItems.categories[i] = newState;
            });

            saveData();
            render(); // RE-RENDER TO SHOW CHECKED ITEMS
        }

        function toggleSelectCategory(index) {
            if (!state.selectedItems.categories) state.selectedItems.categories = {};
            state.selectedItems.categories[index] = !state.selectedItems.categories[index];
            saveData();
            render(); // RE-RENDER TO UPDATE CHECKBOXES AND COUNT
        }

        function hasSelectedCategories() {
            return state.selectedItems.categories && Object.values(state.selectedItems.categories).some(v => v);
        }

        function getSelectedCategoryCount() {
            if (!state.selectedItems.categories) return 0;
            return Object.values(state.selectedItems.categories).filter(v => v).length;
        }

        function bulkDeleteCategories() {
            const selected = Object.keys(state.selectedItems.categories || {})
                .filter(i => state.selectedItems.categories[i])
                .map(i => parseInt(i));

            if (selected.length === 0) return showToast('No categories selected', 'info');

            showConfirm(`Delete ${selected.length} selected categories?`, async function () {
                // Sort in reverse to delete from end first
                selected.sort((a, b) => b - a).forEach(i => {
                    const name = state.categories[i];
                    if (syncEnabled && name) { try { deleteOne('categories', { name }); } catch { } }
                    state.categories.splice(i, 1);
                });

                state.selectedItems.categories = {};
                saveData();
                render();
                showToast(`${selected.length} categories deleted`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        async function addCategory(e) {
            e.preventDefault();
            const nameRaw = document.getElementById('categoryName').value.trim();
            const name = capitalizeFirstWordValue(nameRaw);
            if (state.categories.includes(name)) return showToast('Category already exists', 'error');

            state.categories.push(name);
            saveData();
            render();
            showToast("Category added", "success");

            // Sync in background
            if (syncEnabled) {
                await upsertOne('categories', { name });
                syncInBackground();
            }
        }

        function editCategoryIndex(i) {
            const oldName = state.categories[i];
            const name = prompt("Category name:", oldName);
            if (name && name.trim()) {
                const newName = capitalizeFirstWordValue(name.trim());
                if (state.categories.includes(newName) && newName !== oldName) {
                    return showToast('Category already exists', 'error');
                }
                state.categories[i] = newName;
                // Update products with this category
                state.products.forEach(p => {
                    if (p.category === oldName) p.category = newName;
                });
                saveData();
                render();
                showToast("Category updated", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            }
        }

        function deleteCategoryIndex(i) {
            const cat = state.categories[i];
            const productsInCategory = state.products.filter(p => p.category === cat).length;
            if (productsInCategory > 0) {
                if (!confirm(`This category has ${productsInCategory} products. Delete anyway?`)) {
                    return;
                }
            }
            showConfirm("Delete this category?", async function () {
                try { playDeleteSound(); } catch (e) { }
                state.categories.splice(i, 1);
                saveData();
                render();
                showToast("Category deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }

        function renderExpenses() {
            const stats = getStats();

            let filteredExpenses = state.expenses.slice();

            if (state.searchPeriod) {
                const Period = state.searchPeriod.toLowerCase();
                filteredExpenses = filteredExpenses.filter(e =>
                    e.description.toLowerCase().includes(Period) ||
                    e.category.toLowerCase().includes(Period)
                );
            }

            if (state.filterDateFrom) {
                filteredExpenses = filteredExpenses.filter(e => new Date(e.date) >= new Date(state.filterDateFrom));
            }

            if (state.filterDateTo) {
                filteredExpenses = filteredExpenses.filter(e => new Date(e.date) <= new Date(state.filterDateTo));
            }

            if (state.filterCategory) {
                filteredExpenses = filteredExpenses.filter(e => e.category === state.filterCategory);
            }

            return `
                <div class="stat-grid">
                    <div class="stat-card">
                        <div class="stat-label">TOTAL EXPENSES</div>
                        <div class="stat-value"> ${formatNumber(stats.totalExpenses)} Tsh</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">MONTH EXPENSES</div>
                        <div class="stat-value"> ${formatNumber(stats.monthExpenses)} Tsh</div>
                    </div>
                </div>

                <div class="card">
                    <h2>Add Expense</h2>
                    <form onsubmit="addExpense(event)">
                        <div class="form-group">
                            <label>Description</label>
                            <input type="text" id="expenseDesc" placeholder="e.g., Rent, Utilities" required>
                        </div>
                        <div class="form-group">
                            <label>Category</label>
                            <select id="expenseCategory">
                                <option>Rent</option>
                                <option>Utilities</option>
                                <option>Supplies</option>
                                <option>Salaries</option>
                                <option>Marketing</option>
                                <option>Transportation</option>
                                <option>Office Electricity bills</option>
                                <option>Waste disposal bills</option>
                                <option>Food Expenses</option>
                                <option>Miscellaneous</option>
                                <option>Machine Repair bills</option>
                                <option>Home rent</option>
                                <option>Other</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Amount</label>
                            <input type="text" id="expenseAmount" class="money-input" placeholder="0" required>
                        </div>
                        <div class="form-group">
                            <label>Payment Method</label>
                            <select id="expensePayment">
                                <option>Cash</option>
                                <option>Card</option>
                                <option>Mobile Money</option>
                                <option>M-Pesa Lipa Number</option>
                                <option>Bank Transfer</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Comment (Optional)</label>
                            <textarea id="expenseComment" placeholder="Additional notes..."></textarea>
                        </div>
                        <button type="submit">Add Expense</button>
                    </form>
                </div>

                <div class="card">
                    <h2>Recent Expenses (${filteredExpenses.length})</h2>
                    
                    <div class="search-box">
                        <input type="text" placeholder=" Search expenses..." oninput="updateSearchPeriod(this.value)">
                    </div>

                    <div class="filter-row">
                        <input type="date" placeholder="From" onchange="updateFilterDateFrom(this.value)" value="${state.filterDateFrom || ''}">
                        <input type="date" placeholder="To" onchange="updateFilterDateTo(this.value)" value="${state.filterDateTo || ''}">
                        <select onchange="updateFilterCategory(this.value)">
                            <option value="">All Categories</option>
                            ${[...new Set(state.expenses.map(e => e.category))]
                    .filter(c => !!c)
                    .sort((a, b) => String(a).localeCompare(String(b)))
                    .map(c =>
                        `<option value="${c}" ${state.filterCategory === c ? 'selected' : ''}>${c}</option>`
                    ).join('')}
                        </select>
                        <button class="btn-small btn-secondary" onclick="clearFilters()">Clear</button>
                    </div>
                    </div>

    ${filteredExpenses.length > 0 ? `
        <div class="bulk-actions">
            <input type="checkbox" id="selectAll_expenses" onchange="toggleSelectAll('expenses')" class="checkbox-select">
            <label for="selectAll_expenses">Select All</label>
            <span style="color: #666; font-size: 12px; margin-left: 8px;">
                ${getSelectedCount('expenses')} selected
            </span>
            <button class="btn-small btn-danger" onclick="bulkDelete('expenses')" ${!hasSelected('expenses') ? 'disabled' : ''}>
                 Delete Selected
            </button>
        </div>
    ` : ''}

                    <div id="expensesList">
                    ${(() => {
                    const arr = filteredExpenses.slice().reverse(); const count = (state.listShowCount && state.listShowCount.expenses) ? state.listShowCount.expenses : 3; return arr.slice(0, count).map((e, idx) => `
    <div class="item">
        <div style="display: flex; gap: 12px; align-items: start;">
            <input type="checkbox" class="checkbox-select" 
                   ${state.selectedItems.expenses && state.selectedItems.expenses[e.id] ? 'checked' : ''}
                   onchange="toggleSelect('expenses', '${e.id}')">
            <div style="flex: 1;">
                <div class="item-header">
                                <span class="item-title">${e.description}</span>
                                <span style="color: #d32f2f; font-weight: 700;"> ${formatNumber(e.amount)} Tsh</span>
                            </div>
                            <div class="item-subtitle">
                                ${e.date} | ${e.category} | ${e.payment}
                                ${e.comment ? '<br> ' + e.comment : ''}
                            </div>
                            ${e.category === 'Inventory Purchase' && /^Period \d+/.test(e.comment || '') ? `
                            <div class=\"flex-gap\" style=\"margin-top:8px;\">
                                <button class=\"btn-small\" onclick=\"openInventoryForPeriod(${parseInt(String(e.comment).replace('Period ', ''), 10)})\">Update Stock Info</button>
                                <button class=\"btn-small btn-danger\" onclick=\"terminateInventoryPeriod(${parseInt(String(e.comment).replace('Period ', ''), 10)})\">Delete</button>
                            </div>
                            ` : `
                            <div class=\"flex-gap\" style=\"margin-top:8px;\">
                                <button class=\"btn-small\" onclick=\"editExpenseIndex(${state.expenses.length - 1 - idx})\">Edit</button>
                                <button class=\"btn-small btn-danger\" onclick=\"deleteExpenseIndex(${state.expenses.length - 1 - idx})\">Delete</button>
                            </div>
                            `}
                </div>
            </div>
        </div>
    </div>
                    `).join('') || '<p style="text-align: center; color: #666;">No expenses yet</p>'
                })()}
                    </div>
                    ${(() => { const total = filteredExpenses.length; const count = (state.listShowCount && state.listShowCount.expenses) ? state.listShowCount.expenses : 3; const hasMore = count < total; return `<button class=\"collapse-btn\" onclick=\"${hasMore ? `showMoreList('expenses')` : `collapseList('expenses')`}\"><span class=\"collapse-icon ${hasMore ? '' : 'expanded'}\"></span><span>${hasMore ? 'See more' : 'Hide'}</span></button>`; })()}
                </div>
            `;
        }

        function updateFilterCategory(value) {
            state.filterCategory = value;
            render();
        }

        async function addExpense(e) {
            e.preventDefault();
            const amount = parseMoney(document.getElementById('expenseAmount').value);
            if (isNaN(amount) || amount <= 0) {
                return showToast('Please enter a valid amount', 'error');
            }

            const now = new Date();  //  ADD THIS LINE

            const expense = {
                id: generateID('expenses'),
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime(),
                description: document.getElementById('expenseDesc').value.trim(),
                category: document.getElementById('expenseCategory').value,
                amount: amount,
                payment: document.getElementById('expensePayment').value,
                comment: document.getElementById('expenseComment').value.trim()
            };

            state.expenses.push(expense);
            saveData();
            render();
            showToast("Expense added", "success");

            // Always attempt to upsert the expense; it will be queued if not authenticated
            await upsertOne('expenses', {
                date: expense.date,
                time: expense.time,
                timestamp: expense.timestamp,
                description: expense.description,
                category: expense.category,
                amount: expense.amount,
                payment: expense.payment,
                comment: expense.comment
            });
            if (syncEnabled) syncInBackground();
        }

        async function editExpenseIndex(i) {
            const e = state.expenses[i];
            if (!e) return showToast("Expense not found", "error");
            const desc = prompt("Description:", e.description);
            const amt = prompt("Amount:", e.amount);
            if (desc && amt) {
                const amtNum = parseFloat(amt);
                if (!isNaN(amtNum) && amtNum > 0) {
                    e.description = desc.trim();
                    e.amount = amtNum;
                    e.timestamp = Date.now();
                    saveData();
                    render();
                    showToast("Expense updated", "success");

                    if (syncEnabled) {
                        await upsertOne('expenses', {
                            date: e.date,
                            time: e.time,
                            timestamp: e.timestamp,
                            description: e.description,
                            category: e.category,
                            amount: e.amount,
                            payment: e.payment,
                            comment: e.comment
                        });
                        syncInBackground();
                    }
                } else {
                    showToast("Invalid amount", "error");
                }
            }
        }

        function deleteExpenseIndex(i) {
            showConfirm("Delete this expense?", async function () {
                try { playDeleteSound(); } catch (e) { }
                const e = state.expenses[i];
                if (e) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('expenses', { timestamp: e.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('expenses', { timestamp: e.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.expenses.splice(i, 1);
                saveData();
                render();
                showToast("Expense deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }

        function renderInventory() {
            const trackedProducts = state.products.filter(p => p.hasStock !== false);
            const lowStock = trackedProducts.filter(p => {
                const inv = state.inventory[p.name] || { stock: 0, minAlert: 5 };
                return inv.stock <= inv.minAlert;
            });
            const q = state.stockSearch || '';
            const totalUnits = trackedProducts.reduce((sum, p) => sum + ((state.inventory[p.name] || { stock: 0 }).stock || 0), 0);
            const totalValue = trackedProducts.reduce((sum, p) => sum + (((state.inventory[p.name] || { stock: 0 }).stock || 0) * (p.cost || 0)), 0);

            return `
                ${lowStock.length > 0 ? `
                    <div class="alert-box-danger">
                        <strong> ${lowStock.length} Products Low on Stock!</strong>
                    </div>
                ` : ''
                }

            <div class="card">
                <div class="flex-between">
                    <h2>Stock Levels</h2>
                    <div class="search-box" style="max-width:260px;">
                        <input type="text" id="stockSearch" placeholder=" Search stock..." oninput="searchStock(this.value)" value="${q}" />
                    </div>
                </div>
                <div class="flex-gap" style="margin-top:8px;">
                    <span class="badge">Items: ${trackedProducts.length}</span>
                    <span class="badge ${lowStock.length > 0 ? 'badge-danger' : 'badge-success'}">Low Stock: ${lowStock.length}</span>
                    <span class="badge">Units: ${formatNumber(totalUnits)}</span>
                    <span class="badge">Value: ${formatNumber(totalValue)} Tsh</span>
                </div>
                <div id="stockList">${renderStockList(q)}</div>
                ${(() => { const total = state.products.filter(p => p.hasStock !== false).filter(p => !q || p.name.toLowerCase().includes(q.toLowerCase()) || String(p.category || '').toLowerCase().includes(q.toLowerCase())).length; const count = (state.listShowCount && state.listShowCount.inventory) ? state.listShowCount.inventory : 3; const hasMore = count < total; return `<button class="collapse-btn" onclick="${hasMore ? `showMoreList('inventory')` : `collapseList('inventory')`}"><span class="collapse-icon ${hasMore ? '' : 'expanded'}"></span><span>${hasMore ? 'See more' : 'Hide'}</span></button>`; })()}
                </div>
            `;
        }

        function renderStockList(query) {
            const q = String(query || '').toLowerCase();
            const trackedProducts = state.products.filter(p => p.hasStock !== false);
            const count = (state.listShowCount && state.listShowCount.inventory) ? state.listShowCount.inventory : 3;
            return trackedProducts.filter(p => !q || p.name.toLowerCase().includes(q) || String(p.category || '').toLowerCase().includes(q)).slice(0, count).map(p => {
                const inv = state.inventory[p.name] || { stock: 0, minAlert: 5 };
                const isLow = inv.stock <= inv.minAlert;
                const stockValue = inv.stock * p.cost;
                return `
                <div class="item" style="${isLow ? 'border-left: 4px solid #d32f2f;' : ''}">
                                <div class="item-header">
                                    <span class="item-title">${p.name}</span>
                                    <span class="badge ${isLow ? 'badge-danger' : 'badge-success'}">
                                        ${isLow ? ' LOW' : ' OK'}
                                    </span>
                                </div>
                                <div class="item-subtitle">
                                    Stock: ${inv.stock} units | Min Alert: ${inv.minAlert}<br>
                                    Value:  ${formatNumber(stockValue)} Tsh
                                </div>
                                <div class="flex-gap" style="margin-top: 8px;">
                                    <button class="btn-success btn-small" onclick="adjustStock('${p.name}', 10)">+10</button>
                                    <button class="btn-success btn-small" onclick="adjustStock('${p.name}', 1)">+1</button>
                                    <button class="btn-danger btn-small" onclick="adjustStock('${p.name}', -1)">-1</button>
                                    <input type="number" id="inv_input_${encodeURIComponent(p.name)}" value="${inv.stock}" min="0" style="width:80px;padding:6px;" />
                                    <button class="btn-small" onclick="saveStockFor('${p.name}')">Save</button>
                                    <button class="btn-small btn-secondary" onclick="setMinAlert('${p.name}')"> ${inv.minAlert}</button>
                                </div>
                            </div >
                `;
            }).join('') || '<p style="text-align: center; color: #666;">No stock-tracked items yet</p>';
        }

        function searchStock(q) {
            state.stockSearch = q;
            const el = document.getElementById('stockList');
            if (el) el.innerHTML = renderStockList(q);
        }

        // Unified Inventory Tab: Purchases + Stock
        function renderInventoryTab() {
            // Summary
            const purchases = (state.inventoryPurchases || []);
            const cycles = (state.inventoryPurchaseCycles || []);
            const totalSpent = purchases.reduce((s, p) => s + (Number(p.totalCost) || Number(p.buyingPrice) || 0), 0);
            const uniqueSuppliers = Array.from(new Set(purchases.map(p => (p.supplierName || '').trim()).filter(Boolean))).length;

            // Filters
            const filter = state.inventoryFilters || {};
            const cycleOptions = cycles.length > 0
                ? `<option value="">All Periods</option>` + cycles.map(c => `<option value="${c.number}">Period ${c.number} ${c.title ? ' ' + c.title : ''}</option>`).join('')
                : '<option value="">No Periods yet</option>';

            // Filtered purchases
            const filtered = purchases.filter(p => {
                const matchPeriod = !filter.PeriodNumber || String(p.cycleNumber) === String(filter.PeriodNumber);
                const matchSupplier = !filter.supplier || (p.supplierName || '').toLowerCase().includes(filter.supplier.toLowerCase());
                const df = filter.dateFrom ? new Date(filter.dateFrom).getTime() : null;
                const dt = filter.dateTo ? new Date(filter.dateTo).getTime() : null;
                const ts = p.timestamp || (p.purchaseDate ? new Date(p.purchaseDate).getTime() : 0);
                const matchDate = (!df || ts >= df) && (!dt || ts <= dt);
                return matchPeriod && matchSupplier && matchDate;
            });

            // Group by Period
            const showCount = state.inventoryPeriodsShowCount || 3;
            const cyclesSorted = cycles.slice().sort((a, b) => b.number - a.number);
            const visibleCycles = cyclesSorted.slice(0, showCount);
            const groupedHTML = visibleCycles.map(cycle => {
                const cps = filtered.filter(p => p.cycleNumber === cycle.number);
                const cycleTotal = cps.reduce((sum, p) => sum + (Number(p.totalCost) || Number(p.buyingPrice) || 0), 0);
                const cycleStart = cycle.startDate || (cps[0]?.purchaseDate) || '';
                const nextCycle = cycles.find(c => c.number === cycle.number + 1);
                const cycleEnd = cycle.endDate || (nextCycle?.startDate) || '';
                let lastedText = '';
                if (cycleStart && cycleEnd) {
                    const days = Math.round((new Date(cycleEnd).getTime() - new Date(cycleStart).getTime()) / (1000 * 60 * 60 * 24));
                    if (!isNaN(days)) lastedText = `Lasted: ${days} day${days === 1 ? '' : 's'} `;
                }
                return `
                <div class="card">
                    <div class="flex-between">
                        <h2>Period ${cycle.number} ${cycle.title ? ' ' + cycle.title : ''}</h2>
                        <div class="flex-gap">
                            <span class="badge">Items: ${cps.length}</span>
                            <span class="badge">Spent: ${formatNumber(cycleTotal)} Tsh</span>
                            ${lastedText ? `<span class="badge">${lastedText}</span>` : ''}
                            <button class="btn-small" onclick="downloadInventoryCyclePDF(${cycle.number})"> Period PDF</button>
                            <button class="btn-small btn-danger" onclick="terminateInventoryPeriod(${cycle.number})"> Terminate</button>
                        </div>
                    </div>
                        ${cps.length === 0 ? '<p style="color:#666">No purchases in this Period</p>' : cps.map(p => `
                            <div class="item">
                                <div class="item-header">
                                    <span class="item-title">${p.itemName}  ${p.quantity || 1}</span>
                                    <span class="item-subtitle">${p.purchaseDate || ''} ${p.time || ''}</span>
                                </div>
                                <div class="item-subtitle">
                                    Unit: ${formatNumber(p.unitCost || p.buyingPrice)} Tsh | Total: ${formatNumber(p.totalCost || (p.buyingPrice || 0))} Tsh<br>
                                    ${p.discount ? `Discount: ${formatNumber(p.discount)} Tsh<br>` : ''}
                                    Supplier: ${escapeHTML(p.supplierName || '')} ${p.supplierPhone ? '(' + escapeHTML(p.supplierPhone) + ')' : ''}<br>
                                    ${escapeHTML(p.supplierAddress || '')}
                                    ${p.notes ? `<br>Notes: ${escapeHTML(p.notes)}` : ''}
                                </div>
                                <div class="flex-gap" style="margin-top:8px;">
                                    <button class="btn-small" onclick="openUpdateInventoryForPurchase(${p.timestamp})">Update Stock Info</button>
                                    <button class="btn-small btn-danger" onclick="deleteInventoryPurchaseByTimestamp(${p.timestamp})">Delete</button>
                                </div>
                            </div>
                        `).join('')
                    }
                    </div>
                `;
            }).join('');

            // Build UI
            const summary = `
                <div class="card">
                    <div class="flex-between">
                        <h2>Inventory</h2>
                        <div class="flex-gap">
                            <button class="btn-success" onclick="openInventoryModal()"> Add Inventory Purchase</button>
                            <button class="btn-small" onclick="generateInventoryReport('csv')"> Generate Report (CSV)</button>
                            <button class="btn-small" onclick="downloadInventoryPurchasesReportPDF()"> Generate Report (PDF)</button>
                            <button class="btn-small" onclick="downloadInventoryStockSheetPDF()"> Generate Stock Sheet (PDF)</button>
                        </div>
                    </div>
                    <div class="flex-gap" style="margin-top:8px;">
                        <span class="badge">Purchases: ${purchases.length}</span>
                        <span class="badge">Suppliers: ${uniqueSuppliers}</span>
                        <span class="badge">Total Spent: ${formatNumber(totalSpent)} Tsh</span>
                    </div>
                </div>`;

            const filters = `
                <div class="card">
                    <h3>Filter</h3>
                    <div class="grid-2" style="gap:12px;">
                        <div>
                            <label>Period</label>
                            <select id="invFilterPeriod" onchange="updateInventoryFilter('PeriodNumber', this.value)">${cycleOptions}</select>
                        </div>
                        <div>
                            <label>Supplier</label>
                            <input id="invFilterSupplier" type="text" value="${filter.supplier || ''}" placeholder="Supplier name" oninput="updateInventoryFilter('supplier', this.value)" />
                        </div>
                        <div>
                            <label>From</label>
                            <input id="invFilterFrom" type="date" value="${filter.dateFrom || ''}" onchange="updateInventoryFilter('dateFrom', this.value)" />
                        </div>
                        <div>
                            <label>To</label>
                            <input id="invFilterTo" type="date" value="${filter.dateTo || ''}" onchange="updateInventoryFilter('dateTo', this.value)" />
                        </div>
                    </div>
                </div>`;

            // Embed the existing stock view
            const stock = renderInventory();

            const moreBtn = (() => { const total = cyclesSorted.length; const hasMore = showCount < total; return hasMore ? `<div style="display:flex;justify-content:center;margin:8px 0;"><button class="collapse-btn" onclick="showMoreInventoryPeriods()"><span class="collapse-icon"></span><span>See more</span></button></div>` : `<div style="display:flex;justify-content:center;margin:8px 0;"><button class="collapse-btn" onclick="collapseInventoryPeriods()"><span class="collapse-icon expanded"></span><span>Hide</span></button></div>`; })();
            return summary + filters + (groupedHTML || '<p style="text-align:center;color:#666;">No Periods yet. Add an inventory purchase to create a new Period.</p>') + moreBtn + stock;
        }

        function showMoreInventoryPeriods() {
            const total = (state.inventoryPurchaseCycles || []).length;
            const current = state.inventoryPeriodsShowCount || 3;
            state.inventoryPeriodsShowCount = Math.min(total, current + 3);
            saveData();
            render();
        }

        function collapseInventoryPeriods() {
            state.inventoryPeriodsShowCount = 3;
            saveData();
            render();
        }

        function openInventoryForPeriod(num) {
            openInventoryModal();
            setTimeout(() => {
                try {
                    const perSel = document.getElementById('invPeriodSelect');
                    const chkNew = document.getElementById('invCreateNewPeriod');
                    if (perSel) perSel.value = String(num);
                    if (chkNew) chkNew.checked = false;
                } catch { }
            }, 50);
        }

        function processPlannedPurchases() {
            const todayTs = new Date(getTodayDateString()).getTime();
            (state.inventoryPurchases || []).forEach(p => {
                const pt = new Date(p.purchaseDate || getTodayDateString()).getTime();
                if (p.planned && !p.activated && pt <= todayTs) {
                    updateProductStock(p.itemName, p.quantity);
                    p.activated = true;
                }
            });
        }

        function terminateInventoryPeriod(num) {
            const purchases = (state.inventoryPurchases || []).filter(p => p.cycleNumber === num);
            purchases.forEach(p => {
                const inv = state.inventory[p.itemName] || { stock: 0, minAlert: 5 };
                inv.stock = Math.max(0, (inv.stock || 0) - (p.quantity || 0));
                state.inventory[p.itemName] = inv;
            });
            try {
                purchases.forEach(p => { try { deleteOne('inventory_purchases', { timestamp: p.timestamp }); } catch { } });
            } catch { }
            state.inventoryPurchases = (state.inventoryPurchases || []).filter(p => p.cycleNumber !== num);
            state.inventoryPurchaseCycles = (state.inventoryPurchaseCycles || []).filter(c => c.number !== num);
            saveData();
            render();
            showToast('Period terminated', 'success');

            (async () => {
                if (syncEnabled && currentUser) {
                    try {
                        const { error: perr } = await supabase
                            .from('inventory_purchase_periods')
                            .delete()
                            .match({ user_id: currentUser.id, period_number: num });
                        if (perr) console.warn('Cloud period delete error:', perr.message || perr);

                        const { error: eerr } = await supabase
                            .from('expenses')
                            .delete()
                            .match({ user_id: currentUser.id, comment: `Period ${num} ` });
                        if (eerr) console.warn('Cloud expenses delete error:', eerr.message || eerr);

                        const affected = Array.from(new Set(purchases.map(p => p.itemName)));
                        for (const name of affected) {
                            const inv = state.inventory[name] || { stock: 0, minAlert: 5 };
                            await upsertOne('inventory', { product_name: name, stock: inv.stock || 0, min_alert: inv.minAlert || 5 });
                        }
                        syncInBackground();
                        showToast('Cloud updated', 'success');
                    } catch (err) {
                        console.warn('Cloud update after termination failed:', err?.message || err);
                        showToast('Cloud update failed; will retry when online', 'info');
                    }
                }
            })();
        }

        function updateInventoryFilter(key, value) {
            state.inventoryFilters = state.inventoryFilters || {};
            state.inventoryFilters[key] = value;
            saveData();
            render();
        }

        function openInventoryModal() {
            const modal = document.getElementById('inventoryModal');
            const content = document.getElementById('inventoryModalContent');
            if (!modal || !content) return;
            function getInventoryProductOptions() {
                const all = (state.products || []).filter(p => p.hasStock !== false);
                if (all.length === 0) return '<option value="">No products found</option>';
                const recent = all.slice(-3).map(p => p.name);
                const rest = all
                    .filter(p => !recent.includes(p.name))
                    .slice()
                    .sort((a, b) => String(a.name).localeCompare(String(b.name)))
                    .map(p => p.name);
                const ordered = [...recent, ...rest];
                const opts = ordered.map(name => `<option value="${name}">${name}</option>`).join('');
                return opts + `<option class="opt-new" value="new">+ Add New Product</option>`;
            }
            const productOptions = getInventoryProductOptions();
            const cycles = state.inventoryPurchaseCycles || [];
            const nextPeriodNumber = (cycles?.length || 0) + 1;
            const defaultTitle = new Date().toLocaleString('en-GB', { month: 'long', year: 'numeric' }) + ' Period';
            const cycleOptions = cycles.map(c => `<option value="${c.number}">Period ${c.number} ${c.title ? ' ' + c.title : ''}</option>`).join('');

            content.innerHTML = `
                <div id="invToolbar" style="display:flex;align-items:center;gap:8px;justify-content:space-between;margin-bottom:8px;">
                    <button class="btn-small" id="invBulkToggle" type="button" onclick="invToggleBulkMode()" aria-pressed="false">Bulk Mode: Off</button>
                    <button class="btn-small" id="invAddBulkBtn" type="button" onclick="invAddBulkRow()" style="margin-left:auto; display:none;">+ Add Product</button>
                </div>
                <div id="invBulkContainer" style="display:none; margin-bottom:12px;"></div>
                <div id="invNewProductFields" style="display:none; margin-bottom:12px;">
                    <div class="card">
                        <h3>New Product</h3>
                        <div class="grid-2" style="gap:8px;">
                            <div>
                                <label>Name</label>
                                <input type="text" id="invNewProductName" placeholder="Enter product name" />
                            </div>
                            <div>
                                <label>Category</label>
                                <select id="invNewProductCategory" onchange="invHandleCategorySelection()">
                                    <option value="">-- Select Category --</option>
                                    <option class="opt-new" value="new">+ Add New Category</option>
                                    ${state.categories.slice().sort((a, b) => String(a).localeCompare(String(b))).map(c => `<option value="${c}">${c}</option>`).join('')}
                                </select>
                            </div>
                            <div id="invNewCategoryField" class="grid-span-2" style="display:none;">
                                <label>New Category Name</label>
                                <input type="text" id="invNewCategoryName" placeholder="Enter category name" />
                            </div>
                            <div class="grid-span-2" style="display:flex;align-items:center;gap:8px;">
                                <label style="margin:0;">Track stock</label>
                                <input type="checkbox" id="invNewProductHasStock" checked onchange="invToggleNewProductHasStock()" />
                            </div>
                            <div>
                                <label>Cost (Capital)</label>
                                <input type="text" id="invNewProductCost" class="money-input" placeholder="0" />
                            </div>
                            <div>
                                <label>Price (Selling)</label>
                                <input type="text" id="invNewProductPrice" class="money-input" placeholder="0" />
                            </div>
                            <div id="invNewProductStockGroup" class="grid-span-2">
                                <label>Initial Stock</label>
                                <input type="text" id="invNewProductStock" class="money-input" placeholder="0" value="0" />
                            </div>
                        </div>
                        <div class="flex-gap" style="margin-top:8px;">
                            <button class="btn-success" type="button" onclick="invSaveNewProductFromInventory()"> Save New Product</button>
                            <button class="btn-secondary" type="button" onclick="invCancelNewProduct()"> Cancel</button>
                        </div>
                    </div>
                </div>
                <div id="invSingleItemFields" class="grid-2" style="gap:12px;">
                    <div>
                        <label>Product</label>
                        <select id="invProductSelect" onchange="invHandleProductSelection()">${productOptions}</select>
                    </div>
                    <div>
                        <label>Quantity</label>
                        <input id="invQuantity" type="text" class="money-input" placeholder="Qty" />
                    </div>
                    <div>
                        <label>Unit Cost (Tsh)</label>
                        <input id="invUnitCost" type="text" class="money-input" placeholder="0" />
                    </div>
                    <div>
                        <label>Total Cost (auto)</label>
                        <input id="invTotalCost" type="text" placeholder="0" disabled />
                    </div>
                    <div>
                        <label>Discount (Tsh)</label>
                        <input id="invDiscount" type="text" class="money-input" placeholder="0" />
                    </div>
                </div>
                <div class="grid-2" style="gap:12px;">
                    <div>
                        <label>Supplier Name</label>
                        <input id="invSupplierName" type="text" placeholder="Supplier name" />
                    </div>
                    <div>
                        <label>Supplier Phone</label>
                        <input id="invSupplierPhone" type="text" placeholder="Phone" />
                    </div>
                    <div class="grid-span-2">
                        <label>Supplier Address</label>
                        <input id="invSupplierAddress" type="text" placeholder="Address" />
                    </div>
                    <div>
                        <label>Date</label>
                        <input id="invDate" type="date" value="${getTodayDateString()}" />
                    </div>
                    <div>
                        <label>Time</label>
                        <input id="invTime" type="time" value="${new Date().toISOString().slice(11, 16)}" />
                    </div>
                    <div class="grid-span-2">
                        <label>Notes (optional)</label>
                        <input id="invNotes" type="text" placeholder="Notes" />
                    </div>
                </div>

                <div id="invNewProductFields" style="display:none; margin-top:12px;">
                    <div class="card">
                        <h3>New Product</h3>
                        <div class="grid-2" style="gap:8px;">
                            <div>
                                <label>Name</label>
                                <input type="text" id="invNewProductName" placeholder="Enter product name" />
                            </div>
                            <div>
                                <label>Category</label>
                                <select id="invNewProductCategory" onchange="invHandleCategorySelection()">
                                    <option value="">-- Select Category --</option>
                                    <option class="opt-new" value="new">+ Add New Category</option>
                                    ${state.categories.slice().sort((a, b) => String(a).localeCompare(String(b))).map(c => `<option value="${c}">${c}</option>`).join('')}
                                </select>
                            </div>
                            <div id="invNewCategoryField" class="grid-span-2" style="display:none;">
                                <label>New Category Name</label>
                                <input type="text" id="invNewCategoryName" placeholder="Enter category name" />
                            </div>
                            <div class="grid-span-2" style="display:flex;align-items:center;gap:8px;">
                                <label style="margin:0;">Track stock</label>
                                <input type="checkbox" id="invNewProductHasStock" checked onchange="invToggleNewProductHasStock()" />
                            </div>
                            <div>
                                <label>Cost (Capital)</label>
                                <input type="text" id="invNewProductCost" class="money-input" placeholder="0" />
                            </div>
                            <div>
                                <label>Price (Selling)</label>
                                <input type="text" id="invNewProductPrice" class="money-input" placeholder="0" />
                            </div>
                            <div id="invNewProductStockGroup" class="grid-span-2">
                                <label>Initial Stock</label>
                                <input type="text" id="invNewProductStock" class="money-input" placeholder="0" value="0" />
                            </div>
                        </div>
                        <div class="flex-gap" style="margin-top:8px;">
                            <button class="btn-success" type="button" onclick="invSaveNewProductFromInventory()"> Save New Product</button>
                            <button class="btn-secondary" type="button" onclick="invCancelNewProduct()"> Cancel</button>
                        </div>
                    </div>
                </div>

                    <div class="card" style="margin-top:12px;">
                        <h3>Period</h3>
                        <div class="flex-gap">
                            <label style="display:flex;align-items:center;gap:8px;">
                                <input id="invCreateNewPeriod" type="checkbox" checked />
                                Create new Period (recommended)
                            </label>
                            <div>
                                <label>Existing Period</label>
                                <select id="invPeriodSelect" onchange="invOnPeriodChange()"><option value=""></option>${cycleOptions}</select>
                            </div>
                            <div>
                                <label>New Period Title</label>
                                <input id="invNewPeriodTitle" type="text" value="${defaultTitle}" />
                            </div>
                        </div>
                    </div>
            `;

            // Attach money formatters in modal
            try {
                ['invQuantity', 'invUnitCost', 'invDiscount', 'invNewProductCost', 'invNewProductPrice', 'invNewProductStock'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) attachMoneyFormatter(el);
                });
            } catch { }

            // Auto-update total cost
            setTimeout(() => {
                const qtyEl = document.getElementById('invQuantity');
                const unitEl = document.getElementById('invUnitCost');
                const totalEl = document.getElementById('invTotalCost');
                const discEl = document.getElementById('invDiscount');
                function updateTotal() {
                    const q = parseMoney(qtyEl.value || '0');
                    const u = parseMoney(unitEl.value || '0');
                    const d = parseMoney(discEl.value || '0');
                    const t = Math.max(0, (q * u) - d);
                    totalEl.value = formatMoney(t);
                }
                qtyEl?.addEventListener('input', updateTotal);
                unitEl?.addEventListener('input', updateTotal);
                discEl?.addEventListener('input', updateTotal);
                updateTotal();
            }, 0);

            const handleOutside = (e) => {
                if (e.target === modal) {
                    closeInventoryModal();
                }
            };
            modal.addEventListener('click', handleOutside, { once: true });

            // Floating Add Product button behavior
            try {
                const contentEl = document.querySelector('#inventoryModal .modal-content');
                const toolbarEl = document.getElementById('invToolbar');
                const addBtn = document.getElementById('invAddBulkBtn');
                const closeBtn = document.querySelector('#inventoryModal .modal-close');
                const stickThreshold = (toolbarEl?.offsetHeight || 0) + 8;
                const updateFloating = () => {
                    if (!contentEl || !toolbarEl || !addBtn) return;
                    if (contentEl.scrollTop > stickThreshold && addBtn.style.display !== 'none') {
                        // Move next to the Close (to the left)
                        try { closeBtn?.insertAdjacentElement('afterend', addBtn); } catch { }
                        addBtn.classList.add('floating-add');
                    } else {
                        // Move back into toolbar
                        try { toolbarEl?.appendChild(addBtn); } catch { }
                        addBtn.classList.remove('floating-add');
                    }
                };
                contentEl.addEventListener('scroll', updateFloating);
                updateFloating();
            } catch { }

            window.invToggleBulkMode = function (force) {
                const btn = document.getElementById('invBulkToggle');
                const addBtn = document.getElementById('invAddBulkBtn');
                let active = false;
                if (typeof force === 'boolean') {
                    active = force;
                } else {
                    const pressed = btn && btn.getAttribute('aria-pressed') === 'true';
                    active = !pressed;
                }
                if (btn) {
                    btn.setAttribute('aria-pressed', active ? 'true' : 'false');
                    btn.classList.toggle('btn-success', active);
                    btn.textContent = active ? 'Bulk Mode: On' : 'Bulk Mode: Off';
                }
                if (addBtn) addBtn.style.display = active ? 'inline-block' : 'none';
                const cont = document.getElementById('invBulkContainer');
                const header = document.getElementById('invBulkHeader');
                const single = document.getElementById('invSingleItemFields');
                if (cont) cont.style.display = active ? 'block' : 'none';
                if (header) header.style.display = active ? 'grid' : 'none';
                if (single) single.style.display = active ? 'none' : 'grid';
                if (active && cont && cont.children.length === 0) {
                    try { invAddBulkRow(); } catch { }
                }
            };
            window.invOnPeriodChange = function () {
                const sel = document.getElementById('invPeriodSelect');
                const createNew = document.getElementById('invCreateNewPeriod');
                const titleEl = document.getElementById('invNewPeriodTitle');
                if (!sel) return;
                if (sel.value) {
                    if (createNew) createNew.checked = false;
                    // keep title editable to allow updating existing Period title
                } else {
                    if (createNew) createNew.checked = true;
                }
            };
            window.invAddBulkRow = function () {
                const cont = document.getElementById('invBulkContainer');
                if (!cont) return;
                const btn = document.getElementById('invBulkToggle');
                if (btn && btn.getAttribute('aria-pressed') !== 'true') {
                    invToggleBulkMode(true);
                }
                const all = (state.products || []).filter(p => p.hasStock !== false).map(p => p.name);
                const recent = all.slice(-3);
                const rest = all.filter(n => !recent.includes(n)).sort((a, b) => String(a).localeCompare(String(b)));
                const ordered = [...recent, ...rest];
                const opts = ordered.map(name => `<option value="${name}">${name}</option>`).join('');
                const row = document.createElement('div');
                row.className = 'inv-bulk-row';
                row.style.display = 'grid';
                row.style.gridTemplateColumns = '2fr 1fr 1fr 1fr auto';
                row.style.gap = '8px';
                row.style.marginBottom = '8px';
                row.innerHTML = `
                    <div>
                        <label class="bulk-label">Product</label>
                        <select class="inv-bulk-name">${opts}</select>
                    </div>
                    <div>
                        <label class="bulk-label">Quantity</label>
                        <input class="inv-bulk-qty money-input" type="text" placeholder="Qty" />
                    </div>
                    <div>
                        <label class="bulk-label">Unit Cost</label>
                        <input class="inv-bulk-unit money-input" type="text" placeholder="Unit Cost" />
                    </div>
                    <div>
                        <label class="bulk-label">Discount</label>
                        <input class="inv-bulk-disc money-input" type="text" placeholder="Discount" />
                    </div>
                    <div>
                        <label class="bulk-label">Action</label>
                        <button class="btn-small btn-danger" type="button"></button>
                    </div>
                `;
                row.querySelector('button')?.addEventListener('click', () => {
                    try { cont.removeChild(row); } catch { }
                    try { if (cont.children.length === 0) invToggleBulkMode(false); } catch { }
                });
                cont.appendChild(row);
                try { document.querySelectorAll('.money-input').forEach(el => attachMoneyFormatter(el)); } catch { }
            };

            modal.classList.add('show');
        }

        window.invHandleProductSelection = function () {
            const select = document.getElementById('invProductSelect');
            const newFields = document.getElementById('invNewProductFields');
            if (select && newFields) {
                if (select.value === 'new') {
                    newFields.style.display = 'block';
                    document.getElementById('invNewProductName').value = '';
                    document.getElementById('invNewProductCategory').value = '';
                    document.getElementById('invNewCategoryName').value = '';
                    document.getElementById('invNewProductCost').value = '';
                    document.getElementById('invNewProductPrice').value = '';
                    document.getElementById('invNewProductStock').value = '0';
                    document.getElementById('invNewCategoryField').style.display = 'none';
                    const hasStockEl = document.getElementById('invNewProductHasStock');
                    const stockGroup = document.getElementById('invNewProductStockGroup');
                    if (hasStockEl && stockGroup) { hasStockEl.checked = true; stockGroup.style.display = 'block'; }
                } else {
                    newFields.style.display = 'none';
                }
            }
        };
        window.invHandleCategorySelection = function () {
            const select = document.getElementById('invNewProductCategory');
            const newCategoryField = document.getElementById('invNewCategoryField');
            if (select && newCategoryField) {
                newCategoryField.style.display = (select.value === 'new') ? 'block' : 'none';
                if (select.value !== 'new') document.getElementById('invNewCategoryName').value = '';
            }
        };
        window.invToggleNewProductHasStock = function () {
            const hasStockEl = document.getElementById('invNewProductHasStock');
            const stockGroup = document.getElementById('invNewProductStockGroup');
            if (hasStockEl && stockGroup) stockGroup.style.display = hasStockEl.checked ? 'block' : 'none';
        };
        window.invSaveNewProductFromInventory = async function () {
            const nameRaw = document.getElementById('invNewProductName').value.trim();
            const name = capitalizeFirstWordValue(nameRaw);
            let categorySelect = document.getElementById('invNewProductCategory').value;
            if (typeof categorySelect === 'string') categorySelect = categorySelect.trim();
            const newCategoryNameRaw = document.getElementById('invNewCategoryName').value.trim();
            const newCategoryName = capitalizeFirstWordValue(newCategoryNameRaw);
            const cost = parseMoney(document.getElementById('invNewProductCost').value);
            const price = parseMoney(document.getElementById('invNewProductPrice').value);
            const hasStock = document.getElementById('invNewProductHasStock')?.checked !== false;
            const stock = hasStock ? (parseMoney(document.getElementById('invNewProductStock').value) || 0) : 0;

            if (!name) return showToast('Please enter product name', 'error');
            let category;
            if (categorySelect === 'new') {
                if (!newCategoryName) return showToast('Please enter category name', 'error');
                if (!state.categories.includes(newCategoryName)) state.categories.push(newCategoryName);
                category = newCategoryName;
            } else {
                if (!categorySelect) return showToast('Please select or create a category', 'error');
                category = capitalizeFirstWordValue(categorySelect);
            }
            if (isNaN(cost) || cost < 0) return showToast('Please enter a valid cost', 'error');
            if (isNaN(price) || price < 0) return showToast('Please enter a valid price', 'error');
            if (price < cost && !confirm('Warning: Selling price is less than cost. Continue?')) return;
            if (state.products.some(p => p.name.toLowerCase() === name.toLowerCase())) return showToast('Product already exists', 'error');

            const product = { id: generateID('products'), name, category, cost, price, hasStock: hasStock ? true : false };
            state.products.push(product);
            state.inventory = state.inventory || {};
            if (hasStock) state.inventory[name] = { stock, minAlert: 5 };
            saveData();

            if (syncEnabled) {
                await upsertOne('products', { name, category, cost, price, has_stock: hasStock ? true : false });
                if (hasStock) await upsertOne('inventory', { product_name: name, stock: stock, min_alert: 5 });
                if (category) await upsertOne('categories', { name: category });
                syncInBackground();
            }

            const select = document.getElementById('invProductSelect');
            if (select) {
                // rebuild options minimally
                select.insertAdjacentHTML('afterbegin', `<option value="${name}">${name}</option>`);
                select.value = name;
            }
            showToast(' Product added!', 'success');
            const newFields = document.getElementById('invNewProductFields');
            if (newFields) newFields.style.display = 'none';
        };
        window.invCancelNewProduct = function () {
            const newFields = document.getElementById('invNewProductFields');
            const select = document.getElementById('invProductSelect');
            if (newFields) newFields.style.display = 'none';
            if (select) select.value = '';
        };

        function closeInventoryModal() {
            const modal = document.getElementById('inventoryModal');
            if (modal) modal.classList.remove('show');
        }

        function ensurePeriodCreated(purchaseDate, time, titleHint) {
            state.inventoryPurchaseCycles = state.inventoryPurchaseCycles || [];
            const nextNumber = (state.inventoryPurchaseCycles.length || 0) + 1;
            const title = titleHint || (new Date(purchaseDate).toLocaleString('en-GB', { month: 'long', year: 'numeric' }) + ' Period');
            const cycle = {
                id: generateID('invCycle'),
                number: nextNumber,
                title,
                startDate: purchaseDate,
                endDate: '',
                notes: ''
            };
            state.inventoryPurchaseCycles.push(cycle);
            // Persist new period immediately when online
            if (syncEnabled && currentUser) {
                upsertOne('inventory_purchase_periods', {
                    period_number: nextNumber,
                    title,
                    start_date: purchaseDate,
                    end_date: '',
                    notes: ''
                });
            }
            return nextNumber;
        }

        async function addInventoryRecord() {
            playTapSound();
            hapticShort();
            const productName = (document.getElementById('invProductSelect')?.value || '').trim();
            const quantity = parseMoney(document.getElementById('invQuantity')?.value || '0');
            const unitCost = parseMoney(document.getElementById('invUnitCost')?.value || '0');
            const discount = parseMoney(document.getElementById('invDiscount')?.value || '0');
            const totalCost = parseMoney(document.getElementById('invTotalCost')?.value || '0');
            const supplierName = (document.getElementById('invSupplierName')?.value || '').trim();
            const supplierPhone = (document.getElementById('invSupplierPhone')?.value || '').trim();
            const supplierAddress = (document.getElementById('invSupplierAddress')?.value || '').trim();
            const purchaseDate = document.getElementById('invDate')?.value || getTodayDateString();
            const time = document.getElementById('invTime')?.value || new Date().toISOString().slice(11, 16);
            const notes = (document.getElementById('invNotes')?.value || '').trim();
            const createNew = !!(document.getElementById('invCreateNewPeriod')?.checked);
            const selectedPeriod = document.getElementById('invPeriodSelect')?.value || '';
            const newPeriodTitle = (document.getElementById('invNewPeriodTitle')?.value || '').trim();
            const bulkMode = !!(document.getElementById('invBulkMode')?.checked);

            if (!bulkMode) {
                if (!productName) return showToast('Select a product', 'error');
                if (!quantity || quantity <= 0) return showToast('Enter a valid quantity', 'error');
                if (isNaN(unitCost) || unitCost <= 0) return showToast('Enter unit cost', 'error');
                if (discount < 0) return showToast('Discount cannot be negative', 'error');
            }

            // Determine Period number: only create when no selection and createNew toggled
            let cycleNumber = selectedPeriod ? parseInt(selectedPeriod, 10) : null;
            if (!cycleNumber && createNew) {
                cycleNumber = ensurePeriodCreated(purchaseDate, time, newPeriodTitle);
            }

            // If using existing Period and a new title is provided, update the Period locally and in cloud
            if (cycleNumber && !createNew && newPeriodTitle) {
                const existing = (state.inventoryPurchaseCycles || []).find(c => c.number === cycleNumber);
                if (existing) existing.title = newPeriodTitle;
                if (syncEnabled && currentUser) {
                    await upsertOne('inventory_purchase_periods', {
                        period_number: cycleNumber,
                        title: newPeriodTitle
                    });
                }
            }

            const nowTs = Date.now();
            const todayStr = getTodayDateString();
            const isPlanned = new Date(purchaseDate).getTime() > new Date(todayStr).getTime();
            let totalExpenseAmount = 0;
            let expenseDescription = '';

            state.inventoryPurchases = state.inventoryPurchases || [];
            const createdRecords = [];

            if (bulkMode) {
                const rows = Array.from(document.querySelectorAll('.inv-bulk-row'));
                if (rows.length === 0) return showToast('Add at least one product row', 'error');
                rows.forEach((row, idx) => {
                    const name = (row.querySelector('.inv-bulk-name')?.value || '').trim();
                    const q = parseMoney(row.querySelector('.inv-bulk-qty')?.value || '0');
                    const u = parseMoney(row.querySelector('.inv-bulk-unit')?.value || '0');
                    const d = parseMoney(row.querySelector('.inv-bulk-disc')?.value || '0');
                    if (!name || q <= 0 || u <= 0) return;
                    const rec = {
                        id: generateID('invPurchase'),
                        cycleNumber,
                        itemName: name,
                        quantity: q,
                        unitCost: u,
                        discount: d,
                        totalCost: Math.max(0, (q * u) - d),
                        supplierName,
                        supplierPhone,
                        supplierAddress,
                        purchaseDate,
                        time,
                        notes: notes,
                        timestamp: nowTs + idx,
                        planned: isPlanned,
                        activated: !isPlanned
                    };
                    state.inventoryPurchases.push(rec);
                    createdRecords.push(rec);
                    if (!isPlanned) updateProductStock(name, q);
                    totalExpenseAmount += rec.totalCost;
                });
                expenseDescription = `Inventory(Bulk): ${rows.length} items`;
            } else {
                const record = {
                    id: generateID('invPurchase'),
                    cycleNumber,
                    itemName: productName,
                    quantity,
                    unitCost,
                    discount,
                    totalCost: (isNaN(totalCost) || totalCost === 0) ? Math.max(0, (quantity * unitCost) - discount) : totalCost,
                    supplierName,
                    supplierPhone,
                    supplierAddress,
                    purchaseDate,
                    time,
                    notes: notes ? `${notes}${discount ? ' | Discount: ' + formatMoney(discount) + ' Tsh' : ''} ` : (discount ? `Discount: ${formatMoney(discount)} Tsh` : ''),
                    timestamp: nowTs,
                    planned: isPlanned,
                    activated: !isPlanned
                };
                state.inventoryPurchases.push(record);
                createdRecords.push(record);
                if (!isPlanned) updateProductStock(productName, quantity);
                totalExpenseAmount = record.totalCost;
                expenseDescription = `Inventory: ${productName}  ${quantity} `;
            }

            if (isPlanned) { showToast('Planned purchase saved', 'success'); }

            // Record as an expense (office money usage)
            const expenseTs = nowTs;
            // Upsert period-level expense (summary)
            const periodComment = `Period ${cycleNumber} `;
            const existingIdx = (state.expenses || []).findIndex(e => e.category === 'Inventory Purchase' && e.comment === periodComment);
            if (existingIdx !== -1) {
                state.expenses[existingIdx].amount = (state.expenses[existingIdx].amount || 0) + (totalExpenseAmount || 0);
                try {
                    const e = state.expenses[existingIdx];
                    await upsertOne('expenses', {
                        date: e.date,
                        time: e.time,
                        timestamp: e.timestamp,
                        description: e.description,
                        category: e.category,
                        amount: e.amount,
                        payment: e.payment,
                        comment: e.comment
                    });
                } catch { }
            } else {
                const expense = {
                    id: generateID('expenses'),
                    date: purchaseDate,
                    time,
                    timestamp: expenseTs,
                    description: `Inventory Period ${cycleNumber} `,
                    category: 'Inventory Purchase',
                    amount: totalExpenseAmount,
                    payment: 'cash',
                    comment: periodComment
                };
                state.expenses.push(expense);
                try {
                    await upsertOne('expenses', {
                        date: expense.date,
                        time: expense.time,
                        timestamp: expense.timestamp,
                        description: expense.description,
                        category: expense.category,
                        amount: expense.amount,
                        payment: expense.payment,
                        comment: expense.comment
                    });
                } catch { }
            }

            saveData();
            closeInventoryModal();
            render();
            showToast('Inventory purchase saved', 'success');
            if (syncEnabled) {
                for (const r of createdRecords) {
                    await upsertOne('inventory_purchases', {
                        period_number: r.cycleNumber,
                        item_name: r.itemName,
                        quantity: r.quantity,
                        unit_cost: r.unitCost,
                        total_cost: r.totalCost,
                        purchase_date: r.purchaseDate,
                        supplier_name: r.supplierName,
                        supplier_phone: r.supplierPhone,
                        supplier_address: r.supplierAddress,
                        notes: r.notes,
                        timestamp: r.timestamp
                    });
                }
                // Upsert related expense
                await upsertOne('expenses', {
                    date: expense.date,
                    time: expense.time,
                    timestamp: expense.timestamp,
                    description: expense.description,
                    category: expense.category,
                    amount: expense.amount,
                    payment: expense.payment,
                    comment: expense.comment
                });
                // Upsert inventory stock snapshot
                for (const r of createdRecords) {
                    const inv = state.inventory[r.itemName] || { stock: 0, minAlert: 5 };
                    await upsertOne('inventory', { product_name: r.itemName, stock: inv.stock || 0, min_alert: inv.minAlert || 5 });
                }
                syncInBackground();
            }
        }

        function updateProductStock(productName, quantity) {
            if (!productName || !quantity) return;
            state.inventory = state.inventory || {};
            const inv = state.inventory[productName] || { stock: 0, minAlert: 5 };
            inv.stock = (parseInt(inv.stock || 0, 10) + parseInt(quantity || 0, 10));
            state.inventory[productName] = inv;
        }

        function generateInventoryReport(format = 'csv') {
            const purchases = state.inventoryPurchases || [];
            const cycles = state.inventoryPurchaseCycles || [];
            if (format === 'csv') {
                const headers = ['Product', 'Quantity', 'UnitCost', 'TotalCost', 'Supplier', 'Phone', 'Address', 'Period', 'Date', 'Time'];
                const rows = purchases.map(p => [
                    p.itemName,
                    p.quantity || 0,
                    (p.unitCost || p.buyingPrice || 0),
                    (p.totalCost || p.buyingPrice || 0),
                    p.supplierName || '',
                    p.supplierPhone || p.supplierContact || '',
                    p.supplierAddress || '',
                    p.cycleNumber,
                    p.purchaseDate || '',
                    p.time || ''
                ]);
                const csv = [headers.join(','), ...rows.map(r => r.map(v => String(v).replace(/\n/g, ' ').replace(/,/g, ';')).join(','))].join('\n');
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Inventory_Report_${getTodayDateString()}.csv`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                showToast('CSV report downloaded', 'success');
            } else {
                downloadInventoryPurchasesReportPDF();
            }
        }

        // Inventory PDF generators
        async function downloadInventoryPurchasesReportPDF() {
            await ensureLogoReady();
            try {
                const { jsPDF } = window.jspdf || {};
                if (!jsPDF) {
                    console.error('jsPDF not loaded');
                    showToast('PDF library not loaded', 'error');
                    return;
                }
                const doc = new jsPDF({ unit: 'pt', format: 'a4' });
                const pageWidth = doc.internal.pageSize.getWidth();
                const margin = 50;
                const usableWidth = pageWidth - margin * 2;
                let y = 120;
                const centerX = pageWidth / 2;

                // Header (match Financial Report)
                doc.setFillColor(240, 240, 240);
                doc.rect(0, 0, pageWidth, 100, 'F');
                doc.setTextColor(0, 0, 0);
                doc.setFontSize(24);
                doc.setFont(undefined, 'bold');
                const profile = (typeof getUserProfileData === 'function') ? getUserProfileData() : (state.userProfile || { businessName: 'TUBA', address: '', phone: '', email: '' });
                const drewInvTermHdr = drawLogo(doc, centerX - 18, 20, 36, { borderRadius: 18 });
                doc.text(profile.businessName || 'TUBA', centerX, 45, { align: 'center' });
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.text(`${profile.address || ''} | ${profile.phone || ''} | ${profile.email || ''} `, centerX, 70, { align: 'center' });
                doc.setDrawColor(102, 126, 234);
                doc.setLineWidth(3);
                doc.line(margin, 85, pageWidth - margin, 85);

                // Title
                doc.setTextColor(0, 0, 0);
                doc.setFontSize(18);
                doc.setFont(undefined, 'bold');
                doc.text('Inventory Purchases Report', margin, y);
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.setTextColor(100, 100, 100);
                doc.text(`Generated: ${getTodayDateString()} `, margin, y + 20);
                y += 50;

                const cycles = state.inventoryPurchaseCycles || [];
                const purchases = state.inventoryPurchases || [];

                const drawTable = (headers, rows, startY) => {
                    const colCount = headers.length;
                    const colWidth = usableWidth / colCount;
                    let curY = startY;
                    const headerH = 20;

                    doc.setFillColor(102, 126, 234);
                    doc.roundedRect(margin, curY, usableWidth, headerH, 3, 3, 'F');
                    doc.setTextColor(255, 255, 255);
                    doc.setFont(undefined, 'bold');
                    doc.setFontSize(10);
                    for (let i = 0; i < colCount; i++) {
                        const txtX = margin + i * colWidth + 8;
                        doc.text(String(headers[i]), txtX, curY + 14);
                    }
                    curY += headerH + 2;

                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(9);
                    for (let r = 0; r < rows.length; r++) {
                        let maxLines = 1;
                        const cellLines = [];
                        for (let c = 0; c < colCount; c++) {
                            const txt = rows[r][c] === null || rows[r][c] === undefined ? '' : String(rows[r][c]);
                            const lines = doc.splitTextToSize(txt, colWidth - 16);
                            cellLines.push(lines);
                            if (lines.length > maxLines) maxLines = lines.length;
                        }
                        const lineH = 10;
                        const rowH = maxLines * lineH + 8;

                        if (curY + rowH > 750) {
                            doc.addPage();
                            curY = margin;
                        }

                        if (r % 2 === 0) {
                            doc.setFillColor(248, 249, 250);
                            doc.roundedRect(margin, curY, usableWidth, rowH, 2, 2, 'F');
                        }

                        doc.setTextColor(40, 40, 40);
                        for (let c = 0; c < colCount; c++) {
                            const txtX = margin + c * colWidth + 8;
                            const lines = cellLines[c];
                            for (let li = 0; li < lines.length; li++) {
                                doc.text(lines[li], txtX, curY + 14 + li * lineH);
                            }
                        }
                        curY += rowH;
                    }
                    return curY + 20;
                };

                if (cycles.length === 0) {
                    doc.setFontSize(12);
                    doc.setFont(undefined, 'normal');
                    doc.text('No Periods found.', margin, y);
                } else {
                    cycles.forEach(cycle => {
                        const cps = purchases.filter(p => p.cycleNumber === cycle.number);
                        const cycleTotal = cps.reduce((sum, p) => sum + (Number(p.totalCost) || Number(p.buyingPrice) || 0), 0);
                        if (y > 650) { doc.addPage(); y = margin; }
                        doc.setFontSize(14);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(0, 0, 0);
                        doc.text(`Period ${cycle.number} ${cycle.title ? ' ' + cycle.title : ''} `, margin, y);
                        doc.setFontSize(10);
                        doc.setFont(undefined, 'normal');
                        doc.setTextColor(100, 100, 100);
                        doc.text(`Items: ${cps.length} | Spent: ${formatNumber(cycleTotal)} Tsh`, margin, y + 16);
                        y += 36;

                        const headers = ['Date', 'Time', 'Item', 'Qty', 'Unit', 'Total', 'Supplier', 'Phone'];
                        const rows = cps.map(p => [
                            p.purchaseDate || '',
                            p.time || '',
                            p.itemName,
                            String(p.quantity || 1),
                            formatNumber(p.unitCost || p.buyingPrice || 0),
                            formatNumber(p.totalCost || p.buyingPrice || 0),
                            p.supplierName || '',
                            p.supplierPhone || p.supplierContact || ''
                        ]);
                        y = drawTable(headers, rows, y);
                    });
                }

                // Footer
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFillColor(240, 240, 240);
                    doc.rect(0, 792 - 30, pageWidth, 30, 'F');
                    doc.setTextColor(100, 100, 100);
                    doc.setFontSize(9);
                    doc.text(`Page ${i} of ${pageCount} `, margin, 792 - 11);
                    doc.text(`The Ultimate Business Architecture(TUBA)  ${new Date().getFullYear()} `, pageWidth - margin, 792 - 8, { align: 'right' });
                }

                downloadPDFSafe(doc, `Inventory_Purchases_${getTodayDateString()}.pdf`);
                showToast('Inventory report PDF ready', 'success');
            } catch (e) {
                console.error('Inventory PDF error:', e);
                showToast('Failed to generate PDF', 'error');
            }
        }

        async function downloadInventoryCyclePDF(cycleNumber) {
            await ensureLogoReady();
            try {
                const { jsPDF } = window.jspdf || {};
                if (!jsPDF) {
                    console.error('jsPDF not loaded');
                    showToast('PDF library not loaded', 'error');
                    return;
                }
                const doc = new jsPDF({ unit: 'pt', format: 'a4' });
                const pageWidth = doc.internal.pageSize.getWidth();
                const margin = 50;
                const usableWidth = pageWidth - margin * 2;
                let y = 120;

                // Header (match Financial Report)
                doc.setFillColor(240, 240, 240);
                doc.rect(0, 0, pageWidth, 100, 'F');
                doc.setTextColor(0, 0, 0);
                doc.setFontSize(24);
                doc.setFont(undefined, 'bold');
                const profile = (typeof getUserProfileData === 'function') ? getUserProfileData() : (state.userProfile || { businessName: 'TUBA', address: '', phone: '', email: '' });
                const logo = getLogoForPdf();
                if (logo) { try { doc.addImage(logo.dataUrl, logo.format, centerX - 18, 20, 36, 36); } catch (e) { } }
                doc.text(profile.businessName || 'TUBA', centerX, 45, { align: 'center' });
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.text(`${profile.address || ''} | ${profile.phone || ''} | ${profile.email || ''} `, centerX, 70, { align: 'center' });
                doc.setDrawColor(102, 126, 234);
                doc.setLineWidth(3);
                doc.line(margin, 85, pageWidth - margin, 85);

                const cycle = (state.inventoryPurchaseCycles || []).find(c => c.number === cycleNumber);
                const cps = (state.inventoryPurchases || []).filter(p => p.cycleNumber === cycleNumber);
                const cycleTotal = cps.reduce((sum, p) => sum + (Number(p.totalCost) || Number(p.buyingPrice) || 0), 0);

                // Title
                doc.setTextColor(0, 0, 0);
                doc.setFontSize(18);
                doc.setFont(undefined, 'bold');
                doc.text(`Inventory Period ${cycleNumber} ${cycle?.title ? ' ' + cycle.title : ''} `, margin, y);
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.setTextColor(100, 100, 100);
                doc.text(`Items: ${cps.length} | Spent: ${formatNumber(cycleTotal)} Tsh`, margin, y + 20);
                y += 50;

                const headers = ['Date', 'Time', 'Item', 'Qty', 'Unit', 'Total', 'Supplier', 'Phone'];
                const rows = cps.map(p => [
                    p.purchaseDate || '',
                    p.time || '',
                    p.itemName,
                    String(p.quantity || 1),
                    formatNumber(p.unitCost || p.buyingPrice || 0),
                    formatNumber(p.totalCost || p.buyingPrice || 0),
                    p.supplierName || '',
                    p.supplierPhone || p.supplierContact || ''
                ]);

                const colCount = headers.length;
                const colWidth = usableWidth / colCount;
                let curY = y;
                const headerH = 20;
                doc.setFillColor(102, 126, 234);
                doc.roundedRect(margin, curY, usableWidth, headerH, 3, 3, 'F');
                doc.setTextColor(255, 255, 255);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                for (let i = 0; i < colCount; i++) {
                    const txtX = margin + i * colWidth + 8;
                    doc.text(String(headers[i]), txtX, curY + 14);
                }
                curY += headerH + 2;
                doc.setFont(undefined, 'normal');
                doc.setFontSize(9);
                for (let r = 0; r < rows.length; r++) {
                    let maxLines = 1;
                    const cellLines = [];
                    for (let c = 0; c < colCount; c++) {
                        const txt = rows[r][c] === null || rows[r][c] === undefined ? '' : String(rows[r][c]);
                        const lines = doc.splitTextToSize(txt, colWidth - 16);
                        cellLines.push(lines);
                        if (lines.length > maxLines) maxLines = lines.length;
                    }
                    const lineH = 10;
                    const rowH = maxLines * lineH + 8;
                    if (curY + rowH > 750) { doc.addPage(); curY = margin; }
                    if (r % 2 === 0) { doc.setFillColor(248, 249, 250); doc.roundedRect(margin, curY, usableWidth, rowH, 2, 2, 'F'); }
                    doc.setTextColor(40, 40, 40);
                    for (let c = 0; c < colCount; c++) {
                        const txtX = margin + c * colWidth + 8;
                        const lines = cellLines[c];
                        for (let li = 0; li < lines.length; li++) {
                            doc.text(lines[li], txtX, curY + 14 + li * lineH);
                        }
                    }
                    curY += rowH;
                }

                // Footer
                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFillColor(240, 240, 240);
                    doc.rect(0, 792 - 30, pageWidth, 30, 'F');
                    doc.setTextColor(100, 100, 100);
                    doc.setFontSize(9);
                    doc.text(`Page ${i} of ${pageCount} `, margin, 792 - 11);
                    doc.text(`The Ultimate Business Architecture(TUBA)  ${new Date().getFullYear()} `, pageWidth - margin, 792 - 8, { align: 'right' });
                }

                downloadPDFSafe(doc, `Inventory_Period_${cycleNumber}.pdf`);
                showToast('Period report PDF ready', 'success');
            } catch (e) {
                console.error('Period PDF error:', e);
                showToast('Failed to generate Period PDF', 'error');
            }
        }

        async function downloadInventoryStockSheetPDF() {
            await ensureLogoReady();
            try {
                const { jsPDF } = window.jspdf || {};
                if (!jsPDF) {
                    showToast('PDF library not loaded', 'error');
                    return;
                }
                const doc = new jsPDF({ unit: 'pt', format: 'a4' });
                const pageWidth = doc.internal.pageSize.getWidth();
                const centerX = pageWidth / 2;
                const margin = 50;
                const usableWidth = pageWidth - margin * 2;
                let y = 120;

                doc.setFillColor(240, 240, 240);
                doc.rect(0, 0, pageWidth, 100, 'F');
                doc.setTextColor(0, 0, 0);
                doc.setFontSize(24);
                doc.setFont(undefined, 'bold');
                const profile = (typeof getUserProfileData === 'function') ? getUserProfileData() : (state.userProfile || { businessName: 'TUBA', address: '', phone: '', email: '' });
                const logo = getLogoForPdf();
                if (logo) { try { doc.addImage(logo.dataUrl, logo.format, centerX - 18, 20, 36, 36); } catch { } }
                doc.text(profile.businessName || 'TUBA', centerX, 45, { align: 'center' });
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.text(`${profile.address || ''} | ${profile.phone || ''} | ${profile.email || ''} `, centerX, 70, { align: 'center' });
                doc.setDrawColor(102, 126, 234);
                doc.setLineWidth(3);
                doc.line(margin, 85, pageWidth - margin, 85);

                doc.setTextColor(0, 0, 0);
                doc.setFontSize(18);
                doc.setFont(undefined, 'bold');
                doc.text('Inventory Stock Sheet', margin, y);
                doc.setFontSize(10);
                doc.setFont(undefined, 'normal');
                doc.setTextColor(100, 100, 100);
                doc.text(`Generated: ${getTodayDateString()} `, margin, y + 20);
                y += 50;

                const headers = ['Product', 'Cost', 'S/P', 'QTY', 'Discount', 'Total'];
                const productW = Math.round(usableWidth * 0.20);
                const unitW = Math.round(usableWidth * 0.18);
                const costW = unitW;
                const spW = unitW;
                const qtyW = 60;
                const totalW = unitW;
                const discW = usableWidth - (productW + costW + spW + qtyW + totalW);
                const cols = [productW, costW, spW, qtyW, discW, totalW];

                const drawHeader = () => {
                    doc.setFillColor(102, 126, 234);
                    doc.roundedRect(margin, y, usableWidth, 20, 3, 3, 'F');
                    doc.setTextColor(255, 255, 255);
                    doc.setFont(undefined, 'bold');
                    doc.setFontSize(10);
                    let hx = margin;
                    for (let i = 0; i < headers.length; i++) {
                        doc.text(String(headers[i]), hx + 8, y + 14);
                        hx += cols[i];
                    }
                    y += 22;
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(9);
                    doc.setTextColor(40, 40, 40);
                };

                drawHeader();

                const products = (state.products || []).filter(p => p.hasStock !== false);
                const { TextField } = jsPDF.AcroForm || {};
                let rowIndex = 0;
                for (let idx = 0; idx < products.length; idx++) {
                    const p = products[idx];
                    const nameLines = doc.splitTextToSize(String(p.name || ''), cols[0] - 16);
                    const rowH = Math.max(nameLines.length * 12 + 10, 34);
                    if (y + rowH > 750) {
                        doc.addPage();
                        y = margin;
                        drawHeader();
                    }
                    if (rowIndex % 2 === 0) { doc.setFillColor(248, 249, 250); doc.roundedRect(margin, y, usableWidth, rowH, 2, 2, 'F'); }
                    let x = margin;
                    for (let li = 0; li < nameLines.length; li++) { doc.text(nameLines[li], x + 8, y + 14 + li * 10); }
                    x += cols[0];
                    doc.setDrawColor(0, 0, 0);
                    doc.setLineWidth(1);
                    doc.roundedRect(x + 4, y + 4, cols[1] - 8, rowH - 8, 4, 4);
                    if (TextField) {
                        const costField = new TextField();
                        costField.fieldName = `cost_${rowIndex}`;
                        costField.showWhenPrinted = true;
                        costField.fontSize = 12;
                        costField.Rect = [x + 6, y + 6, cols[1] - 12, rowH - 12];
                        doc.addField(costField);
                    }
                    x += cols[1];
                    doc.setDrawColor(0, 0, 0);
                    doc.setLineWidth(1);
                    doc.roundedRect(x + 4, y + 4, cols[2] - 8, rowH - 8, 4, 4);
                    if (TextField) {
                        const spField = new TextField();
                        spField.fieldName = `sp_${rowIndex}`;
                        spField.showWhenPrinted = true;
                        spField.fontSize = 12;
                        spField.Rect = [x + 6, y + 6, cols[2] - 12, rowH - 12];
                        doc.addField(spField);
                    }
                    x += cols[2];
                    doc.setDrawColor(0, 0, 0);
                    doc.setLineWidth(1);
                    doc.roundedRect(x + 4, y + 4, cols[3] - 8, rowH - 8, 4, 4);
                    if (TextField) {
                        const qtyField = new TextField();
                        qtyField.fieldName = `qty_${rowIndex}`;
                        qtyField.showWhenPrinted = true;
                        qtyField.fontSize = 12;
                        qtyField.Rect = [x + 6, y + 6, cols[3] - 12, rowH - 12];
                        doc.addField(qtyField);
                    }
                    x += cols[3];
                    doc.setDrawColor(0, 0, 0);
                    doc.setLineWidth(1);
                    doc.roundedRect(x + 4, y + 4, cols[4] - 8, rowH - 8, 4, 4);
                    if (TextField) {
                        const discField = new TextField();
                        discField.fieldName = `disc_${rowIndex}`;
                        discField.showWhenPrinted = true;
                        discField.fontSize = 12;
                        discField.Rect = [x + 6, y + 6, cols[4] - 12, rowH - 12];
                        doc.addField(discField);
                    }
                    x += cols[4];
                    doc.setDrawColor(0, 0, 0);
                    doc.setLineWidth(1);
                    doc.roundedRect(x + 4, y + 4, cols[5] - 8, rowH - 8, 4, 4);
                    if (TextField) {
                        const totalField = new TextField();
                        totalField.fieldName = `total_${rowIndex}`;
                        totalField.showWhenPrinted = true;
                        totalField.fontSize = 12;
                        totalField.Rect = [x + 6, y + 6, cols[5] - 12, rowH - 12];
                        doc.addField(totalField);
                    }
                    y += rowH;
                    rowIndex++;
                }

                const footerH = 30;
                if (y + footerH > 760) { doc.addPage(); y = margin; drawHeader(); }
                let fx = margin;
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                doc.text('Grand Totals', fx + 8, y + 16);
                fx += cols[0];
                doc.setFont(undefined, 'normal');
                doc.text('-', fx + 8, y + 16); // Cost
                fx += cols[1];
                doc.text('-', fx + 8, y + 16); // S/P
                fx += cols[2];
                doc.text('-', fx + 8, y + 16); // QTY
                fx += cols[3];
                fx += cols[4];
                doc.setDrawColor(0, 0, 0);
                doc.setLineWidth(1);
                doc.roundedRect(fx + 4, y + 4, cols[5] - 8, footerH - 8, 4, 4);
                const { TextField: TF2 } = jsPDF.AcroForm || {};
                if (TF2) {
                    const grand = new TF2();
                    grand.fieldName = 'grand_total';
                    grand.showWhenPrinted = true;
                    grand.fontSize = 12;
                    grand.Rect = [fx + 6, y + 6, cols[5] - 12, footerH - 12];
                    doc.addField(grand);
                }
                y += footerH;

                if (y + 80 > 760) { doc.addPage(); y = margin; }
                doc.setFont(undefined, 'bold');
                doc.setFontSize(12);
                doc.text('Verification', centerX, y + 10, { align: 'center' });
                doc.setFontSize(9);
                doc.setFont(undefined, 'normal');
                doc.text('Prepared by: _________________________   Date: __________ ', centerX, y + 30, { align: 'center' });
                doc.text('Checked by:  _________________________   Date: __________ ', centerX, y + 50, { align: 'center' });

                const pageCount = doc.internal.getNumberOfPages();
                for (let i = 1; i <= pageCount; i++) {
                    doc.setPage(i);
                    doc.setFillColor(240, 240, 240);
                    doc.rect(0, 792 - 30, pageWidth, 30, 'F');
                    doc.setTextColor(100, 100, 100);
                    doc.setFontSize(9);
                    doc.text(`Page ${i} of ${pageCount} `, margin, 792 - 11);
                    doc.text(`The Ultimate Business Architecture(TUBA)  ${new Date().getFullYear()} `, pageWidth - margin, 792 - 8, { align: 'right' });
                }

                downloadPDFSafe(doc, `Inventory_Stocksheet_${getTodayDateString()}.pdf`);
                showToast('Stocksheet PDF ready', 'success');
            } catch (e) {
                console.error('Stocksheet PDF error:', e);
                showToast('Failed to generate stocksheet PDF', 'error');
            }
        }

        async function adjustStock(productName, amount) {
            if (!state.inventory[productName]) {
                state.inventory[productName] = { stock: 0, minAlert: 5 };
            }
            state.inventory[productName].stock = Math.max(0, state.inventory[productName].stock + amount);
            saveData();
            render();
            showToast(`Stock ${amount > 0 ? 'increased' : 'decreased'} `, 'success');
            if (syncEnabled) {
                const inv = state.inventory[productName] || { stock: 0, minAlert: 5 };
                await upsertOne('inventory', { product_name: productName, stock: inv.stock || 0, min_alert: inv.minAlert || 5 });
                syncInBackground();
            }
        }

        async function deleteInventoryByPeriod(productName) {
            const periods = Array.from(new Set((state.inventoryPurchases || [])
                .filter(p => p.itemName === productName)
                .map(p => p.cycleNumber))).sort((a, b) => a - b);
            if (periods.length === 0) { showToast('No purchases found for this product', 'info'); return; }
            let sel = periods[periods.length - 1];
            if (periods.length > 1) {
                const input = prompt(`Enter Period number to delete for ${productName}(${periods.join(', ')})`);
                if (!input) return;
                const num = parseInt(input, 10);
                if (!periods.includes(num)) { showToast('Invalid Period number', 'error'); return; }
                sel = num;
            }
            const toDelete = (state.inventoryPurchases || []).filter(p => p.itemName === productName && p.cycleNumber === sel);
            if (toDelete.length === 0) { showToast('No entries in selected Period', 'info'); return; }
            const qtySum = toDelete.reduce((s, p) => s + (p.quantity || 0), 0);
            const inv = state.inventory[productName] || { stock: 0, minAlert: 5 };
            inv.stock = Math.max(0, (inv.stock || 0) - qtySum);
            state.inventory[productName] = inv;
            toDelete.forEach(p => { try { deleteOne('inventory_purchases', { timestamp: p.timestamp }); } catch { } });
            state.inventoryPurchases = (state.inventoryPurchases || []).filter(p => !(p.itemName === productName && p.cycleNumber === sel));
            saveData();
            render();
            showToast('Inventory updated', 'success');
            if (syncEnabled) {
                await upsertOne('inventory', { product_name: productName, stock: inv.stock || 0, min_alert: inv.minAlert || 5 });
                syncInBackground();
            }
        }

        async function openUpdateInventoryForProduct(productName) {
            openInventoryModal();
            setTimeout(() => {
                try {
                    invToggleBulkMode(false);
                    const prodSel = document.getElementById('invProductSelect');
                    if (prodSel) { prodSel.value = productName; invHandleProductSelection(); }
                    const last = (state.inventoryPurchases || []).filter(p => p.itemName === productName).sort((a, b) => b.timestamp - a.timestamp)[0];
                    if (last) {
                        const qtyEl = document.getElementById('invQuantity');
                        const unitEl = document.getElementById('invUnitCost');
                        const discEl = document.getElementById('invDiscount');
                        const totalEl = document.getElementById('invTotalCost');
                        const supN = document.getElementById('invSupplierName');
                        const supP = document.getElementById('invSupplierPhone');
                        const supA = document.getElementById('invSupplierAddress');
                        const notesEl = document.getElementById('invNotes');
                        const perSel = document.getElementById('invPeriodSelect');
                        const chkNew = document.getElementById('invCreateNewPeriod');
                        const perTitle = document.getElementById('invNewPeriodTitle');
                        const dateEl = document.getElementById('invDate');
                        const timeEl = document.getElementById('invTime');
                        if (qtyEl) qtyEl.value = String(last.quantity || 1);
                        if (unitEl) unitEl.value = formatMoney(last.unitCost || 0);
                        if (discEl) discEl.value = formatMoney(last.discount || 0);
                        const computedTotal = Math.max(0, (last.quantity || 0) * (last.unitCost || 0) - (last.discount || 0));
                        if (totalEl) totalEl.value = formatMoney(computedTotal);
                        if (supN) supN.value = last.supplierName || '';
                        if (supP) supP.value = last.supplierPhone || '';
                        if (supA) supA.value = last.supplierAddress || '';
                        if (notesEl) notesEl.value = last.notes || '';
                        if (dateEl) dateEl.value = last.purchaseDate || dateEl.value;
                        if (timeEl) timeEl.value = last.time || timeEl.value;
                        if (perSel) perSel.value = String(last.cycleNumber || '');
                        if (chkNew) chkNew.checked = !Boolean(last.cycleNumber);
                        const cycle = (state.inventoryPurchaseCycles || []).find(c => c.number === last.cycleNumber);
                        if (perTitle && cycle && cycle.title) perTitle.value = cycle.title;
                    }
                } catch { }
            }, 50);
        }

        async function openUpdateInventoryForPurchase(ts) {
            const p = (state.inventoryPurchases || []).find(x => x.timestamp === ts);
            if (!p) { showToast('Purchase not found', 'error'); return; }
            openInventoryModal();
            setTimeout(() => {
                try {
                    invToggleBulkMode(false);
                    const prodSel = document.getElementById('invProductSelect');
                    if (prodSel) { prodSel.value = p.itemName; invHandleProductSelection(); }
                    const qtyEl = document.getElementById('invQuantity');
                    const unitEl = document.getElementById('invUnitCost');
                    const discEl = document.getElementById('invDiscount');
                    const totalEl = document.getElementById('invTotalCost');
                    const supN = document.getElementById('invSupplierName');
                    const supP = document.getElementById('invSupplierPhone');
                    const supA = document.getElementById('invSupplierAddress');
                    const notesEl = document.getElementById('invNotes');
                    const perSel = document.getElementById('invPeriodSelect');
                    const chkNew = document.getElementById('invCreateNewPeriod');
                    const perTitle = document.getElementById('invNewPeriodTitle');
                    const dateEl = document.getElementById('invDate');
                    const timeEl = document.getElementById('invTime');
                    if (qtyEl) qtyEl.value = String(p.quantity || 1);
                    if (unitEl) unitEl.value = formatMoney(p.unitCost || p.buyingPrice || 0);
                    if (discEl) discEl.value = formatMoney(p.discount || 0);
                    const computedTotal = Math.max(0, (p.quantity || 0) * (p.unitCost || p.buyingPrice || 0) - (p.discount || 0));
                    if (totalEl) totalEl.value = formatMoney(computedTotal);
                    if (supN) supN.value = p.supplierName || '';
                    if (supP) supP.value = p.supplierPhone || '';
                    if (supA) supA.value = p.supplierAddress || '';
                    if (notesEl) notesEl.value = p.notes || '';
                    if (dateEl) dateEl.value = p.purchaseDate || dateEl.value;
                    if (timeEl) timeEl.value = p.time || timeEl.value;
                    if (perSel) perSel.value = String(p.cycleNumber || '');
                    if (chkNew) chkNew.checked = !Boolean(p.cycleNumber);
                    const cycle = (state.inventoryPurchaseCycles || []).find(c => c.number === p.cycleNumber);
                    if (perTitle && cycle && cycle.title) perTitle.value = cycle.title;
                } catch { }
            }, 50);
        }

        async function deleteInventoryPurchaseByTimestamp(ts) {
            const p = (state.inventoryPurchases || []).find(x => x.timestamp === ts);
            if (!p) { showToast('Purchase not found', 'error'); return; }
            if (p.activated) {
                const inv = state.inventory[p.itemName] || { stock: 0, minAlert: 5 };
                inv.stock = Math.max(0, (inv.stock || 0) - (p.quantity || 0));
                state.inventory[p.itemName] = inv;
            }
            try { deleteOne('inventory_purchases', { timestamp: ts }); } catch { }
            state.inventoryPurchases = (state.inventoryPurchases || []).filter(x => x.timestamp !== ts);
            // Adjust period-level expense
            try {
                const periodComment = `Period ${p.cycleNumber} `;
                const idx = (state.expenses || []).findIndex(e => e.category === 'Inventory Purchase' && e.comment === periodComment);
                if (idx !== -1) {
                    state.expenses[idx].amount = Math.max(0, (state.expenses[idx].amount || 0) - (p.totalCost || p.buyingPrice || 0));
                    if (state.expenses[idx].amount === 0) {
                        // remove the expense entirely
                        const tsExp = state.expenses[idx].timestamp;
                        try { deleteOne('expenses', { timestamp: tsExp }); } catch { }
                        state.expenses.splice(idx, 1);
                    } else {
                        // upsert adjusted expense
                        const e = state.expenses[idx];
                        await upsertOne('expenses', {
                            date: e.date,
                            time: e.time,
                            timestamp: e.timestamp,
                            description: e.description,
                            category: e.category,
                            amount: e.amount,
                            payment: e.payment,
                            comment: e.comment
                        });
                    }
                }
            } catch { }
            saveData();
            render();
            showToast('Purchase deleted', 'success');
            if (syncEnabled) {
                const inv = state.inventory[p.itemName] || { stock: 0, minAlert: 5 };
                await upsertOne('inventory', { product_name: p.itemName, stock: inv.stock || 0, min_alert: inv.minAlert || 5 });
                syncInBackground();
            }
        }

        async function saveStockFor(productName) {
            const el = document.getElementById('inv_input_' + encodeURIComponent(productName));
            if (!el) return showToast("Input not found", "error");
            const v = parseInt(el.value);
            if (isNaN(v) || v < 0) return showToast("Invalid value", "error");
            if (!state.inventory) state.inventory = {};
            state.inventory[productName] = state.inventory[productName] || { stock: 0, minAlert: 5 };
            state.inventory[productName].stock = v;

            saveData();
            render();
            showToast("Stock updated", "success");

            // Sync inventory snapshot to cloud
            if (syncEnabled) {
                const inv = state.inventory[productName] || { stock: 0, minAlert: 5 };
                await upsertOne('inventory', { product_name: productName, stock: inv.stock || 0, min_alert: inv.minAlert || 5 });
                syncInBackground();
            }
        }

        function setMinAlert(productName) {
            const current = state.inventory[productName]?.minAlert || 5;
            const newValue = prompt(`Set minimum stock alert for ${productName}: `, current);
            if (newValue !== null) {
                const val = parseInt(newValue);
                if (!isNaN(val) && val >= 0) {
                    if (!state.inventory[productName]) {
                        state.inventory[productName] = { stock: 0, minAlert: 5 };
                    }
                    state.inventory[productName].minAlert = val;
                    saveData();
                    render();
                    showToast('Min alert updated', 'success');

                    // Sync in background
                    if (syncEnabled) syncInBackground();
                } else {
                    showToast('Invalid value', 'error');
                }
            }
        }

        function renderCustomers() {
            const q = state.customerSearch || '';
            // Sort customers by total purchases
            const sortedCustomers = [...state.customers].sort((a, b) =>
                (b.totalPurchases || 0) - (a.totalPurchases || 0)
            );

            return `
                <div class="card">
                    <h2>Add Customer</h2>
                    <form onsubmit="addCustomer(event)">
                        <div class="form-group">
                            <label>Name</label>
                            <input type="text" id="customerName" placeholder="Full name" required>
                        </div>
                        <div class="form-group">
                            <label>Email</label>
                            <input type="email" id="customerEmail" placeholder="email@example.com">
                        </div>
                        <div class="form-group">
                            <label>Phone</label>
                            <input type="tel" id="customerPhone" placeholder="+255...">
                        </div>
                        <div class="form-group">
                            <label>Address</label>
                            <input type="text" id="customerAddress" placeholder="Address">
                        </div>
                        <button type="submit">Add Customer</button>
                    </form>
                    </div>

                <div class="card">
                    <h2>All Customers (${state.customers.length})</h2>
                    <div class="search-box">
                        <input type="text" placeholder=" Search customers..." oninput="searchCustomers(this.value)" id="customerSearch" value="${q}">
                    </div>

                    ${state.customers.length > 0 ? `
        <div class="bulk-actions">
            <input type="checkbox" id="selectAll_customers" onchange="toggleSelectAll('customers')" class="checkbox-select">
            <label for="selectAll_customers">Select All</label>
            <span style="color: #666; font-size: 12px; margin-left: 8px;">
                ${getSelectedCount('customers')} selected
            </span>
            <button class="btn-small btn-danger" onclick="bulkDelete('customers')" ${!hasSelected('customers') ? 'disabled' : ''}>
                 Delete Selected
            </button>
        </div>
    ` : ''}

                    <div id="customersList">${renderCustomersList(q)}</div>
                    ${(() => { const total = (state.customers || []).filter(c => !q || c.name.toLowerCase().includes(q.toLowerCase()) || (c.email && c.email.toLowerCase().includes(q.toLowerCase())) || (c.phone && c.phone.includes(q))).length; const count = (state.listShowCount && state.listShowCount.customers) ? state.listShowCount.customers : 3; const hasMore = count < total; return `<button class=\"collapse-btn\" onclick=\"${hasMore ? `showMoreList('customers')` : `collapseList('customers')`}\"><span class=\"collapse-icon ${hasMore ? '' : 'expanded'}\"></span><span>${hasMore ? 'See more' : 'Hide'}</span></button>`; })()}
                </div>
            `;
        }

        function renderCustomersList(searchPeriod = '') {
            let customers = state.customers;
            if (searchPeriod) {
                const Period = searchPeriod.toLowerCase();
                customers = customers.filter(c =>
                    c.name.toLowerCase().includes(Period) ||
                    (c.email && c.email.toLowerCase().includes(Period)) ||
                    (c.phone && c.phone.includes(Period))
                );
            }

            if (customers.length === 0) {
                return '<p style="text-align: center; color: #666;">No customers found</p>';
            }
            return customers.map((c, i) => {
                const actualIndex = state.customers.indexOf(c);
                const purchaseCount = state.sales.filter(s => s.customer === c.name).length;
                return `
                <div class="item">
                    <div style="display: flex; gap: 12px; align-items: start;">
                        <input type="checkbox" class="checkbox-select"
                            ${state.selectedItems.customers && state.selectedItems.customers[c.id] ? 'checked' : ''}
                            onchange="toggleSelect('customers', '${c.id}')">
                            <div style="flex: 1;">
                                <div class="item-title">${c.name}</div>
                                <div class="item-subtitle">
                                    ${c.email ? ' ' + c.email + '<br>' : ''}
                                    ${c.phone ? ' ' + c.phone + '<br>' : ''}
                                    ${c.address ? ' ' + c.address + '<br>' : ''}
                                    <div style="color: #2e7d32; font-weight: 600; margin-top: 4px;">
                                         Total Purchases:  ${formatNumber(c.totalPurchases || 0)} Tsh<br>
                                             ${purchaseCount} transactions
                                    </div>
                                </div>
                                <div class="flex-gap" style="margin-top:8px;">
                                    <button class="btn-small" onclick="viewCustomerHistory(${actualIndex})">History</button>
                                    <button class="btn-small" onclick="editCustomerIndex(${actualIndex})">Edit</button>
                                    <button class="btn-small btn-danger" onclick="deleteCustomerIndex(${actualIndex})">Delete</button>
                                </div>
                            </div>
                    </div>
        </div >
                `;
            }).join('');
        }

        function searchCustomers(Period) {
            state.customerSearch = Period;
            document.getElementById('customersList').innerHTML = renderCustomersList(Period);
        }

        function viewCustomerHistory(i) {
            const customer = state.customers[i];
            if (!customer) return showToast("Customer not found", "error");

            const sales = state.sales.filter(s => s.customer === customer.name);

            if (sales.length === 0) {
                showToast("No purchase history", "info");
                return;
            }

            let history = `${customer.name} 's Purchase History:\n\n`;
            sales.slice(-10).reverse().forEach(s => {
                history += `${s.date}: ${s.productName} - ${formatNumber(s.totalPrice)} Tsh\n`;
            });

            alert(history);
        }

        async function addCustomer(e) {
            e.preventDefault();
            const name = document.getElementById('customerName').value.trim();

            if (state.customers.some(c => c.name.toLowerCase() === name.toLowerCase())) {
                return showToast('Customer already exists', 'error');
            }

            const customer = {
                id: generateID('customers'),
                name: name,
                email: document.getElementById('customerEmail').value.trim(),
                phone: document.getElementById('customerPhone').value.trim(),
                address: document.getElementById('customerAddress').value.trim(),
                totalPurchases: 0
            };

            state.customers.push(customer);
            saveData();
            render();
            showToast("Customer added", "success");

            // Sync in background
            if (syncEnabled) syncInBackground();
        }
        function editCustomerIndex(i) {
            const c = state.customers[i];
            if (!c) return showToast("Customer not found", "error");
            const name = prompt("Name:", c.name);
            const email = prompt("Email:", c.email);
            const phone = prompt("Phone:", c.phone);
            if (name) {
                c.name = name.trim();
                if (email !== null) c.email = email.trim();
                if (phone !== null) c.phone = phone.trim();
                saveData();
                render();
                showToast("Customer updated", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            }
        }

        function deleteCustomerIndex(i) {
            showConfirm("Delete this customer?", async function () {
                try { playDeleteSound(); } catch (e) { }
                const c = state.customers[i];
                if (c) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('customers', { name: c.name, email: c.email || '' });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('customers', { name: c.name, email: c.email || '' });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.customers.splice(i, 1);
                saveData();
                render();
                showToast("Customer deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }

        function renderInvoices() {
            const stats = getStats();
            return `
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
        <div class="stat-card" style="padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">TOTAL INVOICED</div>
            <div class="stat-value" style="font-size: 16px;"> ${formatNumber(stats.totalInvoiced)} Tsh</div>
        </div>
        <div class="stat-card" style="background: #2e7d32; padding: 12px;">
            <div class="stat-label" style="font-size: 10px;">PAID</div>
            <div class="stat-value" style="font-size: 16px;"> ${formatNumber(stats.totalPaid)} Tsh</div>
        </div>
    </div>

    <!-- Template Selection Tabs -->
    <div class="card">
        <h2> Create Document</h2>
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 16px;">
            <button class="transaction-tab ${state.activeInvoiceTab === 'invoice' ? 'mpesa active' : 'mpesa'}" 
                    style="opacity: ${state.activeInvoiceTab === 'invoice' ? '1' : '0.6'};"
                    onclick="switchInvoiceTab('invoice')">
                 Invoice
            </button>
            <button class="transaction-tab ${state.activeInvoiceTab === 'receipt' ? 'crdb active' : 'crdb'}" 
                    style="opacity: ${state.activeInvoiceTab === 'receipt' ? '1' : '0.6'};"
                    onclick="switchInvoiceTab('receipt')">
                 Receipt
            </button>
        </div>

        ${state.activeInvoiceTab === 'invoice' ? `
            <!-- Invoice Creation Form -->
            <form onsubmit="createInvoice(event)">
                <div class="form-group">
                    <label>Customer</label>
                    <select id="invoiceCustomer" onchange="toggleInvoiceCustomerInput()" required>
                        <option value="" selected>-- Walk-in --</option>
                        ${state.customers
                        .map((c, i) => ({ c, i }))
                        .sort((a, b) => String(a.c.name).localeCompare(String(b.c.name)))
                        .map(({ c, i }) => `<option value="${i}">${c.name}</option>`).join('')}
                        <option value="new">+ Add New Customer</option>
                    </select>
                </div>
                <div id="newInvoiceCustomerFields" style="display:none;">
                    <div class="form-group">
                        <label>New Customer Name</label>
                        <input type="text" id="newInvoiceCustomerName" placeholder="Enter customer name">
                    </div>
                    <div class="form-group">
                        <label>Phone (Optional)</label>
                        <input type="tel" id="newInvoiceCustomerPhone" placeholder="+255...">
                    </div>
                    <div class="form-group">
                        <label>Email (Optional)</label>
                        <input type="email" id="newInvoiceCustomerEmail" placeholder="customer@email.com">
                    </div>
                </div>
                <div class="form-group">
                    <label>Due Date</label>
                    <input type="date" id="invoiceDueDate" required>
                </div>
                <div class="form-group">
                    <label>Payment Periods</label>
                    <input type="text" id="invoicePeriods" placeholder="Due within 7 days" value="Due within 7 days">
                </div>
                <div class="form-group">
    <label>Items/Services</label>
    <div id="invoiceItemsList">
        <div class="invoice-item-row" style="display: flex; gap: 8px; margin-bottom: 8px;">
            <input type="text" class="item-description" placeholder="Item description" style="flex: 2;" required>
            <input type="text" class="item-amount money-input" placeholder="0" style="flex: 1;" required>
            <button type="button" class="btn-small btn-danger" onclick="removeInvoiceItem(this)" style="width: auto; padding: 8px 12px;"></button>
        </div>
    </div>
    <button type="button" class="btn-secondary" onclick="addInvoiceItem()" style="margin-top: 8px;">+ Add Item</button>
</div>
<div class="form-group">
    <label>Subtotal (Auto-calculated)</label>
    <input type="text" id="invoiceSubtotal" readonly value="0 Tsh" style="background: rgba(0,0,0,0.05);">
</div>
                <div class="form-group">
                    <label>Tax Rate (%)</label>
                    <input type="number" id="invoiceTaxRate" placeholder="0" step="0.01" value="0" min="0" max="100">
                </div>
                <div class="form-group">
                    <label>Payment Method</label>
                    <input type="text" id="invoicePaymentMethod" placeholder="Bank Transfer / Mobile Money" value="Bank Transfer / Mobile Money">
                </div>
                <div class="form-group">
                    <label>Notes (Optional)</label>
                    <textarea id="invoiceNotes" placeholder="Thank you for your business..."></textarea>
                </div>
                <button type="submit">Create Invoice</button>
            </form>
        ` : `
            <!-- Receipt Creation Form -->
<form onsubmit="createReceipt(event)">
    <div class="form-group">
        <label>Received From</label>
        <select id="receiptCustomer" onchange="updateReceiptFromCustomer()" required>
            <option value="" selected>-- Walk-in --</option>
            ${state.customers
                    .map((c, i) => ({ c, i }))
                    .sort((a, b) => String(a.c.name).localeCompare(String(b.c.name)))
                    .map(({ c, i }) => `<option value="${i}">${c.name}</option>`).join('')}
            <option value="manual"> Enter Manually</option>
        </select>
    </div>
    <div id="manualReceiptCustomerField" style="display:none;">
        <div class="form-group">
            <label>Customer Name</label>
            <input type="text" id="manualReceiptCustomerName" placeholder="Enter customer name">
        </div>
        <div class="form-group">
            <label>Customer Email (Optional)</label>
            <input type="email" id="manualReceiptCustomerEmail" placeholder="customer@email.com">
        </div>
    </div>
    <div class="form-group" id="invoiceSelectionGroup" style="display:none;">
        <label>Related Invoice (Optional)</label>
        <select id="receiptInvoice" onchange="updateReceiptFromInvoice()">
            <option value="">-- No Invoice --</option>
        </select>
    </div>
    <div class="form-group">
        <label>Description</label>
        <textarea id="receiptDescription" placeholder="Payment for services rendered" required></textarea>
    </div>
                <div class="form-group">
                    <label>Amount Paid</label>
                    <input type="text" id="receiptAmount" class="money-input" placeholder="0" required>
                </div>
                <div class="form-group">
                    <label>Payment Method</label>
                    <select id="receiptPaymentMethod">
                        <option>Cash</option>
                        <option>M-Pesa</option>
                        <option>Bank Transfer</option>
                        <option>Card</option>
                        <option>Airtel Money</option>
                        <option>Halopesa</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Reference Number (Optional)</label>
                    <input type="text" id="receiptReference" placeholder="REF123XYZ">
                </div>
                <button type="submit">Create Receipt</button>
            </form>
        `}
    </div>

    <!-- Unpaid Invoices -->
    <div class="card">
        <h2>Unpaid Invoices (${state.invoices.filter(i => i.status !== 'Paid').length})</h2>
        
        ${state.invoices.filter(i => i.status !== 'Paid').length > 0 ? `
            <div class="bulk-actions">
                <input type="checkbox" id="selectAll_unpaid_invoices" onchange="toggleSelectAllUnpaidInvoices()" class="checkbox-select">
                <label for="selectAll_unpaid_invoices">Select All</label>
                <span style="color: #666; font-size: 12px; margin-left: 8px;">
                    ${getSelectedUnpaidInvoiceCount()} selected
                </span>
                <button class="btn-small btn-success" onclick="bulkMarkInvoicesPaid()" ${!hasSelectedUnpaidInvoices() ? 'disabled' : ''}>
                     Mark as Paid
                </button>
                <button class="btn-small btn-danger" onclick="bulkDeleteUnpaidInvoices()" ${!hasSelectedUnpaidInvoices() ? 'disabled' : ''}>
                     Delete Selected
                </button>
            </div>
            
            ${state.invoices.filter(i => i.status !== 'Paid').map((inv, origIdx) => {
                        const actualIndex = state.invoices.findIndex(i => i === inv);
                        return `
                <div class="item">
                    <div style="display: flex; gap: 12px; align-items: start;">
                        <input type="checkbox" class="checkbox-select" 
                               ${state.selectedItems.unpaid_invoices && state.selectedItems.unpaid_invoices[actualIndex] ? 'checked' : ''}
                               onchange="toggleSelectUnpaidInvoice(${actualIndex})">
                        <div style="flex: 1;">
                            <div class="item-header">
                                <span class="item-title">${inv.number}</span>
                                <span class="badge ${inv.status === 'Overdue' ? 'badge-danger' : 'badge-warning'}">
                                    ${inv.status}
                                </span>
                            </div>
                            <div class="item-subtitle">
                                ${inv.customer}<br>
                                Due: ${inv.dueDate}<br>
                                <span style="font-weight: 700; color: #000;">Amount:  ${formatNumber(inv.amount)} Tsh</span>
                            </div>
                            <div class="flex-gap" style="margin-top:8px;">
                                <button class="btn-small" onclick="downloadInvoicePDF(${actualIndex})"> Invoice PDF</button>
                                <button class="btn-small" onclick="toggleInvoiceStatus(${actualIndex})">Change Status</button>
                                <button class="btn-small btn-danger" onclick="deleteInvoice(${actualIndex})">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
                    }).join('')}
        ` : '<p style="text-align: center; color: #666;">No unpaid invoices</p>'}
    </div>

    <!-- Paid Invoices -->
    <div class="card">
        <h2>Paid Invoices (${state.invoices.filter(i => i.status === 'Paid').length})</h2>
        
        ${state.invoices.filter(i => i.status === 'Paid').length > 0 ? `
            <div class="bulk-actions">
                <input type="checkbox" id="selectAll_paid_invoices" onchange="toggleSelectAllPaidInvoices()" class="checkbox-select">
                <label for="selectAll_paid_invoices">Select All</label>
                <span style="color: #666; font-size: 12px; margin-left: 8px;">
                    ${getSelectedPaidInvoiceCount()} selected
                </span>
                <button class="btn-small btn-danger" onclick="bulkDeletePaidInvoices()" ${!hasSelectedPaidInvoices() ? 'disabled' : ''}>
                     Delete Selected
                </button>
            </div>
            
            ${state.invoices.filter(i => i.status === 'Paid').map((inv, origIdx) => {
                        const actualIndex = state.invoices.findIndex(i => i === inv);
                        return `
                <div class="item">
                    <div style="display: flex; gap: 12px; align-items: start;">
                        <input type="checkbox" class="checkbox-select" 
                               ${state.selectedItems.paid_invoices && state.selectedItems.paid_invoices[actualIndex] ? 'checked' : ''}
                               onchange="toggleSelectPaidInvoice(${actualIndex})">
                        <div style="flex: 1;">
                            <div class="item-header">
                                <span class="item-title"> ${inv.number}</span>
                                <span class="badge badge-success">Paid</span>
                            </div>
                            <div class="item-subtitle">
                                ${inv.customer}<br>
                                Paid: ${inv.date}<br>
                                <span style="font-weight: 700; color: #000;">Amount:  ${formatNumber(inv.amount)} Tsh</span>
                            </div>
                            <div class="flex-gap" style="margin-top:8px;">
                                <button class="btn-small" onclick="downloadInvoicePDF(${actualIndex})"> Invoice PDF</button>
                                <button class="btn-small btn-danger" onclick="deleteInvoice(${actualIndex})">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
                    }).join('')}
        ` : '<p style="text-align: center; color: #666;">No paid invoices</p>'}
    </div>

    <!-- Receipts -->
    <div class="card">
        <h2>Receipts (${(state.receipts || []).length})</h2>
        
        ${(state.receipts && state.receipts.length > 0) ? `
            <div class="bulk-actions">
                <input type="checkbox" id="selectAll_receipts" onchange="toggleSelectAllReceipts()" class="checkbox-select">
                <label for="selectAll_receipts">Select All</label>
                <span style="color: #666; font-size: 12px; margin-left: 8px;">
                    ${getSelectedReceiptCount()} selected
                </span>
                <button class="btn-small btn-danger" onclick="bulkDeleteReceipts()" ${!hasSelectedReceipts() ? 'disabled' : ''}>
                     Delete Selected
                </button>
            </div>
            
            ${(state.receipts || []).map((receipt, idx) => `
                <div class="item">
                    <div style="display: flex; gap: 12px; align-items: start;">
                        <input type="checkbox" class="checkbox-select" 
                               ${state.selectedItems.receipts && state.selectedItems.receipts[idx] ? 'checked' : ''}
                               onchange="toggleSelectReceipt(${idx})">
                        <div style="flex: 1;">
                            <div class="item-header">
                                <span class="item-title"> ${receipt.number}</span>
                                <span class="badge badge-success">Receipt</span>
                            </div>
                            <div class="item-subtitle">
                                ${receipt.customer}<br>
                                Date: ${receipt.date} ${receipt.time}<br>
                                <span style="font-weight: 700; color: #000;">Amount:  ${formatNumber(receipt.amount)} Tsh</span>
                                ${receipt.linkedInvoice ? `<br>Linked to: ${receipt.linkedInvoice}` : ''}
                            </div>
                            <div class="flex-gap" style="margin-top:8px;">
                                <button class="btn-small" onclick="downloadReceiptPDF(${idx})"> Receipt PDF</button>
                                <button class="btn-small btn-danger" onclick="deleteReceipt(${idx})">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('')}
        ` : '<p style="text-align: center; color: #666;">No receipts yet</p>'}
    </div>
    `;
        }

        function toggleSelectAllUnpaidInvoices() {
            if (!state.selectedItems.unpaid_invoices) state.selectedItems.unpaid_invoices = {};

            const unpaidInvoices = state.invoices.filter(i => i.status !== 'Paid');

            // Check if all unpaid invoices are currently selected
            const allSelected = unpaidInvoices.every((inv) => {
                const idx = state.invoices.indexOf(inv);
                return state.selectedItems.unpaid_invoices[idx];
            });

            // Toggle: if all selected, unselect all; otherwise, select all
            const newState = !allSelected;

            unpaidInvoices.forEach(inv => {
                const idx = state.invoices.indexOf(inv);
                state.selectedItems.unpaid_invoices[idx] = newState;
            });

            saveData();
            render(); // RE-RENDER TO SHOW CHECKED ITEMS
        }

        function toggleSelectUnpaidInvoice(index) {
            if (!state.selectedItems.unpaid_invoices) state.selectedItems.unpaid_invoices = {};
            state.selectedItems.unpaid_invoices[index] = !state.selectedItems.unpaid_invoices[index];
            saveData();
            render(); // RE-RENDER TO UPDATE CHECKBOXES AND COUNT
        }

        function hasSelectedUnpaidInvoices() {
            return state.selectedItems.unpaid_invoices && Object.values(state.selectedItems.unpaid_invoices).some(v => v);
        }

        function getSelectedUnpaidInvoiceCount() {
            if (!state.selectedItems.unpaid_invoices) return 0;
            return Object.values(state.selectedItems.unpaid_invoices).filter(v => v).length;
        }

        function bulkMarkInvoicesPaid() {
            const selected = Object.keys(state.selectedItems.unpaid_invoices || {})
                .filter(i => state.selectedItems.unpaid_invoices[i])
                .map(i => parseInt(i));

            if (selected.length === 0) return showToast('No invoices selected', 'info');

            showConfirm(`Mark ${selected.length} invoices as paid?`, async function () {
                selected.forEach(i => {
                    if (state.invoices[i]) {
                        state.invoices[i].status = 'Paid';
                    }
                });

                state.selectedItems.unpaid_invoices = {};
                saveData();
                render();
                showToast(`${selected.length} invoices marked as paid`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        function bulkDeleteUnpaidInvoices() {
            const selected = Object.keys(state.selectedItems.unpaid_invoices || {})
                .filter(i => state.selectedItems.unpaid_invoices[i])
                .map(i => parseInt(i));

            if (selected.length === 0) return showToast('No invoices selected', 'info');

            showConfirm(`Delete ${selected.length} selected invoices?`, async function () {
                try { playDeleteSound(); } catch (e) { }
                selected.sort((a, b) => b - a).forEach(i => {
                    const inv = state.invoices[i];
                    if (syncEnabled && inv) { try { deleteOne('invoices', { number: inv.number }); } catch { } }
                    state.invoices.splice(i, 1);
                });

                state.selectedItems.unpaid_invoices = {};
                saveData();
                render();
                showToast(`${selected.length} invoices deleted`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        function toggleSelectAllPaidInvoices() {
            if (!state.selectedItems.paid_invoices) state.selectedItems.paid_invoices = {};

            const paidInvoices = state.invoices.filter(i => i.status === 'Paid');

            // Check if all paid invoices are currently selected
            const allSelected = paidInvoices.every((inv) => {
                const idx = state.invoices.indexOf(inv);
                return state.selectedItems.paid_invoices[idx];
            });

            // Toggle: if all selected, unselect all; otherwise, select all
            const newState = !allSelected;

            paidInvoices.forEach(inv => {
                const idx = state.invoices.indexOf(inv);
                state.selectedItems.paid_invoices[idx] = newState;
            });

            saveData();
            render(); // RE-RENDER TO SHOW CHECKED ITEMS
        }

        function toggleSelectPaidInvoice(index) {
            if (!state.selectedItems.paid_invoices) state.selectedItems.paid_invoices = {};
            state.selectedItems.paid_invoices[index] = !state.selectedItems.paid_invoices[index];
            saveData();
            render(); // RE-RENDER TO UPDATE CHECKBOXES AND COUNT
        }

        function hasSelectedPaidInvoices() {
            return state.selectedItems.paid_invoices && Object.values(state.selectedItems.paid_invoices).some(v => v);
        }

        function getSelectedPaidInvoiceCount() {
            if (!state.selectedItems.paid_invoices) return 0;
            return Object.values(state.selectedItems.paid_invoices).filter(v => v).length;
        }

        function bulkDeletePaidInvoices() {
            const selected = Object.keys(state.selectedItems.paid_invoices || {})
                .filter(i => state.selectedItems.paid_invoices[i])
                .map(i => parseInt(i));

            if (selected.length === 0) return showToast('No invoices selected', 'info');

            showConfirm(`Delete ${selected.length} selected invoices?`, async function () {
                try { playDeleteSound(); } catch (e) { }
                selected.sort((a, b) => b - a).forEach(i => {
                    const inv = state.invoices[i];
                    if (syncEnabled && inv) { try { deleteOne('invoices', { number: inv.number }); } catch { } }
                    state.invoices.splice(i, 1);
                });

                state.selectedItems.paid_invoices = {};
                saveData();
                render();
                showToast(`${selected.length} invoices deleted`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        function deleteInvoice(index) {
            showConfirm("Delete this invoice?", async function () {
                try { playDeleteSound(); } catch (e) { }
                const inv = state.invoices[index];
                if (inv) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('invoices', { number: inv.number });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('invoices', { number: inv.number });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.invoices.splice(index, 1);
                saveData();
                render();
                showToast("Invoice deleted", "success");

                if (syncEnabled) syncInBackground();
            });
        }

        function toggleInvoiceCustomerInput() {
            const select = document.getElementById('invoiceCustomer');
            const fields = document.getElementById('newInvoiceCustomerFields');
            if (select && fields) {
                if (select.value === 'new') {
                    fields.style.display = 'block';
                } else {
                    fields.style.display = 'none';
                }
            }
        }

        function switchInvoiceTab(tab) {
            state.activeInvoiceTab = tab;
            saveData();
            render();
        }

        function toggleReceiptCustomerInput() {
            const select = document.getElementById('receiptCustomer');
            const fields = document.getElementById('newReceiptCustomerFields');
            if (select && fields) {
                if (select.value === 'new') {
                    fields.style.display = 'block';
                } else {
                    fields.style.display = 'none';
                }
            }
        }

        function addInvoiceItem() {
            const container = document.getElementById('invoiceItemsList');
            const newRow = document.createElement('div');
            newRow.className = 'invoice-item-row';
            newRow.style.cssText = 'display: flex; gap: 8px; margin-bottom: 8px;';
            newRow.innerHTML = `
        <input type="text" class="item-description" placeholder="Item description" style="flex: 2;" required>
        <input type="text" class="item-amount money-input" placeholder="0" style="flex: 1;" required oninput="calculateInvoiceSubtotal()">
        <button type="button" class="btn-small btn-danger" onclick="removeInvoiceItem(this)" style="width: auto; padding: 8px 12px;"></button>
    `;
            container.appendChild(newRow);

            // Add event listener to first input too
            const firstAmount = container.querySelector('.item-amount');
            if (firstAmount && !firstAmount.hasAttribute('oninput')) {
                firstAmount.setAttribute('oninput', 'calculateInvoiceSubtotal()');
            }
        }

        function updateReceiptFromCustomer() {
            const select = document.getElementById('receiptCustomer');
            const manualField = document.getElementById('manualReceiptCustomerField');
            const invoiceGroup = document.getElementById('invoiceSelectionGroup');
            const invoiceSelect = document.getElementById('receiptInvoice');

            if (select.value === 'manual') {
                manualField.style.display = 'block';
                invoiceGroup.style.display = 'none';
                return;
            }

            manualField.style.display = 'none';

            if (select.value === '') {
                invoiceGroup.style.display = 'none';
                return;
            }

            const customer = state.customers[select.value];
            if (!customer) return;

            // Find invoices for this customer
            const customerInvoices = state.invoices.filter(inv =>
                inv.customer === customer.name && inv.status !== 'Paid'
            );

            if (customerInvoices.length > 0) {
                invoiceGroup.style.display = 'block';
                invoiceSelect.innerHTML = '<option value="">-- No Invoice --</option>' +
                    customerInvoices.map((inv, idx) => {
                        const actualIndex = state.invoices.indexOf(inv);
                        return `<option value="${actualIndex}">${inv.number} - ${formatNumber(inv.amount)} Tsh (Due: ${inv.dueDate})</option>`;
                    }).join('');

                // Auto-select first invoice
                if (customerInvoices.length === 1) {
                    invoiceSelect.selectedIndex = 1;
                    updateReceiptFromInvoice();
                }
            } else {
                invoiceGroup.style.display = 'none';
            }
        }

        function updateReceiptFromInvoice() {
            const invoiceSelect = document.getElementById('receiptInvoice');
            const descField = document.getElementById('receiptDescription');
            const amountField = document.getElementById('receiptAmount');

            if (!invoiceSelect.value) return;

            const invoice = state.invoices[invoiceSelect.value];
            if (!invoice) return;

            // Format items properly
            let itemsDescription = '';
            if (Array.isArray(invoice.items)) {
                itemsDescription = invoice.items.map(item =>
                    `${item.description} (${formatMoney(item.amount)} Tsh)`
                ).join(', ');
            } else {
                itemsDescription = String(invoice.items);
            }

            descField.value = `Payment for ${itemsDescription} (Invoice ${invoice.number})`;
            amountField.value = formatMoney(invoice.amount);
        }

        function removeInvoiceItem(button) {
            const container = document.getElementById('invoiceItemsList');
            if (container.children.length > 1) {
                button.parentElement.remove();
                calculateInvoiceSubtotal();
            } else {
                showToast('At least one item is required', 'error');
            }
        }

        function calculateInvoiceSubtotal() {
            const amounts = document.querySelectorAll('.item-amount');
            let subtotal = 0;
            amounts.forEach(input => {
                const val = parseMoney(input.value) || 0;
                subtotal += val;
            });

            const subtotalField = document.getElementById('invoiceSubtotal');
            if (subtotalField) {
                subtotalField.value = formatMoney(subtotal) + ' Tsh';
            }

            // Update total with tax
            const taxRate = parseFloat(document.getElementById('invoiceTaxRate')?.value || 0) / 100;
            const tax = subtotal * taxRate;
            const total = subtotal + tax;

            // You can add a total display field if needed
        }

        async function createReceipt(e) {
            e.preventDefault();

            const customerSelect = document.getElementById('receiptCustomer').value;
            let customer;
            let customerName = '';
            let customerEmail = '';

            if (customerSelect === 'manual') {
                customerName = document.getElementById('manualReceiptCustomerName')?.value.trim();
                customerEmail = document.getElementById('manualReceiptCustomerEmail')?.value.trim();

                if (!customerName) return showToast('Please enter customer name', 'error');

                // Optionally add to customers list
                customer = {
                    id: generateID('customers'),
                    name: customerName,
                    email: customerEmail,
                    phone: '',
                    address: '',
                    totalPurchases: 0
                };
                // Don't auto-add manual entries to avoid clutter
                // state.customers.push(customer);
            } else if (customerSelect) {
                customer = state.customers[customerSelect];
                customerName = customer.name;
                customerEmail = customer.email || '';
            } else {
                customerName = 'WALK IN';
                customerEmail = '';
            }

            const amount = parseMoney(document.getElementById('receiptAmount').value);
            if (isNaN(amount) || amount <= 0) {
                return showToast('Please enter a valid amount', 'error');
            }

            const now = new Date();
            const paymentMethod = document.getElementById('receiptPaymentMethod').value;
            const reference = document.getElementById('receiptReference')?.value.trim();

            // Check if linked to an invoice
            const invoiceSelect = document.getElementById('receiptInvoice');
            let linkedInvoice = null;
            if (invoiceSelect && invoiceSelect.value) {
                linkedInvoice = state.invoices[invoiceSelect.value];
                // Mark invoice as paid
                if (linkedInvoice) {
                    linkedInvoice.status = 'Paid';
                    showToast('Invoice marked as paid', 'success');
                }
            }

            const receipt = {
                id: generateID('receipts'),
                number: 'RCPT-' + Date.now().toString().slice(-6),
                customer: customerName,
                customerEmail: customerEmail,
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime(),
                description: document.getElementById('receiptDescription').value.trim(),
                amount: amount,
                paymentMethod: paymentMethod + (reference ? ' (Ref: ' + reference + ')' : ''),
                linkedInvoice: linkedInvoice ? linkedInvoice.number : null
            };

            if (!state.receipts) state.receipts = [];
            state.receipts.push(receipt);

            saveData();
            render();
            showToast("Receipt created successfully!", "success");

            if (syncEnabled) syncInBackground();
        }

        async function downloadReceiptPDF(idx) {
            await ensureLogoReady();
            const receipt = state.receipts[idx];
            if (!receipt) return showToast("Receipt not found", "error");

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'pt', format: [226.77, 396.85] });
            const margin = 20;
            const centerX = 226.77 / 2;
            let y = 30;

            // Draw zigzag borders
            doc.setDrawColor(0, 0, 0);
            doc.setLineWidth(1);
            const zigzagSize = 8;
            const zigzagCount = Math.floor(226.77 / zigzagSize);

            for (let i = 0; i < zigzagCount; i++) {
                const x1 = i * zigzagSize;
                const x2 = (i + 0.5) * zigzagSize;
                const x3 = (i + 1) * zigzagSize;
                if (i % 2 === 0) {
                    doc.line(x1, 10, x2, 5);
                    doc.line(x2, 5, x3, 10);
                } else {
                    doc.line(x1, 10, x2, 15);
                    doc.line(x2, 15, x3, 10);
                }
            }

            doc.line(10, 10, 10, 396.85 - 10);
            doc.line(226.77 - 10, 10, 226.77 - 10, 396.85 - 10);

            const profile = getUserProfileData();

            // Header
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            const drewRec = drawLogo(doc, centerX - 12, y - 4, 24, { borderRadius: 12 });
            if (drewRec) { y += 26; }
            doc.text(profile.businessName, centerX, y, { align: 'center' });
            y += 18;

            doc.setFontSize(7);
            doc.setFont(undefined, 'normal');
            if (profile.address) {
                const addressLines = doc.splitTextToSize(profile.address, 186.77);
                addressLines.forEach(line => {
                    doc.text(line, centerX, y, { align: 'center' });
                    y += 10;
                });
            }
            if (profile.phone) {
                doc.text(`Tel: ${profile.phone}`, centerX, y, { align: 'center' });
                y += 10;
            }
            if (profile.email) {
                doc.text(`Email: ${profile.email}`, centerX, y, { align: 'center' });
                y += 10;
            }
            y += 8;

            doc.setLineWidth(0.5);
            doc.line(margin, y, 226.77 - margin, y);
            y += 15;

            // Receipt Title
            doc.setFontSize(12);
            doc.setFont(undefined, 'bold');
            doc.text('PAYMENT RECEIPT', centerX, y, { align: 'center' });
            y += 18;

            // Receipt Details
            doc.setFontSize(8);
            doc.setFont(undefined, 'normal');
            doc.text(`Receipt No: ${receipt.number}`, margin, y);
            y += 11;
            doc.text(`Date: ${receipt.date}`, margin, y);
            y += 11;
            doc.text(`Time: ${receipt.time}`, margin, y);
            y += 16;

            doc.line(margin, y, 226.77 - margin, y);
            y += 13;

            // Received From
            doc.setFont(undefined, 'bold');
            doc.setFontSize(7);
            doc.text('RECEIVED FROM', margin, y);
            y += 11;
            doc.setFont(undefined, 'normal');
            doc.setFontSize(9);
            doc.text(receipt.customer, margin, y);
            if (receipt.customerEmail) {
                y += 11;
                doc.setFontSize(7);
                doc.text(receipt.customerEmail, margin, y);
            }
            y += 16;

            // Description
            doc.setFont(undefined, 'bold');
            doc.setFontSize(7);
            doc.text('DESCRIPTION', margin, y);
            y += 11;
            doc.setFont(undefined, 'normal');
            doc.setFontSize(8);
            const descLines = doc.splitTextToSize(receipt.description, 186.77);
            descLines.forEach(line => {
                if (y > 320) return; // Prevent overflow
                doc.text(line, margin, y);
                y += 10;
            });
            y += 8;

            doc.line(margin, y, 226.77 - margin, y);
            y += 13;

            // Amount
            doc.setFont(undefined, 'bold');
            doc.setFontSize(7);
            doc.text('AMOUNT PAID', margin, y);
            y += 14;
            doc.setFontSize(14);
            doc.text(`${formatNumber(receipt.amount)} Tsh`, centerX, y, { align: 'center' });
            y += 16;

            doc.setFontSize(7);
            doc.setFont(undefined, 'normal');
            const paymentLines = doc.splitTextToSize(`Payment Method: ${receipt.paymentMethod}`, 186.77);
            paymentLines.forEach(line => {
                doc.text(line, centerX, y, { align: 'center' });
                y += 10;
            });
            y += 10;

            // Linked Invoice
            if (receipt.linkedInvoice) {
                doc.setFontSize(7);
                doc.text(`Related Invoice: ${receipt.linkedInvoice}`, centerX, y, { align: 'center' });
                y += 12;
            }

            doc.line(margin, y, 226.77 - margin, y);
            y += 13;

            // Footer
            doc.setFont(undefined, 'bold');
            doc.setFontSize(8);
            doc.text('The Ultimate Business Architecture - TUBA', centerX, y, { align: 'center' });
            y += 11;
            doc.setFontSize(7);
            doc.setFont(undefined, 'normal');
            doc.text(` ${new Date().getFullYear()}`, centerX, y, { align: 'center' });


            // Bottom zigzag
            const bottomY = 396.85 - 10;
            for (let i = 0; i < zigzagCount; i++) {
                const x1 = i * zigzagSize;
                const x2 = (i + 0.5) * zigzagSize;
                const x3 = (i + 1) * zigzagSize;
                if (i % 2 === 0) {
                    doc.line(x1, bottomY, x2, bottomY + 5);
                    doc.line(x2, bottomY + 5, x3, bottomY);
                } else {
                    doc.line(x1, bottomY, x2, bottomY - 5);
                    doc.line(x2, bottomY - 5, x3, bottomY);
                }
            }

            downloadPDFSafe(doc, `${receipt.number}.pdf`);
            showToast("Receipt PDF ready", "success");
        }
        function deleteReceipt(idx) {
            showConfirm("Delete this receipt?", async function () {
                try { playDeleteSound(); } catch (e) { }
                const r = state.receipts[idx];
                if (r) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('receipts', { timestamp: r.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('receipts', { timestamp: r.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.receipts.splice(idx, 1);
                saveData();
                render();
                showToast("Receipt deleted", "success");

                if (syncEnabled) syncInBackground();
            });
        }
        function toggleSelectAllReceipts() {
            if (!state.selectedItems.receipts) state.selectedItems.receipts = {};

            const receipts = state.receipts || [];

            // Check if all receipts are currently selected
            const allSelected = receipts.every((receipt, idx) => state.selectedItems.receipts[idx]);

            // Toggle: if all selected, unselect all; otherwise, select all
            const newState = !allSelected;

            receipts.forEach((receipt, idx) => {
                state.selectedItems.receipts[idx] = newState;
            });

            saveData();
            render(); // RE-RENDER TO SHOW CHECKED ITEMS
        }

        function toggleSelectReceipt(index) {
            if (!state.selectedItems.receipts) state.selectedItems.receipts = {};
            state.selectedItems.receipts[index] = !state.selectedItems.receipts[index];
            saveData();
            render(); // RE-RENDER TO UPDATE CHECKBOXES AND COUNT
        }

        function hasSelectedReceipts() {
            return state.selectedItems.receipts && Object.values(state.selectedItems.receipts).some(v => v);
        }

        function getSelectedReceiptCount() {
            if (!state.selectedItems.receipts) return 0;
            return Object.values(state.selectedItems.receipts).filter(v => v).length;
        }

        function bulkDeleteReceipts() {
            const selected = Object.keys(state.selectedItems.receipts || {})
                .filter(i => state.selectedItems.receipts[i])
                .map(i => parseInt(i));

            if (selected.length === 0) return showToast('No receipts selected', 'info');

            showConfirm(`Delete ${selected.length} selected receipts?`, async function () {
                try { playDeleteSound(); } catch (e) { }
                selected.sort((a, b) => b - a).forEach(i => {
                    const r = state.receipts[i];
                    if (syncEnabled && r) { try { deleteOne('receipts', { timestamp: r.timestamp }); } catch { } }
                    state.receipts.splice(i, 1);
                });

                state.selectedItems.receipts = {};
                saveData();
                render();
                showToast(`${selected.length} receipts deleted`, 'success');

                if (syncEnabled) syncInBackground();
            });
        }

        function toggleInvoiceStatus(idx) {
            const inv = state.invoices[idx];
            if (!inv) return;

            const statuses = ['Pending', 'Paid', 'Overdue'];
            const currentIdx = statuses.indexOf(inv.status);
            inv.status = statuses[(currentIdx + 1) % statuses.length];

            saveData();
            render();
            showToast(`Invoice status changed to ${inv.status}`, 'success');

            // Sync in background
            if (syncEnabled) syncInBackground();
        }

        async function createInvoice(e) {
            e.preventDefault();
            const customerSelect = document.getElementById('invoiceCustomer').value;
            let customer;

            if (customerSelect === 'new') {
                const newName = document.getElementById('newInvoiceCustomerName')?.value.trim();
                if (!newName) return showToast('Please enter customer name', 'error');
                const newPhone = document.getElementById('newInvoiceCustomerPhone')?.value.trim();
                const newEmail = document.getElementById('newInvoiceCustomerEmail')?.value.trim();

                // Check if customer already exists
                const existingCustomer = state.customers.find(c => c.name.toLowerCase() === newName.toLowerCase());

                if (existingCustomer) {
                    customer = existingCustomer;
                } else {
                    customer = {
                        id: generateID('customers'),
                        name: newName,
                        email: newEmail,
                        phone: newPhone,
                        address: '',
                        totalPurchases: 0
                    };
                    state.customers.push(customer);
                    showToast('New customer added to customers list', 'info');
                }
            } else if (customerSelect) {
                customer = state.customers[customerSelect];
            } else {
                customer = { name: 'WALK IN', email: '', phone: '', address: '', totalPurchases: 0 };
            }

            // Collect all items
            const itemRows = document.querySelectorAll('.invoice-item-row');
            const items = [];
            let subtotal = 0;

            itemRows.forEach(row => {
                const desc = row.querySelector('.item-description').value.trim();
                const amount = parseFloat(row.querySelector('.item-amount').value) || 0;

                if (desc && amount > 0) {
                    items.push({ description: desc, amount: amount });
                    subtotal += amount;
                }
            });

            if (items.length === 0) {
                return showToast('Please add at least one item with an amount', 'error');
            }

            const taxRate = parseFloat(document.getElementById('invoiceTaxRate')?.value || 0) / 100;
            const taxAmount = subtotal * taxRate;
            const total = subtotal + taxAmount;

            const now = new Date();
            const invoice = {
                id: generateID('invoices'),
                number: 'INV-' + Date.now().toString().slice(-6),
                customer: customer.name,
                customerEmail: customer.email || '',
                customerAddress: customer.address || '',
                customerPhone: customer.phone || '',
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime(),
                dueDate: document.getElementById('invoiceDueDate').value,
                Periods: document.getElementById('invoicePeriods')?.value.trim() || 'Due within 7 days',
                items: items,
                subtotal: subtotal,
                taxRate: taxRate * 100,
                taxAmount: taxAmount,
                amount: total,
                paymentMethod: document.getElementById('invoicePaymentMethod')?.value.trim() || 'Bank Transfer',
                notes: document.getElementById('invoiceNotes')?.value.trim() || '',
                status: 'Pending'
            };

            state.invoices.push(invoice);
            saveData();
            render();
            showToast("Invoice created successfully!", "success");
            if (syncEnabled) {
                await upsertOne('invoices', {
                    number: invoice.number,
                    customer: invoice.customer,
                    date: invoice.date,
                    due_date: invoice.dueDate,
                    items: invoice.items,
                    amount: invoice.amount,
                    status: invoice.status
                });
                syncInBackground();
            }
        }

        async function downloadInvoicePDF(i) {
            await ensureLogoReady();
            const inv = state.invoices[i];
            if (!inv) return showToast("Invoice not found", "error");

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'pt', format: 'a4' });
            const pageWidth = 595.28;
            const margin = 50;
            const usableWidth = pageWidth - margin * 2;
            let y = 50;

            const profile = getUserProfileData();

            // Header with gradient gray background
            doc.setFillColor(245, 245, 245);
            doc.rect(0, 0, pageWidth, 70, 'F');
            doc.setFillColor(230, 230, 230);
            doc.rect(0, 70, pageWidth, 70, 'F');

            // Company name + logo
            doc.setTextColor(40, 40, 40);
            doc.setFontSize(26);
            doc.setFont(undefined, 'bold');
            const drewInv = drawLogo(doc, margin, 20, 40, { borderRadius: 20 });
            const titleX = drewInv ? (margin + 58) : margin;
            doc.text(profile.businessName || 'Your Business Name', titleX, 45);

            // Company details - show all profile info
            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.setTextColor(80, 80, 80);
            let headerY = 70;

            if (profile.address) {
                doc.text(`Address: ${profile.address}`, margin, headerY);
                headerY += 14;
            }
            if (profile.phone) {
                doc.text(`Phone: ${profile.phone}`, margin, headerY);
                headerY += 14;
            }
            if (profile.email) {
                doc.text(`Email: ${profile.email}`, margin, headerY);
                headerY += 14;
            }

            // Add a subtle line separator
            doc.setDrawColor(150, 150, 150);
            doc.setLineWidth(2);
            doc.line(margin, headerY + 5, pageWidth - margin, headerY + 5);

            // Invoice details (right side)
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text('INVOICE', pageWidth - margin, 45, { align: 'right' });

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.text(`${inv.number}`, pageWidth - margin, 65, { align: 'right' });
            doc.text(`Date: ${inv.date}`, pageWidth - margin, 80, { align: 'right' });
            doc.text(`Due: ${inv.dueDate}`, pageWidth - margin, 95, { align: 'right' });

            y = 165;
            doc.setTextColor(0, 0, 0);

            // Bill To section
            doc.setFillColor(248, 248, 248);
            doc.roundedRect(margin, y, (usableWidth / 2) - 10, 100, 5, 5, 'F');

            doc.setFontSize(10);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(107, 114, 128);
            doc.text('BILL TO', margin + 15, y + 20);

            doc.setTextColor(0, 0, 0);
            doc.setFont(undefined, 'normal');
            doc.setFontSize(11);
            doc.text(inv.customer, margin + 15, y + 40);

            let billY = y + 55;
            if (inv.customerEmail) {
                doc.setFontSize(9);
                doc.setTextColor(107, 114, 128);
                doc.text(inv.customerEmail, margin + 15, billY);
                billY += 12;
            }
            if (inv.customerPhone) {
                doc.text(inv.customerPhone, margin + 15, billY);
                billY += 12;
            }
            if (inv.customerAddress) {
                doc.text(inv.customerAddress, margin + 15, billY);
            }

            // Payment Periods section
            doc.setFillColor(248, 248, 248);
            doc.roundedRect(margin + (usableWidth / 2) + 10, y, (usableWidth / 2) - 10, 80, 5, 5, 'F');

            doc.setFontSize(10);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(107, 114, 128);
            doc.text('PAYMENT PeriodS', margin + (usableWidth / 2) + 25, y + 20);

            doc.setTextColor(0, 0, 0);
            doc.setFont(undefined, 'normal');
            doc.setFontSize(10);
            doc.text(inv.Periods || 'Due within 7 days', margin + (usableWidth / 2) + 25, y + 40);

            doc.setFont(undefined, 'bold');
            doc.text('Payment Method', margin + (usableWidth / 2) + 25, y + 60);
            doc.setFont(undefined, 'normal');
            doc.text(inv.paymentMethod || 'Bank Transfer', margin + (usableWidth / 2) + 25, y + 75);

            y += 120;

            // Items table
            doc.setFillColor(100, 100, 100);
            doc.rect(margin, y, usableWidth, 25, 'F');

            doc.setTextColor(255, 255, 255);
            doc.setFont(undefined, 'bold');
            doc.setFontSize(10);
            doc.text('Item / Service', margin + 10, y + 16);
            doc.text('Amount', pageWidth - margin - 10, y + 16, { align: 'right' });

            y += 25;
            doc.setTextColor(0, 0, 0);
            doc.setFont(undefined, 'normal');
            doc.setFontSize(10);

            y += 25;
            doc.setTextColor(0, 0, 0);
            doc.setFont(undefined, 'normal');
            doc.setFontSize(10);

            // Parse items properly
            let items = [];
            if (Array.isArray(inv.items)) {
                items = inv.items;
            } else if (typeof inv.items === 'string') {
                try {
                    // Try to parse as JSON first
                    items = JSON.parse(inv.items);
                } catch (e) {
                    // If not JSON, split by comma
                    items = inv.items.split(',').map(s => ({ description: s.trim(), amount: 0 })).filter(i => i.description);
                }
            } else if (typeof inv.items === 'object') {
                items = [inv.items];
            }

            items.forEach((item, idx) => {
                if (idx % 2 === 0) {
                    doc.setFillColor(248, 249, 250);
                    doc.rect(margin, y, usableWidth, 20, 'F');
                }

                const description = item.description || String(item);
                const amount = item.amount || 0;

                const maxDescWidth = usableWidth - 20;
                const descLines = doc.splitTextToSize(description, maxDescWidth);
                for (let li = 0; li < descLines.length; li++) {
                    doc.text(descLines[li], margin + 10, y + 14 + li * 12);
                }
                if (amount > 0) {
                    doc.text(`${formatNumber(amount)} Tsh`, pageWidth - margin - 10, y + 14, { align: 'right' });
                }
                y += Math.max(20, descLines.length * 12 + 6);
            });

            y += 10;

            // Totals section
            const totalsX = pageWidth - margin - 150;

            if (inv.subtotal !== undefined) {
                doc.setDrawColor(200, 200, 200);
                doc.line(totalsX - 20, y, pageWidth - margin, y);
                y += 15;

                doc.setFont(undefined, 'normal');
                doc.text('Subtotal:', totalsX, y);
                doc.text(`${formatNumber(inv.subtotal)} Tsh`, pageWidth - margin, y, { align: 'right' });
                y += 18;

                if (inv.taxAmount && inv.taxAmount > 0) {
                    doc.text(`Tax (${inv.taxRate}%):`, totalsX, y);
                    doc.text(`${formatNumber(inv.taxAmount)} Tsh`, pageWidth - margin, y, { align: 'right' });
                    y += 18;
                }
            }

            doc.setDrawColor(100, 100, 100);
            doc.setLineWidth(2);
            doc.line(totalsX - 20, y, pageWidth - margin, y);
            y += 18;

            doc.setFont(undefined, 'bold');
            doc.setFontSize(12);
            doc.text('Total Due:', totalsX, y);
            doc.text(`${formatNumber(inv.amount)} Tsh`, pageWidth - margin, y, { align: 'right' });

            // Notes
            if (inv.notes) {
                y += 40;
                doc.setFontSize(9);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(107, 114, 128);
                doc.text('Notes:', margin, y);
                y += 12;
                doc.setFont(undefined, 'normal');
                const noteLines = doc.splitTextToSize(inv.notes, usableWidth);
                noteLines.forEach(line => {
                    doc.text(line, margin, y);
                    y += 12;
                });
            }

            // Footer
            doc.setFillColor(80, 80, 80);
            doc.rect(0, 792 - 50, pageWidth, 50, 'F');
            doc.setFontSize(11);
            doc.setTextColor(255, 255, 255);
            doc.setFont(undefined, 'bold');
            doc.text('The Ultimate Business Architecture', pageWidth / 2, 792 - 28, { align: 'center' });
            doc.setFontSize(14);
            doc.text('- TUBA -', pageWidth / 2, 792 - 12, { align: 'center' });
            downloadPDFSafe(doc, `${inv.number}.pdf`);
            showToast("Invoice PDF ready", "success");
        }

        async function downloadSaleReceiptPDF(timestamp) {
            await ensureLogoReady();
            const sale = state.sales.find(s => s.timestamp === timestamp);
            if (!sale) return showToast("Sale not found", "error");

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'pt', format: [226.77, 396.85] }); // 80mm x 140mm receipt size
            const margin = 20;
            const contentWidth = 226.77 - (margin * 2);
            let y = 30;

            // Draw zigzag top border
            doc.setDrawColor(0, 0, 0);
            doc.setLineWidth(1);
            const zigzagSize = 8;
            const zigzagCount = Math.floor(226.77 / zigzagSize);

            // Top zigzag
            for (let i = 0; i < zigzagCount; i++) {
                const x1 = i * zigzagSize;
                const x2 = (i + 0.5) * zigzagSize;
                const x3 = (i + 1) * zigzagSize;
                if (i % 2 === 0) {
                    doc.line(x1, 10, x2, 5);
                    doc.line(x2, 5, x3, 10);
                } else {
                    doc.line(x1, 10, x2, 15);
                    doc.line(x2, 15, x3, 10);
                }
            }

            // Left border
            doc.line(10, 10, 10, 396.85 - 10);

            // Right border
            doc.line(226.77 - 10, 10, 226.77 - 10, 396.85 - 10);

            // Get profile data
            const profile = getUserProfileData();

            // Header - Logo + Business Name
            doc.setFontSize(16);
            doc.setFont(undefined, 'bold');
            const centerX = 226.77 / 2;
            const drewSaleRec = drawLogo(doc, centerX - 12, y - 4, 24, { borderRadius: 12 });
            if (drewSaleRec) { y += 26; }
            doc.text(profile.businessName || 'Your Business', centerX, y, { align: 'center' });
            y += 20;

            // Business Info
            doc.setFontSize(8);
            doc.setFont(undefined, 'normal');

            if (profile.address) {
                const addressLines = doc.splitTextToSize(profile.address, 186.77);
                addressLines.forEach(line => {
                    doc.text(line, centerX, y, { align: 'center' });
                    y += 10;
                });
            }

            if (profile.phone) {
                doc.text(`Tel: ${profile.phone}`, centerX, y, { align: 'center' });
                y += 10;
            }

            if (profile.email) {
                doc.text(`Email: ${profile.email}`, centerX, y, { align: 'center' });
                y += 10;
            }

            // Separator line
            y += 8;
            doc.setLineWidth(0.5);
            doc.line(margin, y, 226.77 - margin, y);
            y += 15;

            // Receipt Title
            doc.setFontSize(12);
            doc.setFont(undefined, 'bold');
            doc.text('SALES RECEIPT', centerX, y, { align: 'center' });
            y += 18;

            // Date and Time
            doc.setFontSize(9);
            doc.setFont(undefined, 'normal');
            doc.text(`Date: ${sale.date}`, margin, y);
            y += 12;
            doc.text(`Time: ${sale.time}`, margin, y);
            y += 12;
            doc.text(`Customer: ${sale.customer}`, margin, y);
            y += 18;

            // Separator line
            doc.line(margin, y, 226.77 - margin, y);
            y += 15;

            // Item Details Header
            doc.setFontSize(8);
            doc.setFont(undefined, 'bold');
            const pageWidth = 226.77;
            const priceX = pageWidth - margin; // Right aligned at content edge
            const qtyX = priceX - 60; // Leave 60pt gap from price
            doc.text('ITEM/DESCRIPTION', margin, y);
            doc.text('QTY', qtyX, y);
            doc.text('PRICE', priceX, y, { align: 'right' });
            y += 12;

            doc.setFont(undefined, 'normal');

            // Item Details
            doc.text(sale.productName, margin, y);
            y += 12;
            doc.text(`${sale.quantity}`, qtyX, y);
            doc.text(`${formatNumber(sale.pricePerUnit)}`, priceX, y, { align: 'right' });
            y += 18;

            // Separator line
            doc.line(margin, y, 226.77 - margin, y);
            y += 15;

            // Totals
            doc.setFontSize(9);
            doc.text('Subtotal:', margin, y);
            doc.text(`${formatNumber(sale.totalPrice)} Tsh`, 160, y, { align: 'right' });
            y += 15;

            doc.setFont(undefined, 'bold');
            doc.setFontSize(11);
            doc.text('TOTAL:', margin, y);
            doc.text(`${formatNumber(sale.totalPrice)} Tsh`, 160, y, { align: 'right' });
            y += 18;

            // Payment Method
            doc.setFontSize(8);
            doc.setFont(undefined, 'normal');
            doc.text(`Payment: ${sale.payment}`, margin, y);
            y += 20;

            // Separator line
            doc.line(margin, y, 226.77 - margin, y);
            y += 15;

            // Footer
            doc.setFontSize(8);
            doc.text('Thank you for your business!', centerX, y, { align: 'center' });
            y += 12;
            doc.text('Visit us again', centerX, y, { align: 'center' });
            y += 18;

            // Transaction ID
            doc.setFontSize(7);
            doc.text(`Trans ID: ${sale.id || timestamp}`, centerX, y, { align: 'center' });

            // Bottom zigzag
            const bottomY = 396.85 - 10;
            for (let i = 0; i < zigzagCount; i++) {
                const x1 = i * zigzagSize;
                const x2 = (i + 0.5) * zigzagSize;
                const x3 = (i + 1) * zigzagSize;
                if (i % 2 === 0) {
                    doc.line(x1, bottomY, x2, bottomY + 5);
                    doc.line(x2, bottomY + 5, x3, bottomY);
                } else {
                    doc.line(x1, bottomY, x2, bottomY - 5);
                    doc.line(x2, bottomY - 5, x3, bottomY);
                }
            }

            // Save the PDF
            downloadPDFSafe(doc, `Receipt_${sale.id || timestamp}.pdf`);
            showToast("Receipt PDF ready", "success");
        }

        function renderUnpaid() {
            const unpaidList = state.unpaidEntries.filter(e => !e.paid);
            const unpaidTotal = unpaidList.reduce((sum, e) => sum + (e.amount || 0), 0);
            const unpaidSorted = unpaidList.slice().reverse();
            const unpaidShow = state.unpaidEntriesShowCount || 2;
            const unpaidVisible = unpaidSorted.slice(0, unpaidShow);
            const paidSorted = state.unpaidEntries.filter(e => e.paid).slice().reverse();
            const paidShow = state.paidEntriesShowCount || 2;
            const paidVisible = paidSorted.slice(0, paidShow);

            return `
                <div class="stat-grid">
                    <div class="stat-card">
                        <div class="stat-label">UNPAID ENTRIES</div>
                        <div class="stat-value">${unpaidList.length}</div>
                    </div>
                    <div class="stat-card" style="background: #d32f2f;">
                        <div class="stat-label">UNPAID AMOUNT</div>
                        <div class="stat-value"> ${formatNumber(unpaidTotal)} Tsh</div>
                    </div>
                </div>

                <div class="card">
                    <h2>Add Unpaid Entry</h2>
                    <form onsubmit="addUnpaidEntry(event)">
                        <div class="form-group">
                            <label>Customer</label>
                            <select id="unpaidCustomer">
                                <option value="" selected>-- Walk-in --</option>
                                ${state.customers
                    .map((c, i) => ({ c, i }))
                    .sort((a, b) => String(a.c.name).localeCompare(String(b.c.name)))
                    .map(({ c, i }) => `<option value="${i}">${c.name}</option>`).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label>OR Enter Customer Name</label>
                            <input type="text" id="unpaidName" placeholder="Enter name manually">
                        </div>
                        <div class="form-group">
                            <label>Product</label>
                            <select id="unpaidProduct" onchange="updateUnpaidAmount()">
                                <option value="">-- Select Product --</option>
                                ${state.products.map((p, i) => `<option value="${i}">${p.name} -  ${formatNumber(p.price)} Tsh</option>`).join('')}
                            </select>
                        </div>
                        <div class="form-group">
                            <label>OR Transaction Type</label>
                            <input type="text" id="unpaidType" placeholder="e.g., Product Sale">
                        </div>
                        <div class="form-group">
                            <label>Amount</label>
                            <input type="text" id="unpaidAmount" class="money-input" placeholder="0" required>
                        </div>
                        <button type="submit">Add Unpaid Entry</button>
                    </form>
                </div>

                <div class="card" id="unpaidEntriesCard">
                    <h2>Unpaid Entries (${unpaidList.length})</h2>
                    
                    <div class="bulk-actions">
                        <input type="checkbox" id="selectAll_unpaidEntries" onchange="toggleSelectAll('unpaidEntries')" class="checkbox-select">
                        <label for="selectAll_unpaidEntries">Select All</label>
                        <span style="color: #666; font-size: 12px; margin-left: 8px;">
                            ${getSelectedCount('unpaidEntries')} selected
                        </span>
                        <button class="btn-small btn-success" onclick="bulkMarkPaid()" ${!hasSelected('unpaidEntries') ? 'disabled' : ''}>
                             Mark Selected as Paid
                        </button>
                        <button class="btn-small btn-danger" onclick="bulkDelete('unpaidEntries')" ${!hasSelected('unpaidEntries') ? 'disabled' : ''}>
                             Delete Selected
                        </button>
                    </div>

                    ${unpaidVisible.map((entry, idx) => `
                        <div class="item" style="border-left: 4px solid #d32f2f;">
                            <div style="display: flex; gap: 12px; align-items: start;">
                                <input type="checkbox" class="checkbox-select" 
                                       ${state.selectedItems.unpaidEntries && state.selectedItems.unpaidEntries[entry.id] ? 'checked' : ''}
                                       onchange="toggleSelect('unpaidEntries', '${entry.id}')">
                                <div style="flex: 1;">
                                    <div class="item-header">
                                        <span class="item-title">${entry.name}</span>
                                        <span class="badge badge-unpaid">UNPAID</span>
                                    </div>
                                    <div class="item-subtitle">
                                        ${entry.date} ${entry.time}<br>
                                        Type: ${entry.type}<br>
                                        Amount: <strong style="color: #d32f2f;"> ${formatNumber(entry.amount)} Tsh</strong>
                                    </div>
                                    <div class="flex-gap" style="margin-top:8px;">
                                        <button class="btn-success btn-small" onclick="markAsPaid(${entry.timestamp})"> Mark Paid</button>
                                        <button class="btn-small btn-danger" onclick="deleteUnpaidEntry(${entry.timestamp})">Delete</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `).join('') || '<p style="text-align: center; color: #666;">No unpaid entries</p>'}
                    ${unpaidSorted.length > unpaidShow ? `<div style="display:flex;justify-content:center;margin-top:8px;"><button class="btn-small" onclick="showMoreUnpaidEntries()">Show more</button></div>` : ''}
                </div>

                <div class="card" id="paidEntriesCard">
                    <h2>Paid Entries (${paidSorted.length})</h2>
                    ${paidVisible.map(entry => `
                        <div class="item">
                            <div class="item-header">
                                <span class="item-title">${entry.name}</span>
                                <span class="badge badge-paid"> PAID</span>
                            </div>
                            <div class="item-subtitle">
                                ${entry.date} ${entry.time}<br>
                                Type: ${entry.type}<br>
                                Amount:  ${formatNumber(entry.amount)} Tsh
                            </div>
                        </div>
                    `).join('') || '<p style="text-align: center; color: #666;">No paid entries yet</p>'}
                    ${paidSorted.length > paidShow ? `<div style="display:flex;justify-content:center;margin-top:8px;"><button class="btn-small" onclick="showMorePaidEntries()">Show more</button></div>` : ''}
                </div>
            `;
        }

        function showMoreUnpaidEntries() {
            const total = state.unpaidEntries.filter(e => !e.paid).length;
            const current = state.unpaidEntriesShowCount || 2;
            state.unpaidEntriesShowCount = Math.min(total, current + 3);
            saveData();
            render();
        }

        function showMorePaidEntries() {
            const total = state.unpaidEntries.filter(e => e.paid).length;
            const current = state.paidEntriesShowCount || 2;
            state.paidEntriesShowCount = Math.min(total, current + 3);
            saveData();
            render();
        }

        function updateUnpaidAmount() {
            const productIndex = document.getElementById('unpaidProduct')?.value;
            if (productIndex !== null && productIndex !== '') {
                const product = state.products[productIndex];
                if (product) {
                    document.getElementById('unpaidAmount').value = formatMoney(product.price);
                }
            }
        }

        async function addUnpaidEntry(e) {
            e.preventDefault();
            const now = new Date();
            state.unpaidEntries = state.unpaidEntries || [];

            const customerIndex = document.getElementById('unpaidCustomer')?.value;
            const manualName = document.getElementById('unpaidName')?.value.trim();
            let customerName = manualName;
            if (!customerName && customerIndex) {
                customerName = state.customers[customerIndex].name;
            }
            if (!customerName) {
                customerName = 'WALK IN';
            }

            const productIndex = document.getElementById('unpaidProduct')?.value;
            const manualType = document.getElementById('unpaidType')?.value.trim();
            let transactionType = manualType;
            if (!transactionType && productIndex !== null && productIndex !== '') {
                transactionType = state.products[productIndex].name;
            }
            if (!transactionType) {
                return showToast("Please select product or enter transaction type", "error");
            }

            const amount = parseMoney(document.getElementById('unpaidAmount').value);
            if (isNaN(amount) || amount <= 0) {
                return showToast("Please enter a valid amount", "error");
            }

            const entry = {
                name: customerName,
                type: transactionType,
                amount: amount,
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime(),
                paid: false
            };

            state.unpaidEntries.push(entry);
            saveData();
            render();
            showToast("Unpaid entry added", "success");

            // Sync in background
            if (syncEnabled) syncInBackground();
        }

        async function markAsPaid(timestamp) {
            const entry = state.unpaidEntries.find(e => e.timestamp === timestamp);
            if (!entry) return showToast("Entry not found", "error");

            entry.paid = true;
            const now = new Date();
            state.sales.push({
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime(),
                productName: entry.type,
                customer: entry.name,
                quantity: 1,
                costPerUnit: 0,
                pricePerUnit: entry.amount,
                totalCost: 0,
                totalPrice: entry.amount,
                profit: entry.amount,
                payment: 'Unpaid Entry - Now Paid'
            });

            // Update customer total
            const customer = state.customers.find(c => c.name === entry.name);
            if (customer) {
                customer.totalPurchases = (customer.totalPurchases || 0) + entry.amount;
            }

            saveData();
            render();
            showToast("Marked as paid and added to sales", "success");

            // Sync in background
            if (syncEnabled) syncInBackground();
        }

        function deleteUnpaidEntry(timestamp) {
            showConfirm("Delete this unpaid entry?", function () {
                try { playDeleteSound(); } catch (e) { }
                const idx = state.unpaidEntries.findIndex(e => e.timestamp === timestamp);
                if (idx !== -1) {
                    const entry = state.unpaidEntries[idx];
                    if (entry) {
                        (async () => {
                            try {
                                if (navigator.onLine && syncEnabled && currentUser) {
                                    await deleteOne('unpaid_entries', { timestamp: entry.timestamp });
                                    showToast('Deleted from cloud', 'success');
                                } else {
                                    await deleteOne('unpaid_entries', { timestamp: entry.timestamp });
                                    showToast('Will delete from cloud when online', 'info');
                                }
                            } catch { }
                        })();
                    }
                    state.unpaidEntries.splice(idx, 1);
                    saveData();
                    render();
                    showToast("Entry deleted", "success");
                }
            });
        }

        function renderNotes() {
            return `
                <div class="card">
                    <h2>Add Note</h2>
                    <form onsubmit="addNote(event)">
                        <div class="form-group">
                            <label>Note Title (Optional)</label>
                            <input type="text" id="noteTitle" placeholder="Brief title...">
                        </div>
                        <div class="form-group">
                            <textarea id="noteContent" placeholder="Write your note here..." required></textarea>
                        </div>
                        <button type="submit">Save Note</button>
                    </form>
                </div>

                <div class="card">
                    <h2>All Notes (${state.notes.length})</h2>
                    <div class="search-box">
                        <input type="text" placeholder=" Search notes..." oninput="searchNotes(this.value)" id="noteSearch">
                    </div>
                    <div id="notesList">
                        ${renderNotesList()}
                    </div>
                    ${(() => { const total = state.notes.length; const count = (state.listShowCount && state.listShowCount.notes) ? state.listShowCount.notes : 3; const hasMore = count < total; return `<button class=\"collapse-btn\" onclick=\"${hasMore ? `showMoreList('notes')` : `collapseList('notes')`}\"><span class=\"collapse-icon ${hasMore ? '' : 'expanded'}\"></span><span>${hasMore ? 'See more' : 'Hide'}</span></button>`; })()}
                </div>
            `;
        }

        function renderNotesList(searchPeriod = '') {
            let notes = state.notes.slice().reverse();
            const count = (state.listShowCount && state.listShowCount.notes) ? state.listShowCount.notes : 3;
            notes = notes.slice(0, count);

            if (searchPeriod) {
                const Period = searchPeriod.toLowerCase();
                notes = notes.filter(n =>
                    n.content.toLowerCase().includes(Period) ||
                    (n.title && n.title.toLowerCase().includes(Period))
                );
            }

            if (notes.length === 0) {
                return '<p style="text-align: center; color: #666;">No notes found</p>';
            }

            return notes.map((note, idx) => {
                const actualIndex = state.notes.length - 1 - idx;
                const isEditing = state.editingNoteIndex === actualIndex;

                if (isEditing) {
                    return `
                <div class="item">
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 6px;">Title (Optional)</label>
                        <input type="text" id="editNoteTitle_${actualIndex}" 
                               value="${(note.title || '').replace(/"/g, '&quot;')}" 
                               placeholder="Note title..."
                               style="width: 100%; padding: 10px; border: 2px solid #667eea; border-radius: 8px;">
                    </div>
                    <div style="margin-bottom: 12px;">
                        <label style="display: block; font-size: 13px; font-weight: 600; margin-bottom: 6px;">Content</label>
                        <textarea id="editNoteContent_${actualIndex}" 
                                  style="width: 100%; min-height: 150px; padding: 10px; border: 2px solid #667eea; border-radius: 8px;"
                                  placeholder="Write your note here...">${note.content}</textarea>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button class="btn-success btn-small" onclick="saveNoteEdit(${actualIndex})"> Save</button>
                        <button class="btn-secondary btn-small" onclick="cancelNoteEdit()"> Cancel</button>
                    </div>
                </div>
            `;
                }

                return `
            <div class="item">
                <div class="note-preview" onclick="openNoteModal(${actualIndex})" style="cursor: pointer;">
                    ${note.title ? `<div class="item-title" style="margin-bottom: 8px;">${escapeHTML(note.title)}</div>` : ''}
                    <div class="item-subtitle" style="margin-bottom: 8px;">${escapeHTML(note.date)} ${escapeHTML(note.time)}</div>
                    <div style="white-space: pre-wrap;">${escapeHTML(note.content)}</div>
                </div>
                <div style="display: flex; gap: 6px; margin-top: 8px;">
                    <button class="btn-small" onclick="startEditingNote(${actualIndex})"> Edit</button>
                    <button class="btn-small btn-danger" onclick="deleteNoteByIndex(${actualIndex})"> Delete</button>
                </div>
            </div>
        `;
            }).join('');
        }

        function startEditingNote(index) {
            state.editingNoteIndex = index;
            saveData();
            render();
            setTimeout(() => {
                const contentInput = document.getElementById(`editNoteContent_${index}`);
                if (contentInput && typeof contentInput.focus === 'function') {
                    try { contentInput.focus(); contentInput.selectionStart = contentInput.value.length; contentInput.selectionEnd = contentInput.value.length; } catch (e) { }
                    return;
                }
                const titleInput = document.getElementById(`editNoteTitle_${index}`);
                if (titleInput && typeof titleInput.focus === 'function') {
                    try { titleInput.focus(); } catch (e) { }
                }
            }, 50);
        }

        function cancelNoteEdit() {
            state.editingNoteIndex = null;
            saveData();
            render();
        }

        async function saveNoteEdit(index) {
            playTapSound();
            hapticShort();
            const titleInput = document.getElementById(`editNoteTitle_${index}`);
            const contentInput = document.getElementById(`editNoteContent_${index}`);

            if (!contentInput || !contentInput.value.trim()) {
                return showToast('Note content cannot be empty', 'error');
            }

            state.notes[index].title = titleInput ? titleInput.value.trim() : '';
            state.notes[index].content = contentInput.value.trim();
            state.editingNoteIndex = null;

            saveData();
            render();
            showToast('Note updated successfully', 'success');
            if (syncEnabled) {
                const n = state.notes[index];
                await upsertOne('notes', {
                    title: n.title || '',
                    content: n.content,
                    date: n.date,
                    time: n.time,
                    timestamp: n.timestamp
                });
                syncInBackground();
            }
        }

        function searchNotes(Period) {
            document.getElementById('notesList').innerHTML = renderNotesList(Period);
        }

        async function addNote(e) {
            e.preventDefault();
            playTapSound();
            hapticShort();
            const now = new Date();
            const content = document.getElementById('noteContent').value.trim();
            const title = document.getElementById('noteTitle')?.value.trim();

            if (!content) {
                return showToast('Please enter note content', 'error');
            }

            const note = {
                title: title || '',
                content: content,
                date: getTodayDateString(),
                time: now.toLocaleTimeString(),
                timestamp: now.getTime()
            };

            state.notes.push(note);
            saveData();
            render();
            showToast("Note saved", "success");

            // Sync in background
            if (syncEnabled) syncInBackground();
        }

        function openNoteModal(index) {
            state.currentNoteIndex = index;
            const note = state.notes[index];
            const modal = document.getElementById('noteModal');
            const content = document.getElementById('noteModalContent');
            content.innerHTML = `
                ${note.title ? `<h3 class="modal-title" style="margin-bottom: 12px;">${escapeHTML(note.title)}</h3>` : ''}
                <div style="margin-bottom: 12px; color: #666; font-size: 13px;">${escapeHTML(note.date)} ${escapeHTML(note.time)}</div>
                <div style="white-space: pre-wrap; line-height: 1.6;">${escapeHTML(note.content)}</div>
            `;
            modal.classList.add('show');
            modal.setAttribute('aria-modal', 'true');
            const handleOutside = (e) => {
                if (e.target === modal) {
                    closeNoteModal();
                }
            };
            modal.addEventListener('click', handleOutside, { once: true });
        }

        function closeNoteModal() {
            document.getElementById('noteModal').classList.remove('show');
            state.currentNoteIndex = null;
        }

        function composeNoteText(note) {
            const title = (note.title || '').trim();
            const content = (note.content || '').trim();
            return title ? (title + '\n\n' + content) : content;
        }

        async function copyNoteFromModal() {
            if (state.currentNoteIndex === null) return;
            try { playTapSound(); } catch { }
            try { hapticShort(); } catch { }
            const note = state.notes[state.currentNoteIndex] || {};
            const text = composeNoteText(note);
            try {
                await navigator.clipboard.writeText(text);
                showToast('Note copied', 'success');
            } catch (e) {
                try {
                    const ta = document.createElement('textarea');
                    ta.value = text;
                    ta.setAttribute('readonly', '');
                    ta.style.position = 'fixed';
                    ta.style.opacity = '0';
                    document.body.appendChild(ta);
                    ta.select();
                    document.execCommand('copy');
                    document.body.removeChild(ta);
                    showToast('Note copied', 'success');
                } catch {
                    showToast('Copy failed', 'error');
                }
            }
        }

        async function shareNoteFromModal() {
            if (state.currentNoteIndex === null) return;
            try { playTapSound(); } catch { }
            try { hapticShort(); } catch { }
            const note = state.notes[state.currentNoteIndex] || {};
            const title = (note.title || 'Note').trim() || 'Note';
            const text = composeNoteText(note);
            const ua = navigator.userAgent || navigator.vendor || window.opera;
            const isIOS = /iPad|iPhone|iPod/.test(ua) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            const isAndroid = /Android/.test(ua);
            if (navigator.share) {
                try {
                    await navigator.share({ title, text });
                    showToast('Shared', 'success');
                    return;
                } catch { }
            }
            try {
                const smsBody = encodeURIComponent(text);
                const smsUrl = isIOS ? `sms:&body=${smsBody}` : `sms:?body=${smsBody}`;
                window.location.href = smsUrl;
                return;
            } catch { }
            try {
                await navigator.clipboard.writeText(text);
                showToast('Copied. Share via any app', 'info');
            } catch {
                showToast('Sharing not supported', 'error');
            }
        }

        function editNoteFromModal() {
            if (state.currentNoteIndex === null) return;
            const idx = state.currentNoteIndex;
            closeNoteModal();
            startEditingNote(idx);
        }

        function deleteNoteFromModal() {
            if (state.currentNoteIndex === null) return;
            showConfirm("Delete this note?", async function () {
                try { playDeleteSound(); } catch (e) { }
                const note = state.notes[state.currentNoteIndex];
                if (note) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('notes', { timestamp: note.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('notes', { timestamp: note.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.notes.splice(state.currentNoteIndex, 1);
                saveData();
                closeNoteModal();
                render();
                showToast("Note deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }

        // Offline info modal control
        function openOfflineInfoModal() {
            const modal = document.getElementById('offlineInfoModal');
            if (!modal) return;
            modal.classList.add('show');
            const handleOutside = (e) => {
                if (e.target === modal) {
                    closeOfflineInfoModal();
                }
            };
            modal.addEventListener('click', handleOutside, { once: true });
        }

        function closeOfflineInfoModal() {
            const modal = document.getElementById('offlineInfoModal');
            if (modal) modal.classList.remove('show');
        }

        function deleteNoteFromModal() {
            if (state.currentNoteIndex === null) return;
            showConfirm("Delete this note?", async function () {
                try { playDeleteSound(); } catch (e) { }
                const note = state.notes[state.currentNoteIndex];
                if (note) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('notes', { timestamp: note.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('notes', { timestamp: note.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.notes.splice(state.currentNoteIndex, 1);
                saveData();
                closeNoteModal();
                render();
                showToast("Note deleted", "success");

                // Sync in background
                if (syncEnabled) syncInBackground();
            });
        }


        function deleteNoteByIndex(index) {
            showConfirm("Delete this note?", async function () {
                try { playDeleteSound(); } catch (e) { }
                const note = state.notes[index];
                if (note) {
                    try {
                        if (navigator.onLine && syncEnabled && currentUser) {
                            await deleteOne('notes', { timestamp: note.timestamp });
                            showToast('Deleted from cloud', 'success');
                        } else {
                            await deleteOne('notes', { timestamp: note.timestamp });
                            showToast('Will delete from cloud when online', 'info');
                        }
                    } catch { }
                }
                state.notes.splice(index, 1);
                saveData();
                render();
                showToast("Note deleted", "success");

                if (syncEnabled) syncInBackground();
            });
        }

        function togglePrivacy() {
            state.privacyBlurred = !state.privacyBlurred;
            saveData();
            try {
                const btn = document.getElementById('privacyToggleBtn');
                if (btn) { btn.classList.add('bounce'); setTimeout(() => btn.classList.remove('bounce'), 600); }
            } catch { }
            render();
        }

        function toggleDashboardPrivacy() {
            state.dashboardPrivacyBlurred = !state.dashboardPrivacyBlurred;
            saveData();
            try {
                const btn = document.getElementById('dashboardPrivacyToggleBtn');
                if (btn) { btn.classList.add('bounce'); setTimeout(() => btn.classList.remove('bounce'), 600); }
            } catch { }
            render();
        }

        function renderAnalytics() {
            const stats = getStats();
            const netProfit = stats.netProfit;

            return `
    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
    <div class="stat-card" style="padding: 12px;">
        <div class="stat-label" style="font-size: 10px;">REVENUE</div>
        <div class="stat-value" style="font-size: 16px;"> ${formatNumber(stats.totalRevenue)} Tsh</div>
    </div>
    <div class="stat-card" style="padding: 12px;">
        <div class="stat-label" style="font-size: 10px;">EXPENSES</div>
        <div class="stat-value" style="font-size: 16px;"> ${formatNumber(stats.totalExpenses)} Tsh</div>
    </div>
    <div class="stat-card" style="background: ${netProfit >= 0 ? '#2e7d32' : '#d32f2f'}; padding: 12px;">
        <div class="stat-label" style="font-size: 10px;">NET PROFIT</div>
        <div class="stat-value" style="font-size: 16px;"> ${formatNumber(netProfit)} Tsh</div>
    </div>
    <div class="stat-card" style="background: #1976d2; padding: 12px;">
        <div class="stat-label" style="font-size: 10px;">TOTAL SALES</div>
        <div class="stat-value" style="font-size: 16px;">${stats.totalSalesCount}</div>
    </div>
</div>

    <div class="card">
        <h2>Download Reports</h2>
        <button onclick="downloadDailyReportPDF()"> DAILY REPORT (PDF)</button>
        <button style="margin-top:8px;" onclick="downloadSalesReportPDF()"> Download Report (PDF)</button>
        <button class="btn-secondary" style="margin-top:8px;" onclick="downloadSalesReportExcel()"> Download Report (Excel)</button>
        <button class="btn-secondary" style="margin-top:8px;" onclick="downloadBackup()"> Backup All Data</button>
    </div>

    <div class="card">
        <h2>Payment Methods</h2>
        ${getPaymentMethodsHTML()}
    </div>

    <div class="card">
        <h2>Money Transactions Summary</h2>
        ${getTransactionSummaryHTML()}
    </div>

    <div class="card">
        <h2>Category Performance</h2>
        ${getCategoryPerformanceHTML()}
    </div>

    <div class="card">
        <h2>Top Products by Profit</h2>
        ${getTopProductsHTML()}
    </div>

    <div class="card">
        <h2>Analytics Chart</h2>
        <canvas id="analyticsChart"></canvas>
    </div>
`;
        }

        function getCategoryPerformanceHTML() {
            const categoryStats = {};
            state.sales.forEach(s => {
                const product = state.products.find(p => p.name === s.productName);
                if (product) {
                    if (!categoryStats[product.category]) {
                        categoryStats[product.category] = { profit: 0, revenue: 0, count: 0 };
                    }
                    categoryStats[product.category].profit += s.profit;
                    categoryStats[product.category].revenue += s.totalPrice;
                    categoryStats[product.category].count += 1;
                }
            });

            const entries = Object.entries(categoryStats)
                .sort((a, b) => b[1].profit - a[1].profit)
                .slice(0, 2);

            if (entries.length === 0) {
                return '<p style="text-align: center; color: #666;">No category data yet</p>';
            }

            return entries.map(([category, data]) => `
                <div class="item">
                    <div class="item-header">
                        <span class="item-title">${category}</span>
                        <span style="color: #2e7d32; font-weight: 700;"> ${formatNumber(data.profit)} Tsh</span>
                    </div>
                    <div class="item-subtitle">
                        Revenue: ${formatNumber(data.revenue)} Tsh | ${data.count} sales
                    </div>
                </div>
            `).join('');
        }

        function getTopProductsHTML() {
            const productStats = {};
            state.sales.forEach(s => {
                if (!productStats[s.productName]) {
                    productStats[s.productName] = { profit: 0, quantity: 0, revenue: 0 };
                }
                productStats[s.productName].profit += s.profit;
                productStats[s.productName].quantity += s.quantity;
                productStats[s.productName].revenue += s.totalPrice;
            });

            const entries = Object.entries(productStats)
                .sort((a, b) => b[1].profit - a[1].profit)
                .slice(0, 2);

            if (entries.length === 0) {
                return '<p style="text-align: center; color: #666;">No product data yet</p>';
            }

            return entries.map(([product, data], index) => `
                <div class="item">
                    <div class="item-header">
                        <span class="item-title">${index + 1}. ${product}</span>
                        <span style="color: #2e7d32; font-weight: 700;"> ${formatNumber(data.profit)} Tsh</span>
                    </div>
                    <div class="item-subtitle">
                        Sold: ${data.quantity} units | Revenue: ${formatNumber(data.revenue)} Tsh
                    </div>
                </div>
            `).join('');
        }

        function getPaymentMethodsHTML() {
            const paymentTotals = {};
            state.sales.forEach(s => {
                paymentTotals[s.payment] = (paymentTotals[s.payment] || 0) + s.totalPrice;
            });
            if (Object.keys(paymentTotals).length === 0) {
                return '<p style="text-align: center; color: #666;">No payment data yet</p>';
            }

            const entries = Object.entries(paymentTotals)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 2);
            return entries.map(([method, total]) => `
                <div class="item">
                    <div style="display: flex; justify-content: space-between;">
                        <span class="item-title">${method}</span>
                        <span style="font-weight: 700;"> ${formatNumber(total)} Tsh</span>
                    </div>
                </div>
            `).join('');
        }

        function getTransactionSummaryHTML() {
            const transactionTotals = {
                mpesa: { deposit: 0, withdrawal: 0 },
                crdb: { deposit: 0, withdrawal: 0 },
                nmb: { deposit: 0, withdrawal: 0 },
                airtel: { deposit: 0, withdrawal: 0 },
                halopesa: { deposit: 0, withdrawal: 0 },
                yas: { deposit: 0, withdrawal: 0 }
            };

            (state.transactions || []).forEach(t => {
                if (transactionTotals[t.channel]) {
                    transactionTotals[t.channel][t.type] += t.amount || 0;
                }
            });

            const channelLabels = {
                mpesa: 'M-Pesa',
                crdb: 'CRDB',
                nmb: 'NMB',
                airtel: 'Airtel Money',
                halopesa: 'Halopesa',
                yas: 'Yas Tanzania'
            };

            const channelColors = {
                mpesa: '#d32f2f',
                crdb: '#2e7d32',
                nmb: '#e65100',
                airtel: '#b71c1c',
                halopesa: '#fdd835',
                yas: '#0d47a1'
            };

            const hasTransactions = Object.values(transactionTotals).some(val => val.deposit > 0 || val.withdrawal > 0);

            if (!hasTransactions) {
                return '<p style="text-align: center; color: #666;">No transaction data yet</p>';
            }

            const entries = Object.entries(transactionTotals)
                .filter(([channel, amounts]) => amounts.deposit > 0 || amounts.withdrawal > 0)
                .map(([channel, amounts]) => ([channel, amounts, (amounts.deposit + amounts.withdrawal)]))
                .sort((a, b) => b[2] - a[2])
                .slice(0, 2);

            return entries.map(([channel, amounts]) => `
                <div class="item">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                        <span style="width: 12px; height: 12px; border-radius: 50%; background: ${channelColors[channel]};"></span>
                        <span class="item-title">${channelLabels[channel]}</span>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 13px; color: #666;">
                        <span>Deposits: <strong style="color: #2e7d32;"> ${formatNumber(amounts.deposit)} Tsh</strong></span>
                        <span>Withdrawals: <strong style="color: #d32f2f;"> ${formatNumber(amounts.withdrawal)} Tsh</strong></span>
                    </div>
                    <div style="margin-top: 4px; font-weight: 600;">
                        Net: <span style="color: ${amounts.deposit - amounts.withdrawal >= 0 ? '#2e7d32' : '#d32f2f'};">
                            ${amounts.deposit - amounts.withdrawal >= 0 ? '+' : ''} ${formatNumber(amounts.deposit - amounts.withdrawal)} Tsh
                        </span>
                    </div>
                </div>
            `).join('');
        }

        function createAnalyticsChart() {
            setTimeout(() => {
                const canvas = document.getElementById('analyticsChart');
                if (!canvas) return;

                if (chartInstance) {
                    chartInstance.destroy();
                }

                const stats = getStats();
                const revenue = stats.totalRevenue;
                const expenses = stats.totalExpenses;
                const profit = stats.totalProfit;

                const transactionTotals = {
                    mpesa: 0, crdb: 0, nmb: 0, airtel: 0, halopesa: 0, yas: 0
                };
                (state.transactions || []).forEach(t => {
                    if (transactionTotals.hasOwnProperty(t.channel)) {
                        transactionTotals[t.channel] += t.amount || 0;
                    }
                });

                const ctx = canvas.getContext('2d');
                chartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Revenue', 'Expenses', 'Profit', 'M-Pesa', 'CRDB', 'NMB', 'Airtel', 'Halopesa', 'Yas'],
                        datasets: [{
                            label: 'Amount (Tsh)',
                            data: [
                                revenue,
                                expenses,
                                profit,
                                transactionTotals.mpesa,
                                transactionTotals.crdb,
                                transactionTotals.nmb,
                                transactionTotals.airtel,
                                transactionTotals.halopesa,
                                transactionTotals.yas
                            ],
                            backgroundColor: [
                                '#1976d2',
                                '#d32f2f',
                                '#2e7d32',
                                '#d32f2f',
                                '#2e7d32',
                                '#e65100',
                                '#b71c1c',
                                '#fdd835',
                                '#0d47a1'
                            ]
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        plugins: {
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }, 100);
        }
        async function downloadSalesReportPDF() {
            playTapSound();
            hapticShort();
            await ensureLogoReady();
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'pt', format: 'a4' });
            const pageWidth = 595.28;
            const margin = 50;
            const usableWidth = pageWidth - margin * 2;
            let y = 50;
            const centerX = pageWidth / 2;

            // Header
            doc.setFillColor(240, 240, 240);
            doc.rect(0, 0, pageWidth, 100, 'F');

            doc.setTextColor(0, 0, 0);
            doc.setFontSize(24);
            doc.setFont(undefined, 'bold');
            const profile = getUserProfileData();
            const drew = drawLogo(doc, centerX - 18, 20, 36, { borderRadius: 18 });
            doc.text(profile.businessName, centerX, 45, { align: 'center' });

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.text(`${profile.address} | ${profile.phone} | ${profile.email}`, centerX, 70, { align: 'center' });

            doc.setDrawColor(102, 126, 234);
            doc.setLineWidth(3);
            doc.line(margin, 85, pageWidth - margin, 85);

            y = 120;
            doc.setTextColor(0, 0, 0);
            doc.setFontSize(18);
            doc.setFont(undefined, 'bold');
            doc.text("Financial Report", margin, y);

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.setTextColor(100, 100, 100);
            doc.text(`Generated: ${getTodayDateString()}`, margin, y + 20);
            y += 50;

            function drawTable(headers, rows, startY) {
                const colCount = headers.length;
                const colWidth = usableWidth / colCount;
                let curY = startY;
                const headerH = 22;

                doc.setFillColor(102, 126, 234);
                doc.roundedRect(margin, curY, usableWidth, headerH, 3, 3, 'F');

                doc.setTextColor(255, 255, 255);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                for (let i = 0; i < colCount; i++) {
                    const txtX = margin + i * colWidth + 8;
                    doc.text(String(headers[i]), txtX, curY + 15);
                }
                curY += headerH + 2;

                doc.setFont(undefined, 'normal');
                doc.setFontSize(9);
                for (let r = 0; r < rows.length; r++) {
                    let maxLines = 1;
                    const cellLines = [];
                    for (let c = 0; c < colCount; c++) {
                        const txt = rows[r][c] === null || rows[r][c] === undefined ? '' : String(rows[r][c]);
                        const lines = doc.splitTextToSize(txt, colWidth - 16);
                        cellLines.push(lines);
                        if (lines.length > maxLines) maxLines = lines.length;
                    }
                    const lineH = 10;
                    const rowH = maxLines * lineH + 8;

                    if (curY + rowH > 750) {
                        doc.addPage();
                        curY = margin;
                    }

                    if (r % 2 === 0) {
                        doc.setFillColor(248, 249, 250);
                        doc.roundedRect(margin, curY, usableWidth, rowH, 2, 2, 'F');
                    }

                    doc.setTextColor(40, 40, 40);
                    for (let c = 0; c < colCount; c++) {
                        const txtX = margin + c * colWidth + 8;
                        const lines = cellLines[c];
                        for (let li = 0; li < lines.length; li++) {
                            doc.text(lines[li], txtX, curY + 15 + li * lineH);
                        }
                    }
                    curY += rowH;
                }
                return curY + 20;
            }

            // Sales
            const salesHeaders = ["Date", "Product", "Customer", "Qty", "Price", "Profit"];
            const salesRows = (state.sales || []).map(s => [
                s.date, s.productName, s.customer, s.quantity, formatNumber(s.totalPrice) + ' Tsh', formatNumber(s.profit) + ' Tsh'
            ]);
            if (salesRows.length > 0) {
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(0, 0, 0);
                doc.text("Sales Records", margin, y);
                y += 15;
                y = drawTable(salesHeaders, salesRows, y);
                const totalQty = (state.sales || []).reduce((sum, s) => sum + (s.quantity || 0), 0);
                const totalPrice = (state.sales || []).reduce((sum, s) => sum + (s.totalPrice || 0), 0);
                const totalProfit = (state.sales || []).reduce((sum, s) => sum + (s.profit || 0), 0);
                const colCount = salesHeaders.length;
                const colWidth = usableWidth / colCount;
                const rowHeight = 22;
                if (y + rowHeight > 750) { doc.addPage(); y = margin; }
                doc.setFillColor(245, 245, 245);
                doc.setDrawColor(180, 180, 180);
                doc.setLineWidth(0.75);
                doc.roundedRect(margin, y, usableWidth, rowHeight, 2, 2, 'FD');
                doc.setTextColor(40, 40, 40);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                doc.text('Totals', margin + 2 * colWidth + 8, y + 15);
                doc.text(String(totalQty), margin + 3 * colWidth + 8, y + 15);
                doc.text(formatNumber(totalProfit) + ' Tsh', margin + 5 * colWidth + 8, y + 15);
                y += rowHeight + 20;
            }

            // Expenses
            // Group inventory purchases per period, keep other expenses as is
            const groups = {};
            (state.expenses || []).forEach(e => {
                if (e.category === 'Inventory Purchase' && /^Period \d+/.test(e.comment || '')) {
                    const key = e.comment;
                    groups[key] = groups[key] || { amount: 0, date: e.date, time: e.time };
                    groups[key].amount += (e.amount || 0);
                }
            });
            const periodRows = Object.keys(groups).sort((a, b) => {
                const na = parseInt(a.replace('Period ', ''), 10);
                const nb = parseInt(b.replace('Period ', ''), 10);
                return na - nb;
            }).map(key => [groups[key].date, key, 'Inventory Purchase', formatNumber(groups[key].amount) + ' Tsh']);
            const otherRows = (state.expenses || []).filter(e => e.category !== 'Inventory Purchase').map(e => [
                e.date, e.description, e.category, formatNumber(e.amount || 0) + ' Tsh'
            ]);
            const expHeaders = ["Date", "Description", "Category", "Amount"];
            const expRows = [...otherRows, ...periodRows];
            if (expRows.length > 0) {
                if (y > 650) { doc.addPage(); y = margin; }
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.text("Expenses", margin, y);
                y += 15;
                y = drawTable(expHeaders, expRows, y);
                const totalExp = (state.expenses || []).reduce((sum, e) => sum + (e.amount || 0), 0);
                const colCountE = expHeaders.length;
                const colWidthE = usableWidth / colCountE;
                const rowHeightE = 22;
                if (y + rowHeightE > 750) { doc.addPage(); y = margin; }
                doc.setFillColor(245, 245, 245);
                doc.setDrawColor(180, 180, 180);
                doc.setLineWidth(0.75);
                doc.roundedRect(margin, y, usableWidth, rowHeightE, 2, 2, 'FD');
                doc.setTextColor(40, 40, 40);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                doc.text('Total', margin + 2 * colWidthE + 8, y + 15);
                doc.text(formatNumber(totalExp) + ' Tsh', margin + 3 * colWidthE + 8, y + 15);
                y += rowHeightE + 20;
            }

            // Transactions
            const transHeaders = ["Type", "Date", "Customer", "Amount"];
            const transRows = (state.transactions || []).map(t => [
                t.channel.toUpperCase(), t.date, t.customerName || 'N/A', formatNumber(t.amount || 0) + ' Tsh'
            ]);
            if (transRows.length > 0) {
                if (y > 650) { doc.addPage(); y = margin; }
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.text("Money Transactions", margin, y);
                y += 15;
                y = drawTable(transHeaders, transRows, y);
            }

            // Chart
            if (chartInstance) {
                doc.addPage();
                doc.setFontSize(16);
                doc.setFont(undefined, 'bold');
                doc.text("Analytics Overview", margin, 50);

                const chartImage = chartInstance.toBase64Image();
                doc.addImage(chartImage, 'PNG', margin, 70, usableWidth, 250);
            }

            // Footer
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFillColor(240, 240, 240);
                doc.rect(0, 792 - 30, pageWidth, 30, 'F');
                doc.setTextColor(100, 100, 100);
                doc.setFontSize(9);
                doc.text(`Page ${i} of ${pageCount}`, margin, 792 - 11);
                doc.text(`The Ultimate Business Achitecture (TUBA)  ${new Date().getFullYear()}`, pageWidth - margin, 792 - 8, { align: 'right' });
            }

            downloadPDFSafe(doc, `Financial_Report_${getTodayDateString()}.pdf`);
            showToast("PDF ready", "success");
        }

        async function downloadDailyReportPDF() {
            playTapSound();
            hapticShort();
            await ensureLogoReady();
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ unit: 'pt', format: 'a4' });
            const pageWidth = 595.28;
            const margin = 50;
            const usableWidth = pageWidth - margin * 2;
            let y = 50;
            const centerX = pageWidth / 2;

            const today = getTodayDateString();
            const todaySales = state.sales.filter(s => s.date === today);
            const todayExpenses = state.expenses.filter(e => e.date === today);
            const todayTransactions = state.transactions.filter(t => t.date === today);

            // Calculate today's stats
            const todayRevenue = todaySales.reduce((sum, s) => sum + (s.totalPrice || 0), 0);
            const todayProfit = todaySales.reduce((sum, s) => sum + (s.profit || 0), 0);
            const todayExpenseTotal = todayExpenses.reduce((sum, e) => sum + (e.amount || 0), 0);
            const todayNetProfit = todayProfit - todayExpenseTotal;

            // Header
            doc.setFillColor(240, 240, 240);
            doc.rect(0, 0, pageWidth, 100, 'F');

            doc.setTextColor(0, 0, 0);
            doc.setFontSize(24);
            doc.setFont(undefined, 'bold');

            const profile = getUserProfileData();
            const drewDaily = drawLogo(doc, centerX - 18, 20, 36, { borderRadius: 18 });
            doc.text(profile.businessName, centerX, 45, { align: 'center' });

            doc.setFontSize(10);
            doc.setFont(undefined, 'normal');
            doc.text(`${profile.address} | ${profile.phone} | ${profile.email}`, centerX, 70, { align: 'center' });

            doc.setDrawColor(102, 126, 234);
            doc.setLineWidth(3);
            doc.line(margin, 85, pageWidth - margin, 85);

            y = 120;
            doc.setTextColor(0, 0, 0);
            doc.setFontSize(18);
            doc.setFont(undefined, 'bold');
            doc.text("Daily Report", margin, y);

            doc.setFontSize(12);
            doc.setFont(undefined, 'normal');
            doc.setTextColor(100, 100, 100);
            doc.text(`Date: ${today}`, margin, y + 20);
            y += 50;

            // Summary Box
            doc.setFillColor(240, 248, 255);
            doc.roundedRect(margin, y, usableWidth, 100, 5, 5, 'F');
            doc.setDrawColor(102, 126, 234);
            doc.setLineWidth(2);
            doc.roundedRect(margin, y, usableWidth, 100, 5, 5, 'S');

            doc.setTextColor(0, 0, 0);
            doc.setFontSize(11);
            doc.setFont(undefined, 'bold');
            doc.text("TODAY'S SUMMARY", margin + 15, y + 20);

            doc.setFont(undefined, 'normal');
            doc.setFontSize(10);
            doc.text(`Total Sales: ${todaySales.length}`, margin + 15, y + 40);
            doc.text(`Revenue: ${formatNumber(todayRevenue)} Tsh`, margin + 15, y + 55);
            doc.text(`Profit: ${formatNumber(todayProfit)} Tsh`, margin + 15, y + 70);
            doc.text(`Expenses: ${formatNumber(todayExpenseTotal)} Tsh`, margin + 200, y + 40);
            doc.text(`Net Profit: ${formatNumber(todayNetProfit)} Tsh`, margin + 200, y + 55);

            const netColor = todayNetProfit >= 0 ? [46, 125, 50] : [211, 47, 47];
            doc.setTextColor(...netColor);
            doc.setFont(undefined, 'bold');
            doc.text(`Status: ${todayNetProfit >= 0 ? 'Profitable ' : 'Loss '}`, margin + 200, y + 70);

            y += 120;

            function drawTable(headers, rows, startY) {
                const colCount = headers.length;
                const colWidth = usableWidth / colCount;
                let curY = startY;
                const rowHeight = 22;

                doc.setFillColor(102, 126, 234);
                doc.roundedRect(margin, curY, usableWidth, rowHeight, 3, 3, 'F');

                doc.setTextColor(255, 255, 255);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                for (let i = 0; i < colCount; i++) {
                    const txtX = margin + i * colWidth + 8;
                    doc.text(String(headers[i]), txtX, curY + 15);
                }
                curY += rowHeight + 2;

                doc.setFont(undefined, 'normal');
                doc.setFontSize(9);
                for (let r = 0; r < rows.length; r++) {
                    if (curY + rowHeight > 750) {
                        doc.addPage();
                        curY = margin;
                    }

                    if (r % 2 === 0) {
                        doc.setFillColor(248, 249, 250);
                        doc.roundedRect(margin, curY, usableWidth, rowHeight, 2, 2, 'F');
                    }

                    doc.setTextColor(40, 40, 40);
                    for (let c = 0; c < colCount; c++) {
                        const txt = rows[r][c] === null || rows[r][c] === undefined ? '' : String(rows[r][c]);
                        const txtX = margin + c * colWidth + 8;
                        doc.text(txt, txtX, curY + 15, { maxWidth: colWidth - 16 });
                    }
                    curY += rowHeight;
                }
                return curY + 20;
            }

            // Today's Sales
            if (todaySales.length > 0) {
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(0, 0, 0);
                doc.text("Today's Sales", margin, y);
                y += 15;
                const salesHeaders = ["Time", "Product", "Customer", "Qty", "Price", "Profit"];
                const salesRows = todaySales.map(s => [
                    s.time, s.productName, s.customer, s.quantity,
                    formatNumber(s.totalPrice) + ' Tsh', formatNumber(s.profit) + ' Tsh'
                ]);
                y = drawTable(salesHeaders, salesRows, y);
                const totalQty = todaySales.reduce((sum, s) => sum + (s.quantity || 0), 0);
                const totalPrice = todaySales.reduce((sum, s) => sum + (s.totalPrice || 0), 0);
                const totalProfit = todaySales.reduce((sum, s) => sum + (s.profit || 0), 0);
                const colCount = salesHeaders.length;
                const colWidth = usableWidth / colCount;
                const rowHeight = 22;
                if (y + rowHeight > 750) { doc.addPage(); y = margin; }
                doc.setFillColor(245, 245, 245);
                doc.setDrawColor(180, 180, 180);
                doc.setLineWidth(0.75);
                doc.roundedRect(margin, y, usableWidth, rowHeight, 2, 2, 'FD');
                doc.setTextColor(40, 40, 40);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                doc.text('Totals', margin + 2 * colWidth + 8, y + 15);
                doc.text(String(totalQty), margin + 3 * colWidth + 8, y + 15);
                doc.text(formatNumber(totalProfit) + ' Tsh', margin + 5 * colWidth + 8, y + 15);
                y += rowHeight + 20;
            }

            // Today's Expenses
            if (todayExpenses.length > 0) {
                if (y > 650) { doc.addPage(); y = margin; }
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.text("Today's Expenses", margin, y);
                y += 15;
                const expHeaders = ["Time", "Description", "Category", "Amount"];
                const expRows = todayExpenses.map(e => [
                    e.time, e.description, e.category, formatNumber(e.amount || 0) + ' Tsh'
                ]);
                y = drawTable(expHeaders, expRows, y);
                const totalExp = todayExpenses.reduce((sum, e) => sum + (e.amount || 0), 0);
                const colCountE = expHeaders.length;
                const colWidthE = usableWidth / colCountE;
                const rowHeightE = 22;
                if (y + rowHeightE > 750) { doc.addPage(); y = margin; }
                doc.setFillColor(245, 245, 245);
                doc.setDrawColor(180, 180, 180);
                doc.setLineWidth(0.75);
                doc.roundedRect(margin, y, usableWidth, rowHeightE, 2, 2, 'FD');
                doc.setTextColor(40, 40, 40);
                doc.setFont(undefined, 'bold');
                doc.setFontSize(10);
                doc.text('Total', margin + 2 * colWidthE + 8, y + 15);
                doc.text(formatNumber(totalExp) + ' Tsh', margin + 3 * colWidthE + 8, y + 15);
                y += rowHeightE + 20;
            }

            // Today's Transactions
            if (todayTransactions.length > 0) {
                if (y > 650) { doc.addPage(); y = margin; }
                doc.setFontSize(14);
                doc.setFont(undefined, 'bold');
                doc.text("Today's Transactions", margin, y);
                y += 15;
                const transHeaders = ["Type", "Time", "Customer", "Amount"];
                const transRows = todayTransactions.map(t => [
                    t.channel.toUpperCase(), t.time, t.customerName || 'N/A',
                    formatNumber(t.amount || 0) + ' Tsh'
                ]);
                y = drawTable(transHeaders, transRows, y);
            }

            // Footer
            const pageCount = doc.internal.getNumberOfPages();
            for (let i = 1; i <= pageCount; i++) {
                doc.setPage(i);
                doc.setFillColor(240, 240, 240);
                doc.rect(0, 792 - 30, pageWidth, 30, 'F');
                doc.setTextColor(100, 100, 100);
                doc.setFontSize(9);
                doc.text(`Page ${i} of ${pageCount}`, margin, 792 - 12);
                doc.text(`The Ultimate Business Achitecture (TUBA)  ${new Date().getFullYear()}`, pageWidth - margin, 792 - 8, { align: 'right' });
            }

            downloadPDFSafe(doc, `Daily_Report_${today}.pdf`);
            showToast("Daily report PDF ready", "success");
        }

        function downloadSalesReportExcel() {
            playTapSound();
            hapticShort();
            const totalSalesQty = (state.sales || []).reduce((sum, s) => sum + (s.quantity || 0), 0);
            const totalSalesPrice = (state.sales || []).reduce((sum, s) => sum + (s.totalPrice || 0), 0);
            const totalSalesProfit = (state.sales || []).reduce((sum, s) => sum + (s.profit || 0), 0);
            const totalExpenses = (state.expenses || []).reduce((sum, e) => sum + (e.amount || 0), 0);
            const totalTransactions = (state.transactions || []).reduce((sum, t) => sum + (t.amount || 0), 0);
            const rows = [
                ["TUBA - The Ultimate Business Architecture"],
                ["Financial Report"],
                [`Generated: ${getTodayDateString()}`],
                [],
                ["SALES RECORDS"],
                ["Date", "Product", "Customer", "Quantity", "Price (Tsh)", "Profit (Tsh)"],
                ...((state.sales || []).map(s => [s.date, s.productName, s.customer, s.quantity, s.totalPrice, s.profit])),
                ["", "", "Totals", totalSalesQty, totalSalesPrice, totalSalesProfit],
                [],
                ["EXPENSES"],
                ["Date", "Description", "Category", "Amount (Tsh)"],
                ...((state.expenses || []).map(e => [e.date, e.description, e.category, e.amount])),
                ["", "", "Total", totalExpenses],
                [],
                ["MONEY TRANSACTIONS"],
                ["Type", "Date", "Customer", "Amount (Tsh)"],
                ...((state.transactions || []).map(t => [t.channel.toUpperCase(), t.date, t.customerName || 'N/A', t.amount])),
                ["", "", "Total", totalTransactions]
            ];

            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet(rows);

            ws['!cols'] = [
                { wch: 15 }, { wch: 20 }, { wch: 20 }, { wch: 12 }, { wch: 15 }, { wch: 15 }
            ];

            XLSX.utils.book_append_sheet(wb, ws, "Financial Report");
            XLSX.writeFile(wb, `Financial_Report_${getTodayDateString()}.xlsx`);
            showToast("Excel downloaded successfully!", "success");
        }

        function downloadBackup() {
            playTapSound();
            hapticShort();
            exportData();
        }


        function openCleanupModal() {
            if (!currentUser) {
                showToast('You must be signed in to clean duplicates.', 'info');
                return;
            }
            const modal = document.getElementById('cleanupModal');
            modal.classList.add('show');
            const handleOutside = (e) => { if (e.target === modal) { closeCleanupModal(); } };
            modal.addEventListener('click', handleOutside, { once: true });
        }

        function closeCleanupModal() {
            document.getElementById('cleanupModal').classList.remove('show');
        }

        async function confirmCleanup() {
            closeCleanupModal();
            await cleanDuplicatesInSupabase();
        }

        async function cleanDuplicatesInSupabase() {
            if (!supabase || !currentUser) {
                showToast('You must be signed in before cleaning.', 'error');
                return;
            }

            showToast(' Starting cleanup...', 'info');
            updateSyncIndicator('syncing');

            // Delegate to comprehensive cleaner (content-based + clear-and-push)
            try {
                const result = await cleanAllDuplicates();
                updateSyncIndicator('synced');
                showToast(` Removed ${result.totalRemoved} duplicates!`, 'success');
            } catch (e) {
                console.error('Cleanup error:', e);
                updateSyncIndicator('synced');
                showToast(' Cleanup failed', 'error');
            }
        }

        function exportData(customMessage = null, customDurationMs = null) {
            const data = {
                products: state.products,
                sales: state.sales,
                expenses: state.expenses,
                customers: state.customers,
                invoices: state.invoices,
                receipts: state.receipts || [],
                categories: state.categories,
                inventory: state.inventory,
                notes: state.notes,
                transactions: state.transactions,
                unpaidEntries: state.unpaidEntries,
                transactionFloats: state.transactionFloats,
                dailyTarget: state.dailyTarget,
                monthlyTarget: state.monthlyTarget,
                exportDate: new Date().toISOString(),
                version: '2.0'
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `TUBA_finance_backup_${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showToast(customMessage || 'Data exported successfully!', 'success', null, null, customDurationMs || 3000);
        }

        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        if (confirm('Import will MERGE with existing data (no overwrite). Continue?')) {
                            // Merge arrays and deduplicate
                            state.products = deduplicateByContent([...(state.products || []), ...(data.products || [])], 'products');
                            state.sales = deduplicateByContent([...(state.sales || []), ...(data.sales || [])], 'sales');
                            state.expenses = deduplicateByContent([...(state.expenses || []), ...(data.expenses || [])], 'expenses');
                            state.customers = deduplicateByContent([...(state.customers || []), ...(data.customers || [])], 'customers');
                            state.invoices = deduplicateByContent([...(state.invoices || []), ...(data.invoices || [])], 'invoices');
                            state.notes = deduplicateByContent([...(state.notes || []), ...(data.notes || [])], 'notes');
                            state.transactions = deduplicateByContent([...(state.transactions || []), ...(data.transactions || [])], 'transactions');
                            state.unpaidEntries = deduplicateByContent([...(state.unpaidEntries || []), ...(data.unpaidEntries || [])], 'unpaid');

                            // Merge categories (set-based)
                            state.categories = Array.from(new Set([...(state.categories || []), ...((data.categories || []))]));

                            // Merge inventory by product name without overwriting local values
                            state.inventory = state.inventory || {};
                            const importedInventory = data.inventory || {};
                            Object.keys(importedInventory).forEach(name => {
                                if (!(name in state.inventory)) {
                                    state.inventory[name] = {
                                        stock: parseInt(importedInventory[name].stock) || 0,
                                        minAlert: parseInt(importedInventory[name].minAlert) || 5
                                    };
                                }
                            });

                            // Floats: merge per channel without overwriting
                            state.transactionFloats = state.transactionFloats || {};
                            const importedFloats = data.transactionFloats || {};
                            Object.keys(importedFloats).forEach(ch => {
                                if (!(ch in state.transactionFloats)) {
                                    state.transactionFloats[ch] = { initial: parseFloat(importedFloats[ch].initial) || 0, current: 0 };
                                }
                            });

                            // Targets: keep existing unless missing
                            if (state.dailyTarget == null) state.dailyTarget = data.dailyTarget || 0;
                            if (state.monthlyTarget == null) state.monthlyTarget = data.monthlyTarget || 0;

                            calculateFloatBalances();
                            saveData();
                            render();
                            showToast('Data imported and merged successfully!', 'success');

                            // If signed-in, upsert merged data to cloud in background
                            if (syncEnabled && currentUser) {
                                try { await clearAndPushAllData(); } catch (e) { /* no-op */ }
                            }
                        }
                    } catch (error) {
                        showToast('Error importing file. Please check the file format.', 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function updateHeaderDate() {
            const dateElement = document.getElementById('headerDate');
            if (!dateElement) return;

            const now = new Date();

            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');

            let hours = now.getHours();
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');

            const ampm = hours >= 12 ? 'PM' : 'AM';
            hours = hours % 12;
            hours = hours ? hours : 12; // Convert 0 to 12

            dateElement.innerHTML = `${year}-${month}-${day}<br>${hours}:${minutes}:${seconds} ${ampm}`;
        }

        function render() {
            const app = document.getElementById('app');
            try { processPlannedPurchases(); } catch { }
            switch (state.activeTab) {
                case 'dashboard': app.innerHTML = renderDashboard(); break;
                case 'account': app.innerHTML = renderAccount(); break;
                case 'sales': app.innerHTML = renderSales(); break;
                case 'transactions': app.innerHTML = renderTransactions(); break;
                case 'products': app.innerHTML = renderProducts(); break;
                case 'categories': app.innerHTML = renderCategories(); break;
                case 'expenses': app.innerHTML = renderExpenses(); break;
                case 'inventory': app.innerHTML = renderInventory(); break;
                case 'inventoryPurchases': app.innerHTML = renderInventoryTab(); break;
                case 'customers': app.innerHTML = renderCustomers(); break;
                case 'invoices': app.innerHTML = renderInvoices(); break;
                case 'analytics':
                    app.innerHTML = renderAnalytics();
                    createAnalyticsChart();
                    break;
                case 'unpaid': app.innerHTML = renderUnpaid(); break;
                case 'notes': app.innerHTML = renderNotes(); break;
            }
            renderNav();
            updateSideNavActiveState();

            // Update all "Select All" checkboxes after render
            setTimeout(() => {
                updateSelectAllCheckbox('sales');
                updateSelectAllCheckbox('products');
                updateSelectAllCheckbox('expenses');
                updateSelectAllCheckbox('customers');
                updateSelectAllCheckbox('transactions');
                updateSelectAllCheckbox('unpaidEntries');
            }, 0);
            try {
                document.querySelectorAll('.money-input').forEach(el => attachMoneyFormatter(el));
                const countInput = document.getElementById('bulkAddCount');
                const addBtn = document.getElementById('bulkAddButton');
                const updateLabel = () => {
                    const raw = countInput?.value;
                    const c = parseInt((raw || '').trim(), 10);
                    if (addBtn) addBtn.textContent = (raw && !isNaN(c) && c > 0) ? '+ Add Rows' : '+ Add Row';
                };
                if (countInput) {
                    countInput.addEventListener('input', updateLabel);
                    updateLabel();
                }
                Array.from(document.querySelectorAll('input[type="text"]:not(.money-input):not([data-nocap]), textarea:not([data-nocap])'))
                    .filter(el => el.type !== 'email')
                    .forEach(el => attachFirstWordCapitalizer(el));
                const dt = document.getElementById('dailyTarget');
                const mt = document.getElementById('monthlyTarget');
                dt && dt.addEventListener('blur', () => { try { setDailyTarget(); } catch { } });
                mt && mt.addEventListener('blur', () => { try { setMonthlyTarget(); } catch { } });
                if (state.activeTab === 'dashboard') {
                    setTimeout(() => { try { positionDashboardPrivacyButton(); } catch { } }, 0);
                }
                if (state.activeTab === 'account') {
                    setTimeout(async () => {
                        try { await initCountryCityData(); } catch { }
                        try {
                            const countrySelect = document.getElementById('profileCountrySelect');
                            const citySelect = document.getElementById('profileCitySelect');
                            const countryInput = document.getElementById('profileCountry');
                            const cityInput = document.getElementById('profileCity');
                            const currentCountry = (countryInput?.value || state.userProfile?.country || '').trim();
                            const currentCity = (cityInput?.value || state.userProfile?.city || '').trim();
                            if (countrySelect) {
                                countrySelect.innerHTML = `<option value="">-- Select Country --</option><option value="__manual__">Manual entry</option>` + getCountryOptionsSelectHTML();
                                if (currentCountry) {
                                    const src = state.countriesCities ? Object.keys(state.countriesCities) : Object.keys(COUNTRY_CITY_DATA);
                                    countrySelect.value = src.includes(currentCountry) ? currentCountry : '__manual__';
                                    onProfileCountrySelect(countrySelect.value);
                                }
                            }
                            if (citySelect) {
                                const baseCountry = currentCountry || (countrySelect?.value || '');
                                citySelect.innerHTML = `<option value="">-- Select City --</option><option value="__manual__">Manual entry</option>` + getCityOptionsSelectHTML(baseCountry);
                                if (currentCity) {
                                    const cities = (state.countriesCities || COUNTRY_CITY_DATA)[baseCountry] || [];
                                    citySelect.value = cities.includes(currentCity) ? currentCity : '__manual__';
                                    onProfileCitySelect(citySelect.value);
                                }
                            }
                        } catch { }
                    }, 0);
                }
                if (state.activeTab === 'expenses') { setupWindowVirtualList('expenses'); }
                if (state.activeTab === 'products') { setupWindowVirtualList('products'); }
                if (state.activeTab === 'categories') { setupWindowVirtualList('categories'); }
                if (state.activeTab === 'customers') { setupWindowVirtualList('customers'); }
                if (state.activeTab === 'notes') { setupWindowVirtualList('notes'); }
            } catch { }
            try { adjustContentPadding(); } catch { }
        }

        function adjustContentPadding() {
            const content = document.getElementById('app');
            const header = document.querySelector('.header');
            const bottom = document.getElementById('bottomNav');
            const banner = document.getElementById('offlineBanner');
            const auth = document.getElementById('authBanner');
            if (!content) return;
            const bannerH = (banner && banner.style.display !== 'none') ? banner.offsetHeight : 0;
            const authH = (auth && auth.style.display !== 'none') ? auth.offsetHeight : 0;
            const gap = 8;
            const topH = (header ? header.offsetHeight : 70) + bannerH + authH + gap;
            const bottomGap = 8;
            const bottomH = (bottom ? bottom.offsetHeight : 90) + bottomGap;
            content.style.paddingTop = topH + 'px';
            content.style.scrollPaddingTop = topH + 'px';
            content.style.paddingBottom = bottomH + 'px';
            content.style.scrollPaddingBottom = bottomH + 'px';
            if (banner && header) banner.style.top = header.offsetHeight + 'px';
            if (auth && header) auth.style.top = (header.offsetHeight + (bannerH || 0)) + 'px';
        }

        function positionDashboardPrivacyButton() {
            const btn = document.getElementById('dashboardPrivacyToggleBtn');
            if (!btn || !btn.parentElement) return;
            const cards = btn.parentElement.querySelectorAll('div > .stat-card');
            if (!cards || cards.length < 4) return;
            const r1 = cards[0].getBoundingClientRect();
            const r2 = cards[1].getBoundingClientRect();
            const r3 = cards[2].getBoundingClientRect();
            const r4 = cards[3].getBoundingClientRect();
            const topRowBottom = Math.max(r1.bottom, r2.bottom);
            const secondRowTop = Math.min(r3.top, r4.top);
            const y = (topRowBottom + secondRowTop) / 2;
            const leftColRight = Math.max(r1.right, r3.right);
            const rightColLeft = Math.min(r2.left, r4.left);
            const x = (leftColRight + rightColLeft) / 2;
            const containerRect = btn.parentElement.getBoundingClientRect();
            btn.style.top = (y - containerRect.top) + 'px';
            btn.style.left = (x - containerRect.left) + 'px';
            btn.style.transform = 'translate(-50%, -50%)';
        }
        window.addEventListener('resize', () => { if (state.activeTab === 'dashboard') { try { positionDashboardPrivacyButton(); } catch { } } });

        function runFormattingTests() {
            const cases = [1000, 999999, 999999999, 0, -12345];
            let passed = 0;
            cases.forEach(n => {
                const s = formatMoney(n);
                const back = parseMoney(s);
                if (Math.round(back) === Math.round(n)) passed++;
            });
            showToast(`Formatting tests: ${passed}/${cases.length} passed`, passed === cases.length ? 'success' : 'error');
        }
        async function runTargetSyncTests() {
            if (!syncEnabled || !currentUser) { showToast('Sign in to run sync tests', 'info'); return; }
            const val = Math.floor(Math.random() * 1000000);
            await upsertOne('settings', { daily_target: val });
            const ok = await verifyCloudSettings('daily_target', val);
            showToast(`Cloud verify daily_target: ${ok ? 'OK' : 'FAIL'}`, ok ? 'success' : 'error');
        }

        // Side Navigation Functions
        function toggleSideNav() {
            try { hapticShort(); } catch (e) { }
            const sideNav = document.getElementById('sideNav');
            const overlay = document.getElementById('sideNavOverlay');
            const body = document.body;

            sideNav.classList.toggle('open');
            overlay.classList.toggle('show');
            body.classList.toggle('nav-open');

            try { updateSideNavSoundButton(); } catch (e) { }
            try { updateSideNavThemeButton(); } catch (e) { }
            try { updateSideNavActiveState(); } catch (e) { }
        }

        function navigateToTab(tabId) {
            switchTab(tabId);
            toggleSideNav();
        }

        function updateSideNavActiveState() {
            const items = document.querySelectorAll('.side-nav-item');
            items.forEach(item => {
                item.classList.remove('active');
            });

            const activeItem = Array.from(items).find(item => {
                const onclick = item.getAttribute('onclick');
                return onclick && onclick.includes(`'${state.activeTab}'`);
            });

            if (activeItem) {
                activeItem.classList.add('active');
            }
        }

        // Initialize
        (function () {
            function wait(ms) { return new Promise(r => setTimeout(r, ms)); }
            async function ensureSupabaseThenInit() {
                try {
                    if (window.supabase && window.supabase.createClient) {
                        initSupabase();
                        try { window.setAuthRestoring(true); } catch { }
                        try { await restoreSession(); } catch { }
                        try { await maybeAutoPullCloudData(); } catch { }
                        try { window.setAuthRestoring(false); } catch { }
                        return;
                    }
                    let tries = 0;
                    while (tries < 60) {
                        await wait(50);
                        if (window.supabase && window.supabase.createClient) {
                            initSupabase();
                            try { window.setAuthRestoring(true); } catch { }
                            try { await restoreSession(); } catch { }
                            try { await maybeAutoPullCloudData(); } catch { }
                            try { window.setAuthRestoring(false); } catch { }
                            return;
                        }
                        tries++;
                    }
                } catch { }
            }
            ensureSupabaseThenInit();
            window.addEventListener('online', async () => {
                try { if (!supabase && window.supabase && window.supabase.createClient) initSupabase(); } catch { }
                try { window.setAuthRestoring(true); } catch { }
                try { await restoreSession(); } catch { }
                try { await maybeAutoPullCloudData(); } catch { }
                try { window.setAuthRestoring(false); } catch { }
            });
        })();

        // ============================================
        // TUBA SWIPE NAVIGATION v2.0
        // Enables left/right swipe with smooth transitions
        // ============================================

        (function () {
            console.log(' Initializing smooth swipe navigation...');

            let touchStartX = 0;
            let touchEndX = 0;
            let touchStartY = 0;
            let touchEndY = 0;
            let isSwiping = false;
            const SWIPE_THRESHOLD = 80; // Minimum swipe distance in pixels
            const VERTICAL_THRESHOLD = 50; // Maximum vertical movement to count as horizontal swipe

            // Add smooth transition CSS
            const style = document.createElement('style');
            style.textContent = `
                .content {
                    transition: opacity 0.3s ease, transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                }
                
                .content.swipe-exit-left {
                    opacity: 0;
                    transform: translateX(-30px);
                }
                
                .content.swipe-exit-right {
                    opacity: 0;
                    transform: translateX(30px);
                }
                
                .content.swipe-enter-left {
                    opacity: 0;
                    transform: translateX(30px);
                }
                
                .content.swipe-enter-right {
                    opacity: 0;
                    transform: translateX(-30px);
                }
                
                .content.swipe-active {
                    opacity: 1;
                    transform: translateX(0);
                }
                
                /* Smooth bottom nav highlight */
                .bottom-nav {
                    transition: all 0.3s ease;
                }
                
                .nav-item {
                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                }
                
                .nav-item.active {
                    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                }
            `;
            document.head.appendChild(style);

            // Get tab order from tabs array
            const tabOrder = tabs.map(t => t.id);

            function getCurrentTabIndex() {
                return tabOrder.indexOf(state.activeTab);
            }

            function switchToTabByIndexWithAnimation(index, direction) {
                if (index < 0 || index >= tabOrder.length || isSwiping) {
                    return;
                }

                isSwiping = true;
                const newTab = tabOrder[index];
                const content = document.querySelector('.content');

                if (!content) {
                    switchTab(newTab);
                    isSwiping = false;
                    return;
                }

                // Exit animation
                content.classList.remove('swipe-active', 'swipe-enter-left', 'swipe-enter-right');
                content.classList.add(direction === 'left' ? 'swipe-exit-left' : 'swipe-exit-right');

                // Switch tab after exit animation starts
                setTimeout(() => {
                    state.activeTab = newTab;
                    render();

                    // Enter animation
                    const newContent = document.querySelector('.content');
                    if (newContent) {
                        newContent.classList.remove('swipe-active');
                        newContent.classList.add(direction === 'left' ? 'swipe-enter-right' : 'swipe-enter-left');

                        // Force reflow
                        void newContent.offsetWidth;

                        // Activate
                        requestAnimationFrame(() => {
                            newContent.classList.remove('swipe-enter-left', 'swipe-enter-right');
                            newContent.classList.add('swipe-active');

                            setTimeout(() => {
                                isSwiping = false;
                            }, 300);
                        });
                    } else {
                        isSwiping = false;
                    }
                }, 150);

                console.log(` Smooth swipe to: ${newTab}`);
            }

            function handleSwipe() {
                const swipeDistanceX = touchEndX - touchStartX;
                const swipeDistanceY = Math.abs(touchEndY - touchStartY);

                // Check if it's a horizontal swipe (not vertical)
                if (swipeDistanceY > VERTICAL_THRESHOLD) {
                    return;
                }

                const currentIndex = getCurrentTabIndex();

                if (swipeDistanceX > SWIPE_THRESHOLD) {
                    // Swipe right - go to previous tab
                    console.log(' Swipe right detected');
                    switchToTabByIndexWithAnimation(currentIndex - 1, 'right');
                } else if (swipeDistanceX < -SWIPE_THRESHOLD) {
                    // Swipe left - go to next tab
                    console.log(' Swipe left detected');
                    switchToTabByIndexWithAnimation(currentIndex + 1, 'left');
                }
            }

            // Add touch event listeners to the main content area
            const app = document.getElementById('app');
            if (!app) {
                console.error(' App element not found');
                return;
            }

            app.addEventListener('touchstart', (e) => {
                if (isSwiping) return;
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            app.addEventListener('touchend', (e) => {
                if (isSwiping) return;
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            }, { passive: true });

            // Initialize content with active class
            setTimeout(() => {
                const content = document.querySelector('.content');
                if (content) {
                    content.classList.add('swipe-active');
                }
            }, 100);

            console.log(' Smooth swipe navigation initialized!');
            console.log('    Swipe left = Next tab (smooth)');
            console.log('    Swipe right = Previous tab (smooth)');
            console.log(`    Tab order: ${tabOrder.join('  ')}`);
        })();

        updateHeaderDate();

        // Load local data IMMEDIATELY - don't wait
        console.log(' Loading local data...');
        loadData();
        try { applyTheme(); } catch (e) { }
        try { render(); } catch (e) { }
        setTimeout(() => { try { ensureIDs(); normalizeLegacyBulkTimestamps(); saveData(); } catch { } }, 0);
        // Delay initial render until after session restore attempt
        (function setupBottomNavFastClick() {
            const nav = document.getElementById('bottomNav');
            if (!nav || nav.__fastSetup) return;
            nav.__fastSetup = true;
            const handler = (e) => {
                const btn = e.target && e.target.closest && e.target.closest('.nav-item');
                if (!btn) return;
                e.preventDefault();
                const tabId = btn.getAttribute('data-tab');
                if (!tabId) return;
                try { switchTab(tabId); } catch { }
            };
            nav.addEventListener('touchstart', handler, { passive: false });
            nav.addEventListener('pointerdown', handler, true);
        })();
        try { setupKeyboardDismiss(); } catch (e) { }



        // Update header date every second
        setInterval(() => {
            updateHeaderDate();
        }, 1000);

        // Auto-save every 15 seconds
        setInterval(() => {
            saveData();
        }, 15000);

        // PWA Manifest (find this section and replace it)
        const manifestData = {
            "name": "TUBA - The Ultimate Business Architecture",
            "short_name": "TUBA",
            "start_url": ".",
            "display": "standalone",
            "background_color": "#000000",
            "theme_color": "#000000",
            "description": "Complete business management solution",
            "icons": [
                {
                    "src": "tuba-icon.png",
                    "sizes": "192x192",
                    "type": "image/png"
                },
                {
                    "src": "tuba-icon.png",
                    "sizes": "512x512",
                    "type": "image/png",
                    "purpose": "any maskable"
                }
            ]
        };

        const manifestBlob = new Blob([JSON.stringify(manifestData)], { type: 'application/json' });
        const manifestURL = URL.createObjectURL(manifestBlob);
        document.querySelector('link[rel="manifest"]').setAttribute('href', manifestURL);

        // ============================================
        // TUBA SALES ENHANCEMENT PATCH v1.0
        // Added: Dynamic Product & Category Creation
        // ============================================

        // Store original renderSales function
        const originalRenderSales = window.renderSales;

        // Override renderSales function
        window.renderSales = function () {
            const stats = getStats();

            // Filter sales based on search and filters
            let filteredSales = state.sales.slice();

            if (state.searchPeriod) {
                const Period = state.searchPeriod.toLowerCase();
                filteredSales = filteredSales.filter(s =>
                    s.productName.toLowerCase().includes(Period) ||
                    s.customer.toLowerCase().includes(Period) ||
                    s.payment.toLowerCase().includes(Period)
                );
            }

            if (state.filterDateFrom) {
                filteredSales = filteredSales.filter(s => new Date(s.date) >= new Date(state.filterDateFrom));
            }

            if (state.filterDateTo) {
                filteredSales = filteredSales.filter(s => new Date(s.date) <= new Date(state.filterDateTo));
            }

            if (state.filterCustomer) {
                filteredSales = filteredSales.filter(s => s.customer === state.filterCustomer);
            }

            return `
        <div class="privacy-container">
            <button class="privacy-toggle-btn show" id="privacyToggleBtn" onclick="togglePrivacy()">
                ${state.privacyBlurred ? '' : ''}
            </button>

        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">TOTAL CAPITAL</div>
                <div class="stat-value" style="font-size: 16px;"> ${formatNumber(stats.totalCapital)} Tsh</div>
            </div>
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">TOTAL PROFIT</div>
                <div class="stat-value" style="font-size: 16px;"> ${formatNumber(stats.totalProfit)} Tsh</div>
            </div>
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">TODAY'S PROFIT</div>
                <div class="stat-value" style="font-size: 16px;"> ${formatNumber(stats.todayProfit)} Tsh</div>
            </div>
            <div class="stat-card ${state.privacyBlurred ? 'privacy-blur' : ''}" style="padding: 12px;">
                <div class="stat-label" style="font-size: 10px;">10% TODAY</div>
                <div class="stat-value" style="font-size: 16px;"> ${formatNumber(stats.todayProfit * 0.1)} Tsh</div>
            </div>
        </div>
    </div>
</div>

        <div class="card">
            <h2>Add Sale</h2>
            <div class="card-header-buttons">
                <button class="save-offline-btn" onclick="exportData('Saved', 2000)">
                    <span>Click to save records for offline</span>
                </button>
            </div>
            <form onsubmit="addSale(event)">
                <div class="form-group">
                    <label>Product</label>
                    <select id="saleProduct" onchange="handleProductSelection()" required>
                        <option value="">-- Select Product --</option>
                        <option class="opt-new" value="new">+ Add New Product</option>
                        ${(() => {
                    const recentNames = [];
                    const seen = new Set();
                    (state.sales || []).slice().sort((a, b) => b.timestamp - a.timestamp).forEach(s => {
                        if (!seen.has(s.productName)) { recentNames.push(s.productName); seen.add(s.productName); }
                    });
                    const prioritized = recentNames.slice(0, 3);
                    const entries = state.products.map((p, i) => ({ p, i }));
                    const prioritizedEntries = entries.filter(e => prioritized.includes(e.p.name));
                    const restEntries = entries.filter(e => !prioritized.includes(e.p.name)).sort((a, b) => String(a.p.name).localeCompare(String(b.p.name)));
                    const merged = [...prioritizedEntries, ...restEntries];
                    return merged.map(({ p, i }) => {
                        const stockVal = (state.inventory[p.name] || { stock: 0 }).stock;
                        const label = (p.hasStock === false)
                            ? `${p.name} - ${p.category}`
                            : `${p.name} - ${p.category} (Stock: ${stockVal})`;
                        return `<option value="${i}">${label}</option>`;
                    }).join('');
                })()}
                    </select>
                </div>
                
                <div id="newProductFields" style="display:none;">
                    <div class="form-group bulk-row" style="display:flex; gap:8px; align-items:end;">
                        <div style="flex:1;">
                            <label>Item Type</label>
                            <select id="newProductType" onchange="toggleNewProductType()">
                                <option value="product" selected>Product (has stock)</option>
                                <option value="service">Service (no stock)</option>
                            </select>
                        </div>
                        <div style="flex:2;">
                            <label>New Product Name</label>
                            <input type="text" id="newProductName" placeholder="Enter product name">
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Category</label>
                        <select id="newProductCategory" onchange="handleCategorySelection()">
                            <option value="">-- Select Category --</option>
                            <option class="opt-new" value="new">+ Add New Category</option>
                            ${state.categories.slice().sort((a, b) => String(a).localeCompare(String(b))).map(c => `<option value="${c}">${c}</option>`).join('')}
                        </select>
                    </div>
                    
                    <div id="newCategoryField" style="display:none;">
                        <div class="form-group">
                            <label>New Category Name</label>
                            <input type="text" id="newCategoryName" placeholder="Enter category name">
                        </div>
                    </div>

                    
                    
                    <div class="form-group" id="newProductStockGroup">
                        <label>Cost (Capital)</label>
                        <input type="text" id="newProductCost" class="money-input" placeholder="0">
                    </div>
                    <div class="form-group">
                        <label>Price (Selling)</label>
                        <input type="text" id="newProductPrice" class="money-input" placeholder="0">
                    </div>
                    <div class="form-group" id="newProductInitialStockGroup">
                        <label>Initial Stock</label>
                        <input type="text" id="newProductStock" class="money-input" placeholder="0" value="0">
                    </div>
                    <button type="button" class="btn-success" onclick="saveNewProductFromSales()" style="margin-bottom: 12px;">
                         Save New Product
                    </button>
                    <button type="button" class="btn-secondary" onclick="cancelNewProduct()" style="margin-bottom: 12px;">
                         Cancel
                    </button>
                </div>

                <div class="form-group">
                    <label>Customer</label>
                    <select id="saleCustomer" onchange="toggleCustomerInput()">
                        <option value="">-- Walk-in --</option>
                        ${state.customers.map((c, i) => `<option value="${i}">${c.name}</option>`).join('')}
                        <option value="new">+ Add New Customer</option>
                    </select>
                </div>
                <div id="newCustomerFields" style="display:none;">
                    <div class="form-group">
                        <label>New Customer Name</label>
                        <input type="text" id="newCustomerName" placeholder="Enter customer name">
                    </div>
                    <div class="form-group">
                        <label>Phone (Optional)</label>
                        <input type="tel" id="newCustomerPhone" placeholder="+255...">
                    </div>
                </div>
                <div class="form-group">
                    <label>Quantity</label>
                    <input type="text" id="saleQuantity" class="money-input" value="1" onchange="updateSaleTotal()" required>
                </div>
                <div class="form-group">
                    <label>Payment Method</label>
                    <select id="salePayment">
                        <option>Cash</option>
                        <option>Card</option>
                        <option>Mobile Money</option>
                        <option>M-Pesa Lipa Number</option>
                        <option>Bank Transfer</option>
                    </select>
                </div>
                <div id="saleInfo"></div>
                <button type="submit">Record Sale</button>
            </form>
        </div>

        <div class="card">
            <h2>Recent Sales (${filteredSales.length})</h2>
            
            <div class="search-box">
                <input type="text" placeholder=" Search sales..." oninput="updateSearchPeriod(this.value)">
            </div>

            <div class="filter-row">
                <div class="form-group">
                    <label>From...</label>
                    <input type="date" onchange="updateFilterDateFrom(this.value)" value="${state.filterDateFrom || ''}" placeholder="mm/dd/yyyy">
                </div>
                <div class="form-group">
                    <label>To...</label>
                    <input type="date" onchange="updateFilterDateTo(this.value)" value="${state.filterDateTo || ''}" placeholder="mm/dd/yyyy">
                </div>
                <div class="form-group">
                    <label>Customer</label>
                    <select onchange="updateFilterCustomer(this.value)">
                        <option value="">All Customers</option>
                        ${[...new Set(state.sales.map(s => s.customer))].map(c =>
                    `<option value="${c}" ${state.filterCustomer === c ? 'selected' : ''}>${c}</option>`
                ).join('')}
                    </select>
                </div>
                <button class="btn-small btn-secondary" onclick="clearFilters()">Clear</button>
            </div>

            ${(() => {
                    const arr = filteredSales.slice().reverse();
                    const count = (state.listShowCount && state.listShowCount.sales) ? state.listShowCount.sales : 3;
                    const bulk = (state.searchPeriod || state.filterDateFrom || state.filterDateTo || state.filterCustomer) ? `
                <div class="bulk-actions">
                    <input type="checkbox" id="selectAll_sales" onchange="toggleSelectAll('sales')" class="checkbox-select">
                    <label for="selectAll_sales">Select All</label>
                    <span style="color: #666; font-size: 12px; margin-left: 8px;">${getSelectedCount('sales')} selected</span>
                    <button class="btn-small btn-danger" onclick="bulkDelete('sales')" ${!hasSelected('sales') ? 'disabled' : ''}> Delete Selected</button>
                </div>` : '';
                    const items = arr.slice(0, count).map((s) => `
                    <div class="item">
                        <div style="display: flex; gap: 12px; align-items: start;">
                            <input type="checkbox" class="checkbox-select" ${state.selectedItems.sales && state.selectedItems.sales[s.id] ? 'checked' : ''} onchange="toggleSelect('sales', '${s.id}')">
                            <div style="flex: 1;">
                                <div class="item-header">
                                    <span class="item-title">${s.productName}</span>
                                    <span style="color: #2e7d32; font-weight: 700;"> ${formatNumber(s.profit)} Tsh</span>
                                </div>
                                <div class="item-subtitle">
                                    ${s.date} ${s.time}<br>
                                    ${s.customer} | Qty: ${s.quantity} | ${s.payment}<br>
                                    Cost: ${formatNumber(s.totalCost)} | Price: ${formatNumber(s.totalPrice)}
                                </div>
                                <div class="flex-gap" style="margin-top:8px;">
                                    <button class="btn-small" style="background: linear-gradient(145deg, #ffeb3b, #fbc02d); color: #333;" onclick="downloadSaleReceiptPDF(${s.timestamp})"> Receipt</button>
                                    <button class="btn-small" onclick="editSaleByTimestamp(${s.timestamp})">Edit</button>
                                    <button class="btn-small btn-danger" onclick="deleteSaleByTimestamp(${s.timestamp})">Delete</button>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('') || '<p style="text-align: center; color: #666;">No sales found</p>';
                    const total = arr.length;
                    const hasMore = count < total;
                    const moreBtn = `<button class="collapse-btn" onclick="${hasMore ? `showMoreList('sales')` : `collapseList('sales')`}"><span class="collapse-icon ${hasMore ? '' : 'expanded'}"></span><span>${hasMore ? 'See more' : 'Hide'}</span></button>`;
                    return bulk + items + moreBtn;
                })()}
        </div>
    `;
        };

        // New function: Handle product selection
        window.handleProductSelection = function () {
            const select = document.getElementById('saleProduct');
            const newFields = document.getElementById('newProductFields');

            if (select && newFields) {
                if (select.value === 'new') {
                    newFields.style.display = 'block';
                    // Clear previous inputs
                    document.getElementById('newProductName').value = '';
                    document.getElementById('newProductCategory').value = '';
                    document.getElementById('newCategoryName').value = '';
                    document.getElementById('newProductCost').value = '';
                    document.getElementById('newProductPrice').value = '';
                    document.getElementById('newProductStock').value = '0';
                    document.getElementById('newCategoryField').style.display = 'none';
                    const typeEl = document.getElementById('newProductType');
                    const stockGroup = document.getElementById('newProductInitialStockGroup');
                    if (typeEl && stockGroup) { typeEl.value = 'product'; stockGroup.style.display = 'block'; }
                } else {
                    newFields.style.display = 'none';
                    updateSaleTotal();
                }
            }
        };

        // New function: Handle category selection in new product form
        window.handleCategorySelection = function () {
            const select = document.getElementById('newProductCategory');
            const newCategoryField = document.getElementById('newCategoryField');

            if (select && newCategoryField) {
                if (select.value === 'new') {
                    newCategoryField.style.display = 'block';
                    document.getElementById('newCategoryName').value = '';
                } else {
                    newCategoryField.style.display = 'none';
                }
            }
        };

        // Toggle initial stock visibility based on hasStock checkbox
        window.toggleNewProductType = function () {
            const typeEl = document.getElementById('newProductType');
            const stockGroup = document.getElementById('newProductInitialStockGroup');
            if (typeEl && stockGroup) {
                stockGroup.style.display = (typeEl.value === 'service') ? 'none' : 'block';
            }
        };

        // New function: Save new product from sales form
        window.saveNewProductFromSales = async function () {
            const nameRaw = document.getElementById('newProductName').value.trim();
            const name = capitalizeFirstWordValue(nameRaw);
            let categorySelect = document.getElementById('newProductCategory').value;
            if (typeof categorySelect === 'string') categorySelect = categorySelect.trim();
            const newCategoryNameRaw = document.getElementById('newCategoryName').value.trim();
            const newCategoryName = capitalizeFirstWordValue(newCategoryNameRaw);
            const cost = parseMoney(document.getElementById('newProductCost').value);
            const price = parseMoney(document.getElementById('newProductPrice').value);
            const typeEl = document.getElementById('newProductType');
            const hasStock = (typeEl?.value !== 'service');
            const stock = hasStock ? (parseMoney(document.getElementById('newProductStock').value) || 0) : 0;

            // Validation
            if (!name) {
                return showToast('Please enter product name', 'error');
            }

            let category;
            if (categorySelect === 'new') {
                if (!newCategoryName) {
                    return showToast('Please enter category name', 'error');
                }
                // Check if category already exists
                if (state.categories.includes(newCategoryName)) {
                    category = newCategoryName;
                    showToast('Category already exists, using existing one', 'info');
                } else {
                    // Add new category
                    state.categories.push(newCategoryName);
                    category = newCategoryName;
                    showToast('New category added!', 'success');
                }
            } else {
                if (!categorySelect) {
                    return showToast('Please select or create a category', 'error');
                }
                category = capitalizeFirstWordValue(categorySelect);
            }

            if (isNaN(cost) || cost < 0) {
                return showToast('Please enter a valid cost', 'error');
            }

            if (isNaN(price) || price < 0) {
                return showToast('Please enter a valid price', 'error');
            }

            if (price < cost) {
                if (!confirm('Warning: Selling price is less than cost. Continue?')) {
                    return;
                }
            }

            // Check if product already exists
            if (state.products.some(p => p.name.toLowerCase() === name.toLowerCase())) {
                return showToast('Product already exists', 'error');
            }

            // Create new product
            const product = {
                id: generateID('products'),
                name,
                category,
                cost,
                price,
                hasStock: hasStock ? true : false
            };
            state.products.push(product);

            // Initialize inventory
            if (!state.inventory) {
                state.inventory = {};
            }
            if (hasStock) {
                state.inventory[name] = {
                    stock: stock,
                    minAlert: 5
                };
            }

            saveData();

            if (syncEnabled) {
                await upsertOne('products', { name, category, cost, price, has_stock: hasStock ? true : false });
                if (hasStock) {
                    await upsertOne('inventory', { product_name: name, stock: stock, min_alert: 5 });
                }
                if (category) {
                    await upsertOne('categories', { name: category });
                }
                syncInBackground();
            }

            // Auto-select the new product
            const productSelect = document.getElementById('saleProduct');
            const newProductIndex = state.products.length - 1;

            // Re-render to show new product in list
            render();

            // After re-render, select the new product
            setTimeout(() => {
                const updatedSelect = document.getElementById('saleProduct');
                if (updatedSelect) {
                    updatedSelect.value = newProductIndex;
                    updateSaleTotal();
                }
            }, 100);

            showToast(' Product added successfully!', 'success');
        };

        // New function: Cancel new product creation
        window.cancelNewProduct = function () {
            document.getElementById('saleProduct').value = '';
            document.getElementById('newProductFields').style.display = 'none';
            document.getElementById('saleInfo').innerHTML = '';
        };

        console.log(' TUBA Sales Enhancement Patch loaded successfully!');
        // END OF PATCH


        // ============================================
        // TUBA COMPLETE ENHANCEMENT v2.0
        // ============================================

        console.log(' Loading TUBA enhancements...');

        // ============================================
        // FIX 1: Deterministic ID Generation
        // ============================================

        function generateDeterministicID(type, item) {
            let hashBase = '';

            switch (type) {
                case 'sales':
                    hashBase = `${item.productName}|${item.customer}|${item.timestamp || Date.now()}`;
                    break;
                case 'products':
                    hashBase = `${item.name}|${item.category}|${item.cost}|${item.price}`;
                    break;
                case 'expenses':
                    hashBase = `${item.description}|${item.category}|${item.timestamp || Date.now()}`;
                    break;
                case 'customers':
                    hashBase = `${item.name}|${item.email || ''}|${item.phone || ''}`;
                    break;
                case 'transactions':
                    hashBase = `${item.channel}|${item.type}|${item.timestamp || Date.now()}`;
                    break;
                case 'unpaid':
                    hashBase = `${item.name}|${item.type}|${item.timestamp || Date.now()}`;
                    break;
                case 'notes':
                    hashBase = `${item.content.substring(0, 50)}|${item.timestamp || Date.now()}`;
                    break;
                default:
                    hashBase = JSON.stringify(item);
            }

            let hash = 0;
            for (let i = 0; i < hashBase.length; i++) {
                const char = hashBase.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }

            const prefix = {
                'sales': 'S',
                'products': 'P',
                'expenses': 'E',
                'customers': 'C',
                'transactions': 'T',
                'unpaid': 'U',
                'notes': 'N'
            }[type] || 'X';

            return `${prefix}-${Math.abs(hash).toString(36).toUpperCase()}`;
        }

        function generateIDSafe(type, item = null) {
            if (item && typeof item === 'object') {
                return generateDeterministicID(type, item);
            }
            return generateID(type);
        }

        // ============================================
        // FIX 2: Content-Based Deduplication
        // ============================================

        function deduplicateByContent(items, type) {
            if (!Array.isArray(items) || items.length === 0) return items;

            const uniqueMap = new Map();

            items.forEach(item => {
                let contentKey;

                switch (type) {
                    case 'sales':
                        contentKey = `${item.productName}|${item.customer}|${item.date}|${item.time}|${item.quantity}|${item.totalPrice}`;
                        break;
                    case 'products':
                        contentKey = `${(item.name || '').trim()}|${(item.category || '').trim()}`;
                        break;
                    case 'expenses':
                        contentKey = `${item.description}|${item.date}|${item.time}|${item.amount}`;
                        break;
                    case 'customers':
                        contentKey = `${item.name}|${item.email || ''}|${item.phone || ''}`;
                        break;
                    case 'transactions':
                        contentKey = `${item.channel}|${item.date}|${item.time}|${item.amount}|${item.type}`;
                        break;
                    case 'unpaid':
                        contentKey = `${item.name}|${item.type}|${item.date}|${item.amount}`;
                        break;
                    case 'notes':
                        contentKey = `${item.content}|${item.date}|${item.time}`;
                        break;
                    default:
                        contentKey = JSON.stringify(item);
                }

                if (!uniqueMap.has(contentKey)) {
                    if (!item.id) {
                        item.id = generateDeterministicID(type, item);
                    }
                    uniqueMap.set(contentKey, item);
                } else {
                    const existing = uniqueMap.get(contentKey);
                    const merged = { ...existing, ...item };
                    merged.id = existing.id;
                    uniqueMap.set(contentKey, merged);
                }
            });

            return Array.from(uniqueMap.values());
        }

        // ============================================
        // FIX 3: Improved Smart Merge
        // ============================================

        async function smartMergeDataFixed() {
            try {
                updateSyncIndicator('syncing');
                showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);
                console.log(' Starting smart merge with duplicate prevention...');

                const localData = {
                    sales: [...(state.sales || [])],
                    products: [...(state.products || [])],
                    expenses: [...(state.expenses || [])],
                    customers: [...(state.customers || [])],
                    transactions: [...(state.transactions || [])],
                    unpaidEntries: [...(state.unpaidEntries || [])],
                    notes: [...(state.notes || [])]
                };

                console.log(' Local data backed up');

                const cloudData = {
                    sales: [],
                    products: [],
                    expenses: [],
                    customers: [],
                    transactions: [],
                    unpaidEntries: [],
                    notes: []
                };

                try {
                    const { data: products } = await supabase
                        .from('products')
                        .select('*')
                        .eq('user_id', currentUser.id);
                    if (products) {
                        cloudData.products = products.map(p => ({
                            name: p.name,
                            category: p.category,
                            cost: parseFloat(p.cost),
                            price: parseFloat(p.price),
                            hasStock: (p.has_stock === false) ? false : true
                        }));
                    }

                    const { data: sales } = await supabase
                        .from('sales')
                        .select('*')
                        .eq('user_id', currentUser.id)
                        .order('timestamp', { ascending: false });
                    if (sales) {
                        cloudData.sales = sales.map(s => ({
                            date: s.date,
                            time: s.time,
                            timestamp: s.timestamp,
                            productName: s.product_name,
                            customer: s.customer,
                            quantity: s.quantity,
                            costPerUnit: parseFloat(s.cost_per_unit),
                            pricePerUnit: parseFloat(s.price_per_unit),
                            totalCost: parseFloat(s.total_cost),
                            totalPrice: parseFloat(s.total_price),
                            profit: parseFloat(s.profit),
                            payment: s.payment
                        }));
                    }

                    const { data: expenses } = await supabase
                        .from('expenses')
                        .select('*')
                        .eq('user_id', currentUser.id);
                    if (expenses) {
                        cloudData.expenses = expenses.map(e => ({
                            date: e.date,
                            time: e.time,
                            timestamp: e.timestamp,
                            description: e.description,
                            category: e.category,
                            amount: parseFloat(e.amount),
                            payment: e.payment,
                            comment: e.comment
                        }));
                    }

                    const { data: customers } = await supabase
                        .from('customers')
                        .select('*')
                        .eq('user_id', currentUser.id);
                    if (customers) {
                        cloudData.customers = customers.map(c => ({
                            name: c.name,
                            email: c.email || '',
                            phone: c.phone || '',
                            address: c.address || '',
                            totalPurchases: parseFloat(c.total_purchases || 0)
                        }));
                    }

                    const { data: transactions } = await supabase
                        .from('transactions')
                        .select('*')
                        .eq('user_id', currentUser.id);
                    if (transactions) {
                        cloudData.transactions = transactions.map(t => ({
                            channel: t.channel,
                            customerName: t.customer_name,
                            type: t.type,
                            amount: parseFloat(t.amount),
                            date: t.date,
                            time: t.time,
                            timestamp: t.timestamp
                        }));
                    }

                    const { data: unpaidEntries } = await supabase
                        .from('unpaid_entries')
                        .select('*')
                        .eq('user_id', currentUser.id);
                    if (unpaidEntries) {
                        cloudData.unpaidEntries = unpaidEntries.map(u => ({
                            name: u.name,
                            type: u.type,
                            amount: parseFloat(u.amount),
                            date: u.date,
                            time: u.time,
                            timestamp: u.timestamp,
                            paid: u.paid
                        }));
                    }

                    const { data: notes } = await supabase
                        .from('notes')
                        .select('*')
                        .eq('user_id', currentUser.id);
                    if (notes) {
                        cloudData.notes = notes.map(n => ({
                            title: n.title || '',
                            content: n.content,
                            date: n.date,
                            time: n.time,
                            timestamp: n.timestamp
                        }));
                    }

                    console.log('  Cloud data fetched');

                } catch (fetchError) {
                    console.error('Error fetching cloud data:', fetchError);
                    throw fetchError;
                }

                console.log(' Merging data...');

                state.sales = [...localData.sales, ...cloudData.sales];
                state.products = [...localData.products, ...cloudData.products];
                state.expenses = [...localData.expenses, ...cloudData.expenses];
                state.customers = [...localData.customers, ...cloudData.customers];
                state.transactions = [...localData.transactions, ...cloudData.transactions];
                state.unpaidEntries = [...localData.unpaidEntries, ...cloudData.unpaidEntries];
                state.notes = [...localData.notes, ...cloudData.notes];

                state.sales = deduplicateByContent(state.sales, 'sales');
                state.products = deduplicateByContent(state.products, 'products');
                state.expenses = deduplicateByContent(state.expenses, 'expenses');
                state.customers = deduplicateByContent(state.customers, 'customers');
                state.transactions = deduplicateByContent(state.transactions, 'transactions');
                state.unpaidEntries = deduplicateByContent(state.unpaidEntries, 'unpaid');
                state.notes = deduplicateByContent(state.notes, 'notes');

                console.log(' Deduplication complete');
                console.log(` Final counts: ${state.sales.length} sales, ${state.products.length} products`);

                saveData();

                console.log('  Pushing merged data to cloud...');
                await clearAndPushAllData();

                updateSyncIndicator('synced');
                console.log(' Smart merge completed successfully');

            } catch (error) {
                console.error('Smart merge error:', error);
                updateSyncIndicator('synced');
                throw error;
            }
        }

        window.smartMergeData = smartMergeDataFixed;

        // ============================================
        // FIX 4: Sync Lock
        // ============================================

        let syncLock = false;

        async function syncInBackgroundSafe() {
            if (!syncEnabled || !currentUser) return;
            if (syncLock) {
                console.log('  Sync already in progress, skipping...');
                return;
            }

            syncLock = true;
            try {
                await clearAndPushAllData();
                console.log(' Background sync complete');
            } catch (error) {
                console.error(' Background sync error:', error);
            } finally {
                syncLock = false;
            }
        }

        window.syncInBackground = syncInBackgroundSafe;

        // ============================================
        // FIX 5: Manual Duplicate Cleaner
        // ============================================

        async function cleanAllDuplicates() {
            console.log(' Cleaning duplicates...');

            const beforeCounts = {
                sales: state.sales.length,
                products: state.products.length,
                expenses: state.expenses.length,
                customers: state.customers.length,
                transactions: state.transactions.length,
                unpaidEntries: state.unpaidEntries.length,
                notes: state.notes.length
            };

            state.sales = deduplicateByContent(state.sales, 'sales');
            state.products = deduplicateByContent(state.products, 'products');
            state.expenses = deduplicateByContent(state.expenses, 'expenses');
            state.customers = deduplicateByContent(state.customers, 'customers');
            state.transactions = deduplicateByContent(state.transactions, 'transactions');
            state.unpaidEntries = deduplicateByContent(state.unpaidEntries, 'unpaid');
            state.notes = deduplicateByContent(state.notes, 'notes');

            const afterCounts = {
                sales: state.sales.length,
                products: state.products.length,
                expenses: state.expenses.length,
                customers: state.customers.length,
                transactions: state.transactions.length,
                unpaidEntries: state.unpaidEntries.length,
                notes: state.notes.length
            };

            const removed = {
                sales: beforeCounts.sales - afterCounts.sales,
                products: beforeCounts.products - afterCounts.products,
                expenses: beforeCounts.expenses - afterCounts.expenses,
                customers: beforeCounts.customers - afterCounts.customers,
                transactions: beforeCounts.transactions - afterCounts.transactions,
                unpaidEntries: beforeCounts.unpaidEntries - afterCounts.unpaidEntries,
                notes: beforeCounts.notes - afterCounts.notes
            };

            const totalRemoved = Object.values(removed).reduce((a, b) => a + b, 0);

            console.log(' Duplicates removed:', removed);
            console.log(` Total duplicates removed: ${totalRemoved}`);

            saveData();

            if (syncEnabled && currentUser) {
                await clearAndPushAllData();
            }

            render();
            showToast(` Removed ${totalRemoved} duplicates!`, 'success');

            return { removed, totalRemoved };
        }

        window.cleanAllDuplicates = cleanAllDuplicates;

        // ============================================
        // FIX 6: Auto Duplicate Detection on Load
        // ============================================

        function detectDuplicatesOnLoad() {
            console.log(' Checking for duplicates on load...');

            const duplicateCounts = {
                sales: 0,
                products: 0,
                expenses: 0,
                customers: 0,
                transactions: 0,
                unpaidEntries: 0,
                notes: 0
            };

            // Check sales
            const salesMap = new Map();
            state.sales.forEach(s => {
                const key = `${s.productName}|${s.customer}|${s.date}|${s.time}`;
                if (salesMap.has(key)) duplicateCounts.sales++;
                salesMap.set(key, true);
            });

            // Check products
            const productsMap = new Map();
            state.products.forEach(p => {
                const key = `${p.name}|${p.category}`;
                if (productsMap.has(key)) duplicateCounts.products++;
                productsMap.set(key, true);
            });

            // Check expenses
            const expensesMap = new Map();
            state.expenses.forEach(e => {
                const key = `${e.description}|${e.date}|${e.time}`;
                if (expensesMap.has(key)) duplicateCounts.expenses++;
                expensesMap.set(key, true);
            });

            // Check customers
            const customersMap = new Map();
            state.customers.forEach(c => {
                const key = `${c.name}|${c.email || ''}`;
                if (customersMap.has(key)) duplicateCounts.customers++;
                customersMap.set(key, true);
            });

            // Check transactions
            const transactionsMap = new Map();
            state.transactions.forEach(t => {
                const key = `${t.channel}|${t.date}|${t.time}|${t.amount}`;
                if (transactionsMap.has(key)) duplicateCounts.transactions++;
                transactionsMap.set(key, true);
            });

            // Check unpaid
            const unpaidMap = new Map();
            state.unpaidEntries.forEach(u => {
                const key = `${u.name}|${u.type}|${u.date}`;
                if (unpaidMap.has(key)) duplicateCounts.unpaidEntries++;
                unpaidMap.set(key, true);
            });

            // Check notes
            const notesMap = new Map();
            state.notes.forEach(n => {
                const key = `${n.content}|${n.date}|${n.time}`;
                if (notesMap.has(key)) duplicateCounts.notes++;
                notesMap.set(key, true);
            });

            const totalDuplicates = Object.values(duplicateCounts).reduce((a, b) => a + b, 0);

            if (totalDuplicates > 0) {
                console.warn(`  Found ${totalDuplicates} potential duplicates!`, duplicateCounts);
                state.hasDuplicates = true;
                state.duplicateCounts = duplicateCounts;
            } else {
                console.log(' No duplicates detected');
                state.hasDuplicates = false;
                state.duplicateCounts = null;
            }

            return { hasDuplicates: totalDuplicates > 0, counts: duplicateCounts, total: totalDuplicates };
        }

        window.detectDuplicatesOnLoad = detectDuplicatesOnLoad;

        // ============================================
        // FIX 7: Enhanced Dashboard with Duplicate Alert
        // ============================================

        const originalRenderDashboard = window.renderDashboard;

        window.renderDashboard = function () {
            const dashboardHTML = originalRenderDashboard();

            // Check for duplicates
            const dupeCheck = detectDuplicatesOnLoad();

            if (dupeCheck.hasDuplicates) {
                const dupeAlert = `
                <div class="alert-box-danger" style="animation: highlightFade 2s ease-out;">
                    <strong>  Duplicate Data Detected!</strong><br>
                    Found ${dupeCheck.total} potential duplicates in your data.<br>
                    <div style="margin-top: 8px; font-size: 12px;">
                        Sales: ${dupeCheck.counts.sales} | 
                        Products: ${dupeCheck.counts.products} | 
                        Expenses: ${dupeCheck.counts.expenses} |
                        Customers: ${dupeCheck.counts.customers}
                    </div>
                    <button class="btn-danger" style="margin-top: 12px; width: 100%;" onclick="cleanDuplicatesFromUI()">
                         Clean All Duplicates Now
                    </button>
                </div>
            `;

                return dupeAlert + dashboardHTML;
            }

            return dashboardHTML;
        };

        // ============================================
        // FIX 8: Clean Duplicates UI Function
        // ============================================

        async function cleanDuplicatesFromUI() {
            playTapSound();
            hapticShort();
            if (!confirm('This will remove all duplicate entries. Continue?')) {
                return;
            }

            showToast(' Cleaning duplicates...', 'info');

            try {
                const result = await cleanAllDuplicates();

                if (result.totalRemoved > 0) {
                    showToast(` Removed ${result.totalRemoved} duplicates!`, 'success');
                } else {
                    showToast(' No duplicates found!', 'success');
                }
            } catch (error) {
                console.error('Error cleaning duplicates:', error);
                showToast(' Error cleaning duplicates', 'error');
            }
        }

        window.cleanDuplicatesFromUI = cleanDuplicatesFromUI;

        // ============================================
        // FIX 9: Update Side Nav with Clean Button
        // ============================================

        const sideNavCleanupItem = document.querySelector('.side-nav-item[onclick="openCleanupModal()"]');
        if (sideNavCleanupItem) {
            sideNavCleanupItem.setAttribute('onclick', 'cleanDuplicatesFromUI(); toggleSideNav();');
            sideNavCleanupItem.innerHTML = `
            <span class="side-nav-icon"></span>
            <span>Clean Duplicates</span>
        `;
        }

        // ============================================
        // FIX 10: Run Detection on First Load
        // ============================================

        setTimeout(() => {
            const dupeCheck = detectDuplicatesOnLoad();
            if (dupeCheck.hasDuplicates && state.activeTab === 'dashboard') {
                render();
            }
        }, 2000);

        console.log(' All TUBA enhancements loaded successfully!');
        console.log(' Available functions:');
        console.log('    cleanAllDuplicates() - Manual duplicate cleaning');
        console.log('    detectDuplicatesOnLoad() - Check for duplicates');
        console.log('    cleanDuplicatesFromUI() - UI-triggered cleaning');


        // ============================================
        // UI ENHANCEMENT FUNCTIONS
        // ============================================

        console.log(' Loading UI enhancements...');

        // Update side nav auth button based on login state
        function updateSideNavAuthButton() {
            const authButton = document.getElementById('sideNavAuthButton');
            const authIcon = document.getElementById('sideNavAuthIcon');
            const authText = document.getElementById('sideNavAuthText');

            if (!authButton || !authIcon || !authText) return;

            if (currentUser && syncEnabled) {
                // User is logged in
                authIcon.textContent = '';
                authText.textContent = 'Logout';
                authButton.style.background = 'linear-gradient(145deg, #d32f2f, #b71c1c)';
            } else {
                // User is logged out
                authIcon.textContent = '';
                authText.textContent = 'Login';
                authButton.style.background = 'linear-gradient(145deg, #2e7d32, #1b5e20)';
            }
        }

        // Handle side nav auth button click
        async function handleSideNavAuth() {
            // Double-check actual session to avoid UI desync
            let effectiveUser = null;
            try {
                const { data: { session } } = await supabase.auth.getSession();
                effectiveUser = session?.user || null;
            } catch { }

            if (effectiveUser && syncEnabled) {
                // User is logged in - logout
                if (confirm('Are you sure you want to logout?')) {
                    await signOut();
                    toggleSideNav();
                    showToast('Logged out successfully', 'info');
                }
            } else {
                // User is logged out - go to account tab
                switchTab('account');
                toggleSideNav();
            }
        }

        function updateSideNavSoundButton() {
            const btn = document.getElementById('sideNavSoundButton');
            const icon = document.getElementById('sideNavSoundIcon');
            const text = document.getElementById('sideNavSoundText');
            const headerIcon = document.getElementById('sideNavSoundHeaderIcon');
            if (!btn || !icon || !text) return;
            if (state.soundEnabled) {
                icon.textContent = '';
                text.textContent = 'Sound: On';
                btn.style.background = 'linear-gradient(145deg, #2e7d32, #1b5e20)';
                btn.style.color = 'white';
                if (headerIcon) headerIcon.textContent = '';
            } else {
                icon.textContent = '';
                text.textContent = 'Sound: Off';
                btn.style.background = 'linear-gradient(145deg, #9e9e9e, #616161)';
                btn.style.color = 'white';
                if (headerIcon) headerIcon.textContent = '';
            }
        }

        function updateSideNavThemeButton() {
            const headerIcon = document.getElementById('sideNavThemeHeaderIcon');
            if (headerIcon) headerIcon.textContent = (state.theme === 'dark' ? '' : '');
        }

        function applyTheme() {
            try {
                document.body.classList.toggle('theme-dark', state.theme === 'dark');
                updateSideNavThemeButton();
            } catch (e) { }
        }

        async function toggleTheme() {
            state.theme = (state.theme === 'dark') ? 'light' : 'dark';
            saveData();
            applyTheme();
            showToast(state.theme === 'dark' ? 'Dark mode enabled' : 'Light mode enabled', 'info');
            try {
                if (syncEnabled && currentUser && supabase && supabase.auth) {
                    await supabase.auth.updateUser({ data: { theme: state.theme } });
                }
            } catch (e) { /* no-op */ }
        }

        function setupKeyboardDismiss() {
            if (window.__keyboardDismissSetup) return;
            window.__keyboardDismissSetup = true;
            const isInputEl = el => el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.tagName === 'SELECT' || el.isContentEditable);
            const isInteractiveTarget = el => !!(el && el.closest('input, textarea, select, .search-box, .money-input, .filter-row, .form-group, .modal-content'));
            const rememberCaret = el => { try { const s = el.selectionStart; const e = el.selectionEnd; el.__caret = { s, e }; } catch { } };
            const restoreCaret = el => { try { if (el.__caret && el.setSelectionRange) el.setSelectionRange(el.__caret.s, el.__caret.e); } catch { } };
            document.addEventListener('focusin', e => { const el = e.target; if (isInputEl(el)) restoreCaret(el); }, true);
            document.addEventListener('blur', e => { const el = e.target; if (isInputEl(el)) rememberCaret(el); }, true);
            const handler = e => {
                const active = document.activeElement;
                if (!active || !isInputEl(active)) return;
                if (isInteractiveTarget(e.target)) return;
                rememberCaret(active);
                try { active.blur(); } catch { }
                try { document.getElementById('hiddenFocusTarget')?.focus(); } catch { }
            };
            document.addEventListener('pointerdown', handler, true);
            document.addEventListener('touchstart', handler, true);
            document.addEventListener('mousedown', handler, true);
        }

        function toggleSoundNotifications() {
            state.soundEnabled = !state.soundEnabled;
            saveData();
            updateSideNavSoundButton();
            showToast(state.soundEnabled ? 'Sound notifications enabled' : 'Sound notifications disabled', 'info');
        }

        // Override the original render to update auth button
        const originalRender = window.render;
        window.render = function () {
            originalRender();
            updateSideNavAuthButton();
            // Auto-submit login if autofill populated credentials
            if (state.activeTab === 'account' && !currentUser) {
                try { autoSubmitLoginIfAutofilled(); } catch (e) { /* no-op */ }
            }
        };

        // Override toggleSideNav to update button when opened
        const originalToggleSideNav = window.toggleSideNav;
        window.toggleSideNav = function () {
            originalToggleSideNav();
            setTimeout(updateSideNavAuthButton, 100);
        };

        // Update button on initial load
        setTimeout(updateSideNavAuthButton, 1000);

        // Enhanced renderDashboard with new quick actions

        window.renderDashboard = function () {
            let html = originalRenderDashboard();

            // Check if quick actions need updating (for older versions)
            if (!html.includes(' Invoices')) {
                const quickActionsRegex = /<div class="card">\s*<h2>Quick Actions<\/h2>\s*<div class="flex-gap">([\s\S]*?)<\/div>\s*<\/div>/;

                const newQuickActions = `<div class="card">
                    <h2>Quick Actions</h2>
                    <div class="flex-gap">
                        <button class="btn-success btn-small" onclick="switchTab('sales')"> New Sale</button>
                        <button class="btn-danger btn-small" onclick="switchTab('expenses')"> Add Expense</button>
                        <button class="btn-small" onclick="switchTab('products')"> Manage Products/Services</button>
                        <button class="btn-small" onclick="switchTab('transactions')"> Transactions</button>
                        <button class="btn-small" onclick="switchTab('inventoryPurchases')"> Inventory</button>
                        <button class="btn-small" onclick="switchTab('invoices')" style="background: linear-gradient(145deg, #1976d2, #0d47a1); color: white;"> Invoices</button>
                        <button class="btn-small" onclick="switchTab('notes')" style="background: linear-gradient(145deg, #e65100, #bf360c); color: white;"> Notes</button>
                        <button class="btn-small" onclick="switchTab('analytics')" style="background: linear-gradient(145deg, #7b1fa2, #4a148c); color: white;"> Analytics</button>
                    </div>
                </div>`;

                if (quickActionsRegex.test(html)) {
                    html = html.replace(quickActionsRegex, newQuickActions);
                }
            }

            return html;
        };

        console.log(' UI enhancements loaded successfully!');


        // ============================================
        // TUBA AUTHENTICATION FIX PATCH v1.0
        // Auto-applied on 2025-10-20T19:50:55.516Z
        // Fixes 404 error during registration
        // ============================================

        (function () {
            console.log(' Applying authentication fix patch...');

            // Override signUp function with enhanced error handling
            window.signUp = async function (email, password) {
                try {
                    console.log(' Attempting to sign up:', email);

                    // Validate inputs
                    if (!email || !password) {
                        showToast('Please provide email and password', 'error');
                        return null;
                    }

                    if (password.length < 6) {
                        showToast('Password must be at least 6 characters', 'error');
                        return null;
                    }

                    // Check if supabase is initialized
                    if (!supabase) {
                        console.error(' Supabase not initialized');
                        showToast('Database connection error. Please refresh the page.', 'error');
                        return null;
                    }

                    // Attempt sign up with enhanced options
                    const { data, error } = await supabase.auth.signUp({
                        email: email.trim(),
                        password: password,
                        options: {
                            emailRedirectTo: APP_BASE_URL + '#signup-confirmed',
                            data: {
                                created_at: new Date().toISOString(),
                                app_version: '2.0'
                            }
                        }
                    });

                    if (error) {
                        console.error(' Sign up error:', error);

                        // Handle specific error codes
                        if (error.message.includes('User already registered') || error.message.includes('already been registered')) {
                            showToast('This email is already registered. Try signing in instead.', 'error');
                        } else if (error.message.includes('Invalid email')) {
                            showToast('Please enter a valid email address', 'error');
                        } else if (error.status === 404 || error.message.includes('404')) {
                            showToast(' Authentication service configuration error', 'error');
                            console.error(' Possible causes:');
                            console.error('   1. Invalid Supabase URL');
                            console.error('   2. Wrong API key');
                            console.error('   3. Email auth not enabled in Supabase dashboard');
                            console.error('   4. Project paused or deleted');
                            console.error('    Check your Supabase dashboard: https://supabase.com/dashboard');
                        } else if (error.message.includes('Email not confirmed')) {
                            showToast('Please confirm your email address', 'info');
                        } else {
                            showToast('Sign up error: ' + error.message, 'error');
                        }

                        return null;
                    }

                    console.log(' Sign up response:', data);

                    // Check if email confirmation is required
                    if (data.user && !data.session) {
                        showToast(' Account created! Please check your email to confirm.', 'success');
                        console.log(' Email confirmation required. Check your inbox.');
                    } else if (data.user && data.session) {
                        showToast(' Account created and logged in successfully!', 'success');
                        currentUser = data.user;
                        syncEnabled = true;
                        updateSyncIndicator('synced');

                        // Initialize user profile
                        await loadUserProfile();
                        render();
                    } else if (data.user && data.user.identities && data.user.identities.length === 0) {
                        showToast('This email is already registered. Please sign in instead.', 'info');
                    }

                    return data;

                } catch (error) {
                    console.error(' Sign up exception:', error);
                    showToast('Unexpected error during sign up. Please try again.', 'error');
                    return null;
                }
            };

            // Override handleSignUp function
            window.handleSignUp = async function () {
                const email = document.getElementById('signupEmail')?.value;
                const password = document.getElementById('signupPassword')?.value;
                const confirm = document.getElementById('signupPasswordConfirm')?.value;

                if (!email || !password || !confirm) {
                    return showToast('Please fill in all fields', 'error');
                }

                // Email validation
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(email)) {
                    return showToast('Please enter a valid email address', 'error');
                }

                if (password !== confirm) {
                    return showToast('Passwords do not match', 'error');
                }

                if (password.length < 6) {
                    return showToast('Password must be at least 6 characters', 'error');
                }

                // Disable buttons during sign up
                const signupForm = document.getElementById('signupForm');
                if (signupForm) {
                    const buttons = signupForm.querySelectorAll('button');
                    buttons.forEach(btn => {
                        btn.disabled = true;
                        btn.style.opacity = '0.6';
                        btn.style.cursor = 'not-allowed';
                    });
                }

                try {
                    await window.signUp(email, password);
                } finally {
                    // Re-enable buttons
                    if (signupForm) {
                        const buttons = signupForm.querySelectorAll('button');
                        buttons.forEach(btn => {
                            btn.disabled = false;
                            btn.style.opacity = '1';
                            btn.style.cursor = 'pointer';
                        });
                    }
                }
            };

            // Enhanced handleSignIn with better error handling
            const originalHandleSignIn = window.handleSignIn;
            window.handleSignIn = async function () {
                try { state.autoAuthDisabled = false; saveData(); } catch { }
                const email = document.getElementById('loginEmail')?.value;
                const password = document.getElementById('loginPassword')?.value;

                if (!email || !password) {
                    return showToast('Please fill in all fields', 'error');
                }

                // Email validation
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(email)) {
                    return showToast('Please enter a valid email address', 'error');
                }

                // Disable button during sign in
                const loginForm = document.getElementById('loginForm');
                if (loginForm) {
                    const buttons = loginForm.querySelectorAll('button');
                    buttons.forEach(btn => {
                        btn.disabled = true;
                        btn.style.opacity = '0.6';
                        btn.style.cursor = 'not-allowed';
                    });
                }

                try {
                    const result = await signIn(email, password);
                    if (result) {
                        render();
                    }
                } catch (error) {
                    console.error('Handle sign in error:', error);
                } finally {
                    // Re-enable buttons
                    if (loginForm) {
                        const buttons = loginForm.querySelectorAll('button');
                        buttons.forEach(btn => {
                            btn.disabled = false;
                            btn.style.opacity = '1';
                            btn.style.cursor = 'pointer';
                        });
                    }
                }
            };

            // Enhanced signIn function with better error handling
            const originalSignIn = window.signIn;
            window.signIn = async function (email, password) {
                try {
                    console.log(' Attempting to sign in:', email);

                    const { data, error } = await supabase.auth.signInWithPassword({
                        email: email.trim(),
                        password: password
                    });

                    if (error) {
                        console.error(' Sign in error:', error);

                        if (error.message.includes('Invalid login credentials')) {
                            showToast('Invalid email or password', 'error');
                        } else if (error.message.includes('Email not confirmed')) {
                            showToast('Please confirm your email address first', 'error');
                        } else if (error.status === 404) {
                            showToast('Authentication service error. Check your connection.', 'error');
                        } else {
                            showToast('Sign in error: ' + error.message, 'error');
                        }

                        currentUser = null;
                        syncEnabled = false;
                        return null;
                    }

                    currentUser = data.user;
                    syncEnabled = true;

                    showToast(' Signed in successfully!', 'success');

                    // Hydrate profile and logo
                    await loadUserProfile();
                    try { await ensureLogoReady(); } catch (e) { /* no-op */ }
                    // if (state.userLogoDataUrl) {
                    //     try { await uploadLogoToSupabase(state.userLogoDataUrl, state.userLogoMime || 'image/png'); } catch (e) { console.warn('Logo upload after sign-in failed:', e); }
                    // }
                    try { window.updateAuthBanner && window.updateAuthBanner(); } catch (e) { /* no-op */ }

                    // Load user profile first
                    await loadUserProfile();

                    // Upload logo if selected locally
                    if (state.userLogoDataUrl) {
                        try { await uploadLogoToSupabase(state.userLogoDataUrl, state.userLogoMime || 'image/png'); } catch (e) { console.warn('Logo upload after sign-in failed:', e); }
                    }

                    // Check if local data exists
                    const localHasData = state.sales.length > 0 || state.products.length > 0;

                    try {
                        if (localHasData) {
                            showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);
                            await smartMergeData();
                            showToast('Local and cloud data merged successfully', 'success');
                        } else {
                            showToast('Loading Your Data, Please wait...', 'info', null, null, 8000);
                            await pullDataFromSupabase();
                            showToast('Cloud data loaded', 'success');
                        }
                    } catch (syncError) {
                        console.error('Sync error after sign in:', syncError);
                        showToast('Signed in but sync failed. Try manual sync.', 'error');
                    }

                    try {
                        if (window.isSecureContext && navigator.credentials && window.PasswordCredential) {
                            const c = new PasswordCredential({ id: email.trim(), password: password });
                            try { navigator.credentials.store(c); } catch (e) { }
                        }
                    } catch (e) { }
                    return data;
                } catch (error) {
                    console.error('Sign in exception:', error);
                    showToast('Sign in error: ' + error.message, 'error');
                    currentUser = null;
                    syncEnabled = false;
                    return null;
                }
            };

            // Diagnostic function - run this in console to test connection
            window.testSupabaseConnection = async function () {
                console.log(' Running Supabase diagnostics...');
                console.log('==========================================');
                console.log('URL:', SUPABASE_URL);
                console.log('Key:', SUPABASE_ANON_KEY.substring(0, 30) + '...');
                console.log('Supabase initialized:', !!supabase);
                console.log('Current user:', currentUser?.email || 'Not logged in');
                console.log('Sync enabled:', syncEnabled);
                console.log('==========================================');

                if (!supabase) {
                    console.error(' Supabase not initialized!');
                    console.error(' Check if the Supabase script loaded correctly');
                    return false;
                }

                try {
                    // Test session
                    console.log('Testing session...');
                    const { data: sessionData, error: sessionError } = await supabase.auth.getSession();

                    if (sessionError) {
                        console.error(' Session test failed:', sessionError);
                    } else {
                        console.log(' Session test passed');
                    }

                    // Test direct auth endpoint
                    console.log('Testing auth endpoint...');
                    const response = await fetch(SUPABASE_URL + '/auth/v1/health', {
                        headers: {
                            'apikey': SUPABASE_ANON_KEY
                        }
                    });

                    console.log('Auth endpoint status:', response.status);

                    if (response.status === 404) {
                        console.error(' 404 Error - Possible issues:');
                        console.error('   1. Incorrect Supabase URL');
                        console.error('   2. Project paused or deleted');
                        console.error('   3. Invalid API key');
                        console.error(' Go to: https://supabase.com/dashboard');
                        console.error(' Verify your project settings');
                        return false;
                    } else if (response.ok) {
                        console.log(' Auth endpoint accessible');
                    }

                    console.log('==========================================');
                    console.log(' Diagnostics complete');
                    return true;

                } catch (error) {
                    console.error(' Connection test exception:', error);
                    console.error(' Check your internet connection');
                    console.error(' Verify Supabase project is active');
                    return false;
                }
            };

            // Auto-run diagnostics if there's a connection issue
            setTimeout(() => {
                if (!supabase || !SUPABASE_URL || !SUPABASE_ANON_KEY) {
                    console.error(' Supabase configuration incomplete!');
                    console.error('Run testSupabaseConnection() in console for diagnostics');
                }
            }, 2000);

            console.log(' Authentication fix patch applied successfully!');
            console.log(' Available commands:');
            console.log('    testSupabaseConnection() - Test your Supabase setup');
            console.log('');
            console.log(' Troubleshooting steps:');
            console.log('   1. Run: testSupabaseConnection()');
            console.log('   2. Check Supabase dashboard: https://supabase.com/dashboard');
            console.log('   3. Verify Email auth is enabled');
            console.log('   4. Check if email confirmation is required');
        })();

        // Mobile App Enhancements
        (function () {
            'use strict';

            // Splash Screen Management
            // Removed in-app pull-to-refresh functionality

            // PWA Installation
            let deferredPrompt;
            let installButton;

            window.addEventListener('beforeinstallprompt', (e) => {
                e.preventDefault();
                deferredPrompt = e;
                showInstallButton();
            });

            function showInstallButton() {
                // Create install button if it doesn't exist
                if (!installButton) {
                    installButton = document.createElement('button');
                    installButton.innerHTML = ' Install App';
                    installButton.className = 'btn btn-success';
                    installButton.style.cssText = `
                        position: fixed;
                        bottom: 80px;
                        right: 16px;
                        z-index: 1000;
                        padding: 8px 12px;
                        font-size: 12px;
                        width: auto;
                        border-radius: 20px;
                    `;
                    installButton.onclick = installApp;
                    document.body.appendChild(installButton);
                }
            }

            async function installApp() {
                if (!deferredPrompt) return;

                deferredPrompt.prompt();
                const { outcome } = await deferredPrompt.userChoice;

                if (outcome === 'accepted') {
                    console.log('PWA installed successfully');
                    showToast('App installed successfully!', 'success');
                } else {
                    console.log('PWA installation declined');
                }

                deferredPrompt = null;
                if (installButton) {
                    installButton.remove();
                    installButton = null;
                }
            }



            // Offline banner: ensure element exists and update immediately and on connectivity changes
            (function () {
                const getOfflineBannerEl = () => {
                    let el = document.getElementById('offlineBanner');
                    if (!el) {
                        el = document.createElement('div');
                        el.id = 'offlineBanner';
                        el.className = 'offline-banner';
                        el.setAttribute('role', 'status');
                        el.setAttribute('aria-live', 'polite');
                        el.setAttribute('aria-atomic', 'true');
                        const headerEl = document.querySelector('.header');
                        if (headerEl && headerEl.parentNode) {
                            headerEl.parentNode.insertBefore(el, headerEl.nextSibling);
                        } else if (document.body) {
                            document.body.insertBefore(el, document.body.firstChild);
                        }
                    }
                    return el;
                };

                const updateOfflineBanner = () => {
                    const offlineBannerEl = getOfflineBannerEl();
                    if (!offlineBannerEl) return;
                    if (navigator.onLine) {
                        offlineBannerEl.style.display = 'none';
                        offlineBannerEl.textContent = '';
                        offlineBannerEl.onclick = null;
                        offlineBannerEl.classList.remove('clickable');
                    } else {
                        offlineBannerEl.innerHTML = "Youre offline  Changes are saved locally <span style='opacity:0.9'>(Click for Info)</span>";
                        offlineBannerEl.style.display = 'block';
                        offlineBannerEl.onclick = () => { try { openOfflineInfoModal(); } catch (e) { } };
                        offlineBannerEl.classList.add('clickable');
                    }
                    try { adjustContentPadding(); } catch { }
                };

                updateOfflineBanner();
                window.addEventListener('online', updateOfflineBanner);
                window.addEventListener('offline', updateOfflineBanner);

                window.updateOfflineBanner = updateOfflineBanner;
            })();

            (function () {
                let isAuthRestoring = true;
                const getAuthBannerEl = () => {
                    let el = document.getElementById('authBanner');
                    if (!el) {
                        el = document.createElement('div');
                        el.id = 'authBanner';
                        el.className = 'offline-banner auth-banner';
                        el.setAttribute('role', 'status');
                        el.setAttribute('aria-live', 'polite');
                        el.setAttribute('aria-atomic', 'true');
                        const headerEl = document.querySelector('.header');
                        if (headerEl && headerEl.parentNode) {
                            headerEl.parentNode.insertBefore(el, headerEl.nextSibling.nextSibling);
                        } else if (document.body) {
                            document.body.insertBefore(el, document.body.firstChild);
                        }
                    }
                    return el;
                };
                window.updateAuthBanner = () => {
                    const el = getAuthBannerEl();
                    if (!el) return;
                    if (!navigator.onLine) {
                        el.style.display = 'none';
                        el.textContent = '';
                        el.onclick = null;
                    } else if (isAuthRestoring) {
                        el.innerHTML = "Restoring session";
                        el.style.display = 'block';
                        el.onclick = null;
                    } else if (currentUser && syncEnabled) {
                        el.style.display = 'none';
                        el.textContent = '';
                        el.onclick = null;
                    } else {
                        el.innerHTML = "Youre not signed in  tap to sign in and sync.";
                        el.style.display = 'block';
                        el.onclick = () => {
                            try {
                                switchTab('account');
                                setTimeout(() => {
                                    try { switchAuthTab('login'); } catch (e) { }
                                    const lf = document.getElementById('loginForm');
                                    lf && lf.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                }, 50);
                            } catch (e) { }
                        };
                    }
                    try { adjustContentPadding(); } catch { }
                };
                window.updateAuthBanner();
                window.addEventListener('online', () => {
                    try { window.updateAuthBanner(); } catch { }
                    try {
                        if (!currentUser) {
                            showToast('Back online  sign in to sync your data', 'info');
                        }
                    } catch { }
                });
                window.addEventListener('offline', () => { try { window.updateAuthBanner(); } catch { } });
                window.setAuthRestoring = (v) => { isAuthRestoring = !!v; };
            })();

            // Service Worker Registration and Capacitor Initialization
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', async () => {
                    try {
                        // Initialize Capacitor plugins if available
                        if (window.Capacitor) {
                            const { CapacitorApp } = await import('@capacitor/app');
                            const { StatusBar, Style } = await import('@capacitor/status-bar');

                            // Set status bar style
                            await StatusBar.setStyle({ style: Style.Dark });

                            console.log('Capacitor plugins initialized');
                        }

                        const registration = await navigator.serviceWorker.register('./sw.js', { scope: './' });
                        console.log('SW registered: ', registration);





                        // Initial state and event listeners
                        window.updateAuthBanner && window.updateAuthBanner();
                        // Periodic auth heartbeat to keep UI in sync
                        async function refreshAuthState() {
                            try {
                                if (!navigator.onLine) return;
                                if (!window.supabase || !supabase || !supabase.auth) return;
                                const { data: { session } } = await supabase.auth.getSession();
                                if (session && session.user) {
                                    currentUser = session.user;
                                    syncEnabled = true;
                                    try {
                                        const t = (session.user?.user_metadata?.theme || '').toLowerCase();
                                        if (t === 'dark' || t === 'light') {
                                            if (state.theme !== t) {
                                                state.theme = t;
                                                saveData();
                                                applyTheme();
                                            }
                                        }
                                    } catch (e) { }
                                } else {
                                    currentUser = null;
                                    syncEnabled = false;
                                }
                            } catch { }
                            try { window.setAuthRestoring(false); } catch { }
                            window.updateAuthBanner && window.updateAuthBanner();
                            updateSideNavAuthButton && updateSideNavAuthButton();
                        }
                        // On load, after SW ready, reconcile auth state
                        try { refreshAuthState(); } catch { }
                        // Also reconcile on online and visibility changes
                        window.addEventListener('online', refreshAuthState);
                        document.addEventListener('visibilitychange', () => { if (!document.hidden) refreshAuthState(); });
                        // Cross-tab sync via storage events
                        window.addEventListener('storage', (e) => {
                            const k = e.key || '';
                            if (k.includes('tuba-auth-token') || k.includes('sb-')) {
                                refreshAuthState();
                            }
                        });
                        // Periodic heartbeat
                        setInterval(refreshAuthState, 60000);
                        window.addEventListener('online', () => {
                            window.updateAuthBanner && window.updateAuthBanner();
                            try {
                                if (navigator.serviceWorker && navigator.serviceWorker.ready) {
                                    navigator.serviceWorker.ready.then(reg => {
                                        if (reg.sync && typeof reg.sync.register === 'function') {
                                            reg.sync.register('background-sync').catch(() => { });
                                        }
                                    });
                                }
                                // Trigger a background sync merge immediately when online
                                if (syncEnabled && currentUser) {
                                    try { syncInBackground(); } catch (e) { /* no-op */ }
                                }
                            } catch (e) { /* no-op */ }
                        });
                        window.addEventListener('offline', () => {
                            window.updateAuthBanner && window.updateAuthBanner();
                        });

                        // Check for updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    showToast('New version available! Refresh to update.', 'info');
                                }
                            });
                        });
                        // FAB removed; bottom tabs used for navigation
                    } catch (error) {
                        console.log('SW registration failed: ', error);
                    }
                });
            }

            // Enhanced Touch Feedback
            function addTouchFeedback() {
                const touchElements = document.querySelectorAll('button, .btn, .nav-item, .stat-card, .item, .quick-nav-btn');

                touchElements.forEach(element => {
                    element.addEventListener('touchstart', function () {
                        this.style.transform = 'scale(0.98)';
                        this.style.transition = 'transform 0.1s ease';
                    });

                    element.addEventListener('touchend', function () {
                        this.style.transform = '';
                    });

                    element.addEventListener('touchcancel', function () {
                        this.style.transform = '';
                    });
                });
            }

            // Prevent zoom on double tap
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function (event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);

            // Initialize mobile features
            document.addEventListener('DOMContentLoaded', function () {
                addTouchFeedback();
                try { if (!isIOSSafari()) { attemptSilentCredentialSignIn(); } } catch (e) { }
                if (!currentUser && !isIOSSafari()) {
                    try { autoSubmitLoginIfAutofilled(); } catch (e) { }
                }

                // Ensure apple-touch-icon hrefs are absolute for iOS launchers
                try {
                    const origin = window.location.origin || '';
                    document.querySelectorAll('link[rel="apple-touch-icon"], link[rel="apple-touch-icon-precomposed"]').forEach(link => {
                        const href = link.getAttribute('href') || '';
                        if (href && !href.startsWith('http') && origin) {
                            link.setAttribute('href', origin.replace(/\/$/, '') + '/' + href.replace(/^\//, ''));
                        }
                    });
                } catch { }

                window.addEventListener('orientationchange', function () {
                    setTimeout(() => {
                        window.scrollTo(0, 1);
                        try { adjustContentPadding(); } catch { }
                    }, 500);
                });

                document.addEventListener('visibilitychange', function () {
                    if (document.visibilityState === 'visible') {
                        console.log('App became visible');
                    }
                });
            });

            // Expose functions globally for debugging
            window.mobileApp = {
                installApp,
                addTouchFeedback
            };
        })();

    </script>
</body>

<script>window.API_URL = 'https://tuba-pwa.vercel.app'</script>

</html>